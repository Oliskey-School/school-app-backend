
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model ParentChild
 * 
 */
export type ParentChild = $Result.DefaultSelection<Prisma.$ParentChildPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model TeacherSubject
 * 
 */
export type TeacherSubject = $Result.DefaultSelection<Prisma.$TeacherSubjectPayload>
/**
 * Model TeacherClass
 * 
 */
export type TeacherClass = $Result.DefaultSelection<Prisma.$TeacherClassPayload>
/**
 * Model Timetable
 * 
 */
export type Timetable = $Result.DefaultSelection<Prisma.$TimetablePayload>
/**
 * Model StudentAttendance
 * 
 */
export type StudentAttendance = $Result.DefaultSelection<Prisma.$StudentAttendancePayload>
/**
 * Model AcademicPerformance
 * 
 */
export type AcademicPerformance = $Result.DefaultSelection<Prisma.$AcademicPerformancePayload>
/**
 * Model BehaviorRecord
 * 
 */
export type BehaviorRecord = $Result.DefaultSelection<Prisma.$BehaviorRecordPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Award
 * 
 */
export type Award = $Result.DefaultSelection<Prisma.$AwardPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model Submission
 * 
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model Notice
 * 
 */
export type Notice = $Result.DefaultSelection<Prisma.$NoticePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ForumTopic
 * 
 */
export type ForumTopic = $Result.DefaultSelection<Prisma.$ForumTopicPayload>
/**
 * Model ForumPost
 * 
 */
export type ForumPost = $Result.DefaultSelection<Prisma.$ForumPostPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model BusRoute
 * 
 */
export type BusRoute = $Result.DefaultSelection<Prisma.$BusRoutePayload>
/**
 * Model BusRoster
 * 
 */
export type BusRoster = $Result.DefaultSelection<Prisma.$BusRosterPayload>
/**
 * Model PickupPoint
 * 
 */
export type PickupPoint = $Result.DefaultSelection<Prisma.$PickupPointPayload>
/**
 * Model StudentFee
 * 
 */
export type StudentFee = $Result.DefaultSelection<Prisma.$StudentFeePayload>
/**
 * Model FeePayment
 * 
 */
export type FeePayment = $Result.DefaultSelection<Prisma.$FeePaymentPayload>
/**
 * Model StoreProduct
 * 
 */
export type StoreProduct = $Result.DefaultSelection<Prisma.$StoreProductPayload>
/**
 * Model StoreOrder
 * 
 */
export type StoreOrder = $Result.DefaultSelection<Prisma.$StoreOrderPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model HealthLog
 * 
 */
export type HealthLog = $Result.DefaultSelection<Prisma.$HealthLogPayload>
/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model DigitalResource
 * 
 */
export type DigitalResource = $Result.DefaultSelection<Prisma.$DigitalResourcePayload>
/**
 * Model CbtTest
 * 
 */
export type CbtTest = $Result.DefaultSelection<Prisma.$CbtTestPayload>
/**
 * Model CbtQuestion
 * 
 */
export type CbtQuestion = $Result.DefaultSelection<Prisma.$CbtQuestionPayload>
/**
 * Model CbtResult
 * 
 */
export type CbtResult = $Result.DefaultSelection<Prisma.$CbtResultPayload>
/**
 * Model CalendarEvent
 * 
 */
export type CalendarEvent = $Result.DefaultSelection<Prisma.$CalendarEventPayload>
/**
 * Model ExtracurricularActivity
 * 
 */
export type ExtracurricularActivity = $Result.DefaultSelection<Prisma.$ExtracurricularActivityPayload>
/**
 * Model PtaMeeting
 * 
 */
export type PtaMeeting = $Result.DefaultSelection<Prisma.$PtaMeetingPayload>
/**
 * Model SchoolPolicy
 * 
 */
export type SchoolPolicy = $Result.DefaultSelection<Prisma.$SchoolPolicyPayload>
/**
 * Model VolunteeringOpportunity
 * 
 */
export type VolunteeringOpportunity = $Result.DefaultSelection<Prisma.$VolunteeringOpportunityPayload>
/**
 * Model PermissionSlip
 * 
 */
export type PermissionSlip = $Result.DefaultSelection<Prisma.$PermissionSlipPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model PdResource
 * 
 */
export type PdResource = $Result.DefaultSelection<Prisma.$PdResourcePayload>
/**
 * Model AiGame
 * 
 */
export type AiGame = $Result.DefaultSelection<Prisma.$AiGamePayload>
/**
 * Model LessonPlan
 * 
 */
export type LessonPlan = $Result.DefaultSelection<Prisma.$LessonPlanPayload>
/**
 * Model GeneratedResource
 * 
 */
export type GeneratedResource = $Result.DefaultSelection<Prisma.$GeneratedResourcePayload>
/**
 * Model ReportCard
 * 
 */
export type ReportCard = $Result.DefaultSelection<Prisma.$ReportCardPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs>;

  /**
   * `prisma.parentChild`: Exposes CRUD operations for the **ParentChild** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentChildren
    * const parentChildren = await prisma.parentChild.findMany()
    * ```
    */
  get parentChild(): Prisma.ParentChildDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.teacherSubject`: Exposes CRUD operations for the **TeacherSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherSubjects
    * const teacherSubjects = await prisma.teacherSubject.findMany()
    * ```
    */
  get teacherSubject(): Prisma.TeacherSubjectDelegate<ExtArgs>;

  /**
   * `prisma.teacherClass`: Exposes CRUD operations for the **TeacherClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherClasses
    * const teacherClasses = await prisma.teacherClass.findMany()
    * ```
    */
  get teacherClass(): Prisma.TeacherClassDelegate<ExtArgs>;

  /**
   * `prisma.timetable`: Exposes CRUD operations for the **Timetable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timetables
    * const timetables = await prisma.timetable.findMany()
    * ```
    */
  get timetable(): Prisma.TimetableDelegate<ExtArgs>;

  /**
   * `prisma.studentAttendance`: Exposes CRUD operations for the **StudentAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAttendances
    * const studentAttendances = await prisma.studentAttendance.findMany()
    * ```
    */
  get studentAttendance(): Prisma.StudentAttendanceDelegate<ExtArgs>;

  /**
   * `prisma.academicPerformance`: Exposes CRUD operations for the **AcademicPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicPerformances
    * const academicPerformances = await prisma.academicPerformance.findMany()
    * ```
    */
  get academicPerformance(): Prisma.AcademicPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.behaviorRecord`: Exposes CRUD operations for the **BehaviorRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehaviorRecords
    * const behaviorRecords = await prisma.behaviorRecord.findMany()
    * ```
    */
  get behaviorRecord(): Prisma.BehaviorRecordDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.award`: Exposes CRUD operations for the **Award** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Awards
    * const awards = await prisma.award.findMany()
    * ```
    */
  get award(): Prisma.AwardDelegate<ExtArgs>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.forumTopic`: Exposes CRUD operations for the **ForumTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumTopics
    * const forumTopics = await prisma.forumTopic.findMany()
    * ```
    */
  get forumTopic(): Prisma.ForumTopicDelegate<ExtArgs>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<ExtArgs>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs>;

  /**
   * `prisma.busRoute`: Exposes CRUD operations for the **BusRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusRoutes
    * const busRoutes = await prisma.busRoute.findMany()
    * ```
    */
  get busRoute(): Prisma.BusRouteDelegate<ExtArgs>;

  /**
   * `prisma.busRoster`: Exposes CRUD operations for the **BusRoster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusRosters
    * const busRosters = await prisma.busRoster.findMany()
    * ```
    */
  get busRoster(): Prisma.BusRosterDelegate<ExtArgs>;

  /**
   * `prisma.pickupPoint`: Exposes CRUD operations for the **PickupPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PickupPoints
    * const pickupPoints = await prisma.pickupPoint.findMany()
    * ```
    */
  get pickupPoint(): Prisma.PickupPointDelegate<ExtArgs>;

  /**
   * `prisma.studentFee`: Exposes CRUD operations for the **StudentFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentFees
    * const studentFees = await prisma.studentFee.findMany()
    * ```
    */
  get studentFee(): Prisma.StudentFeeDelegate<ExtArgs>;

  /**
   * `prisma.feePayment`: Exposes CRUD operations for the **FeePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeePayments
    * const feePayments = await prisma.feePayment.findMany()
    * ```
    */
  get feePayment(): Prisma.FeePaymentDelegate<ExtArgs>;

  /**
   * `prisma.storeProduct`: Exposes CRUD operations for the **StoreProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreProducts
    * const storeProducts = await prisma.storeProduct.findMany()
    * ```
    */
  get storeProduct(): Prisma.StoreProductDelegate<ExtArgs>;

  /**
   * `prisma.storeOrder`: Exposes CRUD operations for the **StoreOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreOrders
    * const storeOrders = await prisma.storeOrder.findMany()
    * ```
    */
  get storeOrder(): Prisma.StoreOrderDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.healthLog`: Exposes CRUD operations for the **HealthLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthLogs
    * const healthLogs = await prisma.healthLog.findMany()
    * ```
    */
  get healthLog(): Prisma.HealthLogDelegate<ExtArgs>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs>;

  /**
   * `prisma.digitalResource`: Exposes CRUD operations for the **DigitalResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DigitalResources
    * const digitalResources = await prisma.digitalResource.findMany()
    * ```
    */
  get digitalResource(): Prisma.DigitalResourceDelegate<ExtArgs>;

  /**
   * `prisma.cbtTest`: Exposes CRUD operations for the **CbtTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CbtTests
    * const cbtTests = await prisma.cbtTest.findMany()
    * ```
    */
  get cbtTest(): Prisma.CbtTestDelegate<ExtArgs>;

  /**
   * `prisma.cbtQuestion`: Exposes CRUD operations for the **CbtQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CbtQuestions
    * const cbtQuestions = await prisma.cbtQuestion.findMany()
    * ```
    */
  get cbtQuestion(): Prisma.CbtQuestionDelegate<ExtArgs>;

  /**
   * `prisma.cbtResult`: Exposes CRUD operations for the **CbtResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CbtResults
    * const cbtResults = await prisma.cbtResult.findMany()
    * ```
    */
  get cbtResult(): Prisma.CbtResultDelegate<ExtArgs>;

  /**
   * `prisma.calendarEvent`: Exposes CRUD operations for the **CalendarEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarEvents
    * const calendarEvents = await prisma.calendarEvent.findMany()
    * ```
    */
  get calendarEvent(): Prisma.CalendarEventDelegate<ExtArgs>;

  /**
   * `prisma.extracurricularActivity`: Exposes CRUD operations for the **ExtracurricularActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtracurricularActivities
    * const extracurricularActivities = await prisma.extracurricularActivity.findMany()
    * ```
    */
  get extracurricularActivity(): Prisma.ExtracurricularActivityDelegate<ExtArgs>;

  /**
   * `prisma.ptaMeeting`: Exposes CRUD operations for the **PtaMeeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PtaMeetings
    * const ptaMeetings = await prisma.ptaMeeting.findMany()
    * ```
    */
  get ptaMeeting(): Prisma.PtaMeetingDelegate<ExtArgs>;

  /**
   * `prisma.schoolPolicy`: Exposes CRUD operations for the **SchoolPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolPolicies
    * const schoolPolicies = await prisma.schoolPolicy.findMany()
    * ```
    */
  get schoolPolicy(): Prisma.SchoolPolicyDelegate<ExtArgs>;

  /**
   * `prisma.volunteeringOpportunity`: Exposes CRUD operations for the **VolunteeringOpportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolunteeringOpportunities
    * const volunteeringOpportunities = await prisma.volunteeringOpportunity.findMany()
    * ```
    */
  get volunteeringOpportunity(): Prisma.VolunteeringOpportunityDelegate<ExtArgs>;

  /**
   * `prisma.permissionSlip`: Exposes CRUD operations for the **PermissionSlip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissionSlips
    * const permissionSlips = await prisma.permissionSlip.findMany()
    * ```
    */
  get permissionSlip(): Prisma.PermissionSlipDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.pdResource`: Exposes CRUD operations for the **PdResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PdResources
    * const pdResources = await prisma.pdResource.findMany()
    * ```
    */
  get pdResource(): Prisma.PdResourceDelegate<ExtArgs>;

  /**
   * `prisma.aiGame`: Exposes CRUD operations for the **AiGame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiGames
    * const aiGames = await prisma.aiGame.findMany()
    * ```
    */
  get aiGame(): Prisma.AiGameDelegate<ExtArgs>;

  /**
   * `prisma.lessonPlan`: Exposes CRUD operations for the **LessonPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonPlans
    * const lessonPlans = await prisma.lessonPlan.findMany()
    * ```
    */
  get lessonPlan(): Prisma.LessonPlanDelegate<ExtArgs>;

  /**
   * `prisma.generatedResource`: Exposes CRUD operations for the **GeneratedResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedResources
    * const generatedResources = await prisma.generatedResource.findMany()
    * ```
    */
  get generatedResource(): Prisma.GeneratedResourceDelegate<ExtArgs>;

  /**
   * `prisma.reportCard`: Exposes CRUD operations for the **ReportCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportCards
    * const reportCards = await prisma.reportCard.findMany()
    * ```
    */
  get reportCard(): Prisma.ReportCardDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Student: 'Student',
    Teacher: 'Teacher',
    Parent: 'Parent',
    ParentChild: 'ParentChild',
    Class: 'Class',
    TeacherSubject: 'TeacherSubject',
    TeacherClass: 'TeacherClass',
    Timetable: 'Timetable',
    StudentAttendance: 'StudentAttendance',
    AcademicPerformance: 'AcademicPerformance',
    BehaviorRecord: 'BehaviorRecord',
    Badge: 'Badge',
    Certificate: 'Certificate',
    Award: 'Award',
    Assignment: 'Assignment',
    Submission: 'Submission',
    Exam: 'Exam',
    Notice: 'Notice',
    Notification: 'Notification',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    ForumTopic: 'ForumTopic',
    ForumPost: 'ForumPost',
    Complaint: 'Complaint',
    Driver: 'Driver',
    BusRoute: 'BusRoute',
    BusRoster: 'BusRoster',
    PickupPoint: 'PickupPoint',
    StudentFee: 'StudentFee',
    FeePayment: 'FeePayment',
    StoreProduct: 'StoreProduct',
    StoreOrder: 'StoreOrder',
    AuditLog: 'AuditLog',
    HealthLog: 'HealthLog',
    Book: 'Book',
    DigitalResource: 'DigitalResource',
    CbtTest: 'CbtTest',
    CbtQuestion: 'CbtQuestion',
    CbtResult: 'CbtResult',
    CalendarEvent: 'CalendarEvent',
    ExtracurricularActivity: 'ExtracurricularActivity',
    PtaMeeting: 'PtaMeeting',
    SchoolPolicy: 'SchoolPolicy',
    VolunteeringOpportunity: 'VolunteeringOpportunity',
    PermissionSlip: 'PermissionSlip',
    Appointment: 'Appointment',
    PdResource: 'PdResource',
    AiGame: 'AiGame',
    LessonPlan: 'LessonPlan',
    GeneratedResource: 'GeneratedResource',
    ReportCard: 'ReportCard'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "student" | "teacher" | "parent" | "parentChild" | "class" | "teacherSubject" | "teacherClass" | "timetable" | "studentAttendance" | "academicPerformance" | "behaviorRecord" | "badge" | "certificate" | "award" | "assignment" | "submission" | "exam" | "notice" | "notification" | "conversation" | "conversationParticipant" | "message" | "forumTopic" | "forumPost" | "complaint" | "driver" | "busRoute" | "busRoster" | "pickupPoint" | "studentFee" | "feePayment" | "storeProduct" | "storeOrder" | "auditLog" | "healthLog" | "book" | "digitalResource" | "cbtTest" | "cbtQuestion" | "cbtResult" | "calendarEvent" | "extracurricularActivity" | "ptaMeeting" | "schoolPolicy" | "volunteeringOpportunity" | "permissionSlip" | "appointment" | "pdResource" | "aiGame" | "lessonPlan" | "generatedResource" | "reportCard"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      ParentChild: {
        payload: Prisma.$ParentChildPayload<ExtArgs>
        fields: Prisma.ParentChildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentChildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentChildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          findFirst: {
            args: Prisma.ParentChildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentChildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          findMany: {
            args: Prisma.ParentChildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>[]
          }
          create: {
            args: Prisma.ParentChildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          createMany: {
            args: Prisma.ParentChildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentChildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>[]
          }
          delete: {
            args: Prisma.ParentChildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          update: {
            args: Prisma.ParentChildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          deleteMany: {
            args: Prisma.ParentChildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentChildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentChildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentChildPayload>
          }
          aggregate: {
            args: Prisma.ParentChildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParentChild>
          }
          groupBy: {
            args: Prisma.ParentChildGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentChildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentChildCountArgs<ExtArgs>
            result: $Utils.Optional<ParentChildCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      TeacherSubject: {
        payload: Prisma.$TeacherSubjectPayload<ExtArgs>
        fields: Prisma.TeacherSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findFirst: {
            args: Prisma.TeacherSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findMany: {
            args: Prisma.TeacherSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          create: {
            args: Prisma.TeacherSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          createMany: {
            args: Prisma.TeacherSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          delete: {
            args: Prisma.TeacherSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          update: {
            args: Prisma.TeacherSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          deleteMany: {
            args: Prisma.TeacherSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          aggregate: {
            args: Prisma.TeacherSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherSubject>
          }
          groupBy: {
            args: Prisma.TeacherSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectCountAggregateOutputType> | number
          }
        }
      }
      TeacherClass: {
        payload: Prisma.$TeacherClassPayload<ExtArgs>
        fields: Prisma.TeacherClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          findFirst: {
            args: Prisma.TeacherClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          findMany: {
            args: Prisma.TeacherClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>[]
          }
          create: {
            args: Prisma.TeacherClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          createMany: {
            args: Prisma.TeacherClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>[]
          }
          delete: {
            args: Prisma.TeacherClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          update: {
            args: Prisma.TeacherClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          deleteMany: {
            args: Prisma.TeacherClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          aggregate: {
            args: Prisma.TeacherClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherClass>
          }
          groupBy: {
            args: Prisma.TeacherClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherClassCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassCountAggregateOutputType> | number
          }
        }
      }
      Timetable: {
        payload: Prisma.$TimetablePayload<ExtArgs>
        fields: Prisma.TimetableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimetableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimetableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findFirst: {
            args: Prisma.TimetableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimetableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findMany: {
            args: Prisma.TimetableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>[]
          }
          create: {
            args: Prisma.TimetableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          createMany: {
            args: Prisma.TimetableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimetableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>[]
          }
          delete: {
            args: Prisma.TimetableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          update: {
            args: Prisma.TimetableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          deleteMany: {
            args: Prisma.TimetableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimetableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimetableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          aggregate: {
            args: Prisma.TimetableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimetable>
          }
          groupBy: {
            args: Prisma.TimetableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimetableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimetableCountArgs<ExtArgs>
            result: $Utils.Optional<TimetableCountAggregateOutputType> | number
          }
        }
      }
      StudentAttendance: {
        payload: Prisma.$StudentAttendancePayload<ExtArgs>
        fields: Prisma.StudentAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findFirst: {
            args: Prisma.StudentAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          findMany: {
            args: Prisma.StudentAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          create: {
            args: Prisma.StudentAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          createMany: {
            args: Prisma.StudentAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>[]
          }
          delete: {
            args: Prisma.StudentAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          update: {
            args: Prisma.StudentAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          deleteMany: {
            args: Prisma.StudentAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAttendancePayload>
          }
          aggregate: {
            args: Prisma.StudentAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAttendance>
          }
          groupBy: {
            args: Prisma.StudentAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAttendanceCountAggregateOutputType> | number
          }
        }
      }
      AcademicPerformance: {
        payload: Prisma.$AcademicPerformancePayload<ExtArgs>
        fields: Prisma.AcademicPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          findFirst: {
            args: Prisma.AcademicPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          findMany: {
            args: Prisma.AcademicPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>[]
          }
          create: {
            args: Prisma.AcademicPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          createMany: {
            args: Prisma.AcademicPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>[]
          }
          delete: {
            args: Prisma.AcademicPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          update: {
            args: Prisma.AcademicPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          deleteMany: {
            args: Prisma.AcademicPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicPerformancePayload>
          }
          aggregate: {
            args: Prisma.AcademicPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicPerformance>
          }
          groupBy: {
            args: Prisma.AcademicPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicPerformanceCountAggregateOutputType> | number
          }
        }
      }
      BehaviorRecord: {
        payload: Prisma.$BehaviorRecordPayload<ExtArgs>
        fields: Prisma.BehaviorRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehaviorRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehaviorRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          findFirst: {
            args: Prisma.BehaviorRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehaviorRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          findMany: {
            args: Prisma.BehaviorRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>[]
          }
          create: {
            args: Prisma.BehaviorRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          createMany: {
            args: Prisma.BehaviorRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehaviorRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>[]
          }
          delete: {
            args: Prisma.BehaviorRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          update: {
            args: Prisma.BehaviorRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          deleteMany: {
            args: Prisma.BehaviorRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehaviorRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehaviorRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          aggregate: {
            args: Prisma.BehaviorRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehaviorRecord>
          }
          groupBy: {
            args: Prisma.BehaviorRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehaviorRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehaviorRecordCountArgs<ExtArgs>
            result: $Utils.Optional<BehaviorRecordCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Award: {
        payload: Prisma.$AwardPayload<ExtArgs>
        fields: Prisma.AwardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AwardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AwardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          findFirst: {
            args: Prisma.AwardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AwardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          findMany: {
            args: Prisma.AwardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>[]
          }
          create: {
            args: Prisma.AwardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          createMany: {
            args: Prisma.AwardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AwardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>[]
          }
          delete: {
            args: Prisma.AwardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          update: {
            args: Prisma.AwardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          deleteMany: {
            args: Prisma.AwardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AwardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AwardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AwardPayload>
          }
          aggregate: {
            args: Prisma.AwardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAward>
          }
          groupBy: {
            args: Prisma.AwardGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardGroupByOutputType>[]
          }
          count: {
            args: Prisma.AwardCountArgs<ExtArgs>
            result: $Utils.Optional<AwardCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>
        fields: Prisma.SubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      Notice: {
        payload: Prisma.$NoticePayload<ExtArgs>
        fields: Prisma.NoticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findFirst: {
            args: Prisma.NoticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          findMany: {
            args: Prisma.NoticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          create: {
            args: Prisma.NoticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          createMany: {
            args: Prisma.NoticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoticeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>[]
          }
          delete: {
            args: Prisma.NoticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          update: {
            args: Prisma.NoticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          deleteMany: {
            args: Prisma.NoticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticePayload>
          }
          aggregate: {
            args: Prisma.NoticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotice>
          }
          groupBy: {
            args: Prisma.NoticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ForumTopic: {
        payload: Prisma.$ForumTopicPayload<ExtArgs>
        fields: Prisma.ForumTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findFirst: {
            args: Prisma.ForumTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          findMany: {
            args: Prisma.ForumTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          create: {
            args: Prisma.ForumTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          createMany: {
            args: Prisma.ForumTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>[]
          }
          delete: {
            args: Prisma.ForumTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          update: {
            args: Prisma.ForumTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          deleteMany: {
            args: Prisma.ForumTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumTopicPayload>
          }
          aggregate: {
            args: Prisma.ForumTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumTopic>
          }
          groupBy: {
            args: Prisma.ForumTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumTopicCountArgs<ExtArgs>
            result: $Utils.Optional<ForumTopicCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: Prisma.$ForumPostPayload<ExtArgs>
        fields: Prisma.ForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplaintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      BusRoute: {
        payload: Prisma.$BusRoutePayload<ExtArgs>
        fields: Prisma.BusRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          findFirst: {
            args: Prisma.BusRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          findMany: {
            args: Prisma.BusRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>[]
          }
          create: {
            args: Prisma.BusRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          createMany: {
            args: Prisma.BusRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>[]
          }
          delete: {
            args: Prisma.BusRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          update: {
            args: Prisma.BusRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          deleteMany: {
            args: Prisma.BusRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRoutePayload>
          }
          aggregate: {
            args: Prisma.BusRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusRoute>
          }
          groupBy: {
            args: Prisma.BusRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusRouteCountArgs<ExtArgs>
            result: $Utils.Optional<BusRouteCountAggregateOutputType> | number
          }
        }
      }
      BusRoster: {
        payload: Prisma.$BusRosterPayload<ExtArgs>
        fields: Prisma.BusRosterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusRosterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusRosterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          findFirst: {
            args: Prisma.BusRosterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusRosterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          findMany: {
            args: Prisma.BusRosterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>[]
          }
          create: {
            args: Prisma.BusRosterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          createMany: {
            args: Prisma.BusRosterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusRosterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>[]
          }
          delete: {
            args: Prisma.BusRosterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          update: {
            args: Prisma.BusRosterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          deleteMany: {
            args: Prisma.BusRosterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusRosterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusRosterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusRosterPayload>
          }
          aggregate: {
            args: Prisma.BusRosterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusRoster>
          }
          groupBy: {
            args: Prisma.BusRosterGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusRosterGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusRosterCountArgs<ExtArgs>
            result: $Utils.Optional<BusRosterCountAggregateOutputType> | number
          }
        }
      }
      PickupPoint: {
        payload: Prisma.$PickupPointPayload<ExtArgs>
        fields: Prisma.PickupPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PickupPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PickupPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          findFirst: {
            args: Prisma.PickupPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PickupPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          findMany: {
            args: Prisma.PickupPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>[]
          }
          create: {
            args: Prisma.PickupPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          createMany: {
            args: Prisma.PickupPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PickupPointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>[]
          }
          delete: {
            args: Prisma.PickupPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          update: {
            args: Prisma.PickupPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          deleteMany: {
            args: Prisma.PickupPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PickupPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PickupPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PickupPointPayload>
          }
          aggregate: {
            args: Prisma.PickupPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePickupPoint>
          }
          groupBy: {
            args: Prisma.PickupPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<PickupPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.PickupPointCountArgs<ExtArgs>
            result: $Utils.Optional<PickupPointCountAggregateOutputType> | number
          }
        }
      }
      StudentFee: {
        payload: Prisma.$StudentFeePayload<ExtArgs>
        fields: Prisma.StudentFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          findFirst: {
            args: Prisma.StudentFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          findMany: {
            args: Prisma.StudentFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>[]
          }
          create: {
            args: Prisma.StudentFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          createMany: {
            args: Prisma.StudentFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>[]
          }
          delete: {
            args: Prisma.StudentFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          update: {
            args: Prisma.StudentFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          deleteMany: {
            args: Prisma.StudentFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          aggregate: {
            args: Prisma.StudentFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentFee>
          }
          groupBy: {
            args: Prisma.StudentFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentFeeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeCountAggregateOutputType> | number
          }
        }
      }
      FeePayment: {
        payload: Prisma.$FeePaymentPayload<ExtArgs>
        fields: Prisma.FeePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findFirst: {
            args: Prisma.FeePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          findMany: {
            args: Prisma.FeePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          create: {
            args: Prisma.FeePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          createMany: {
            args: Prisma.FeePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>[]
          }
          delete: {
            args: Prisma.FeePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          update: {
            args: Prisma.FeePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          deleteMany: {
            args: Prisma.FeePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeePaymentPayload>
          }
          aggregate: {
            args: Prisma.FeePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeePayment>
          }
          groupBy: {
            args: Prisma.FeePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<FeePaymentCountAggregateOutputType> | number
          }
        }
      }
      StoreProduct: {
        payload: Prisma.$StoreProductPayload<ExtArgs>
        fields: Prisma.StoreProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          findFirst: {
            args: Prisma.StoreProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          findMany: {
            args: Prisma.StoreProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>[]
          }
          create: {
            args: Prisma.StoreProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          createMany: {
            args: Prisma.StoreProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>[]
          }
          delete: {
            args: Prisma.StoreProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          update: {
            args: Prisma.StoreProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          deleteMany: {
            args: Prisma.StoreProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreProductPayload>
          }
          aggregate: {
            args: Prisma.StoreProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreProduct>
          }
          groupBy: {
            args: Prisma.StoreProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreProductCountArgs<ExtArgs>
            result: $Utils.Optional<StoreProductCountAggregateOutputType> | number
          }
        }
      }
      StoreOrder: {
        payload: Prisma.$StoreOrderPayload<ExtArgs>
        fields: Prisma.StoreOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          findFirst: {
            args: Prisma.StoreOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          findMany: {
            args: Prisma.StoreOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>[]
          }
          create: {
            args: Prisma.StoreOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          createMany: {
            args: Prisma.StoreOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>[]
          }
          delete: {
            args: Prisma.StoreOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          update: {
            args: Prisma.StoreOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          deleteMany: {
            args: Prisma.StoreOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreOrderPayload>
          }
          aggregate: {
            args: Prisma.StoreOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreOrder>
          }
          groupBy: {
            args: Prisma.StoreOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreOrderCountArgs<ExtArgs>
            result: $Utils.Optional<StoreOrderCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      HealthLog: {
        payload: Prisma.$HealthLogPayload<ExtArgs>
        fields: Prisma.HealthLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          findFirst: {
            args: Prisma.HealthLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          findMany: {
            args: Prisma.HealthLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>[]
          }
          create: {
            args: Prisma.HealthLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          createMany: {
            args: Prisma.HealthLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>[]
          }
          delete: {
            args: Prisma.HealthLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          update: {
            args: Prisma.HealthLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          deleteMany: {
            args: Prisma.HealthLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthLogPayload>
          }
          aggregate: {
            args: Prisma.HealthLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthLog>
          }
          groupBy: {
            args: Prisma.HealthLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthLogCountArgs<ExtArgs>
            result: $Utils.Optional<HealthLogCountAggregateOutputType> | number
          }
        }
      }
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      DigitalResource: {
        payload: Prisma.$DigitalResourcePayload<ExtArgs>
        fields: Prisma.DigitalResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DigitalResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DigitalResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          findFirst: {
            args: Prisma.DigitalResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DigitalResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          findMany: {
            args: Prisma.DigitalResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>[]
          }
          create: {
            args: Prisma.DigitalResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          createMany: {
            args: Prisma.DigitalResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DigitalResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>[]
          }
          delete: {
            args: Prisma.DigitalResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          update: {
            args: Prisma.DigitalResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          deleteMany: {
            args: Prisma.DigitalResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DigitalResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DigitalResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DigitalResourcePayload>
          }
          aggregate: {
            args: Prisma.DigitalResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDigitalResource>
          }
          groupBy: {
            args: Prisma.DigitalResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DigitalResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DigitalResourceCountArgs<ExtArgs>
            result: $Utils.Optional<DigitalResourceCountAggregateOutputType> | number
          }
        }
      }
      CbtTest: {
        payload: Prisma.$CbtTestPayload<ExtArgs>
        fields: Prisma.CbtTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CbtTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CbtTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          findFirst: {
            args: Prisma.CbtTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CbtTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          findMany: {
            args: Prisma.CbtTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>[]
          }
          create: {
            args: Prisma.CbtTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          createMany: {
            args: Prisma.CbtTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CbtTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>[]
          }
          delete: {
            args: Prisma.CbtTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          update: {
            args: Prisma.CbtTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          deleteMany: {
            args: Prisma.CbtTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CbtTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CbtTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtTestPayload>
          }
          aggregate: {
            args: Prisma.CbtTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCbtTest>
          }
          groupBy: {
            args: Prisma.CbtTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CbtTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CbtTestCountArgs<ExtArgs>
            result: $Utils.Optional<CbtTestCountAggregateOutputType> | number
          }
        }
      }
      CbtQuestion: {
        payload: Prisma.$CbtQuestionPayload<ExtArgs>
        fields: Prisma.CbtQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CbtQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CbtQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          findFirst: {
            args: Prisma.CbtQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CbtQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          findMany: {
            args: Prisma.CbtQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>[]
          }
          create: {
            args: Prisma.CbtQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          createMany: {
            args: Prisma.CbtQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CbtQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>[]
          }
          delete: {
            args: Prisma.CbtQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          update: {
            args: Prisma.CbtQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          deleteMany: {
            args: Prisma.CbtQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CbtQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CbtQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtQuestionPayload>
          }
          aggregate: {
            args: Prisma.CbtQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCbtQuestion>
          }
          groupBy: {
            args: Prisma.CbtQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CbtQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CbtQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<CbtQuestionCountAggregateOutputType> | number
          }
        }
      }
      CbtResult: {
        payload: Prisma.$CbtResultPayload<ExtArgs>
        fields: Prisma.CbtResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CbtResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CbtResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          findFirst: {
            args: Prisma.CbtResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CbtResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          findMany: {
            args: Prisma.CbtResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>[]
          }
          create: {
            args: Prisma.CbtResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          createMany: {
            args: Prisma.CbtResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CbtResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>[]
          }
          delete: {
            args: Prisma.CbtResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          update: {
            args: Prisma.CbtResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          deleteMany: {
            args: Prisma.CbtResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CbtResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CbtResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CbtResultPayload>
          }
          aggregate: {
            args: Prisma.CbtResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCbtResult>
          }
          groupBy: {
            args: Prisma.CbtResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<CbtResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.CbtResultCountArgs<ExtArgs>
            result: $Utils.Optional<CbtResultCountAggregateOutputType> | number
          }
        }
      }
      CalendarEvent: {
        payload: Prisma.$CalendarEventPayload<ExtArgs>
        fields: Prisma.CalendarEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findFirst: {
            args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          findMany: {
            args: Prisma.CalendarEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          create: {
            args: Prisma.CalendarEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          createMany: {
            args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
          }
          delete: {
            args: Prisma.CalendarEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          update: {
            args: Prisma.CalendarEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          deleteMany: {
            args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarEventPayload>
          }
          aggregate: {
            args: Prisma.CalendarEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarEvent>
          }
          groupBy: {
            args: Prisma.CalendarEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarEventCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarEventCountAggregateOutputType> | number
          }
        }
      }
      ExtracurricularActivity: {
        payload: Prisma.$ExtracurricularActivityPayload<ExtArgs>
        fields: Prisma.ExtracurricularActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtracurricularActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtracurricularActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          findFirst: {
            args: Prisma.ExtracurricularActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtracurricularActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          findMany: {
            args: Prisma.ExtracurricularActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>[]
          }
          create: {
            args: Prisma.ExtracurricularActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          createMany: {
            args: Prisma.ExtracurricularActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtracurricularActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>[]
          }
          delete: {
            args: Prisma.ExtracurricularActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          update: {
            args: Prisma.ExtracurricularActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          deleteMany: {
            args: Prisma.ExtracurricularActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtracurricularActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExtracurricularActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtracurricularActivityPayload>
          }
          aggregate: {
            args: Prisma.ExtracurricularActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtracurricularActivity>
          }
          groupBy: {
            args: Prisma.ExtracurricularActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtracurricularActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtracurricularActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ExtracurricularActivityCountAggregateOutputType> | number
          }
        }
      }
      PtaMeeting: {
        payload: Prisma.$PtaMeetingPayload<ExtArgs>
        fields: Prisma.PtaMeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PtaMeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PtaMeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          findFirst: {
            args: Prisma.PtaMeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PtaMeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          findMany: {
            args: Prisma.PtaMeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>[]
          }
          create: {
            args: Prisma.PtaMeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          createMany: {
            args: Prisma.PtaMeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PtaMeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>[]
          }
          delete: {
            args: Prisma.PtaMeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          update: {
            args: Prisma.PtaMeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          deleteMany: {
            args: Prisma.PtaMeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PtaMeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PtaMeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PtaMeetingPayload>
          }
          aggregate: {
            args: Prisma.PtaMeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePtaMeeting>
          }
          groupBy: {
            args: Prisma.PtaMeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PtaMeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PtaMeetingCountArgs<ExtArgs>
            result: $Utils.Optional<PtaMeetingCountAggregateOutputType> | number
          }
        }
      }
      SchoolPolicy: {
        payload: Prisma.$SchoolPolicyPayload<ExtArgs>
        fields: Prisma.SchoolPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          findFirst: {
            args: Prisma.SchoolPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          findMany: {
            args: Prisma.SchoolPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>[]
          }
          create: {
            args: Prisma.SchoolPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          createMany: {
            args: Prisma.SchoolPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>[]
          }
          delete: {
            args: Prisma.SchoolPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          update: {
            args: Prisma.SchoolPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          deleteMany: {
            args: Prisma.SchoolPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPolicyPayload>
          }
          aggregate: {
            args: Prisma.SchoolPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolPolicy>
          }
          groupBy: {
            args: Prisma.SchoolPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolPolicyCountAggregateOutputType> | number
          }
        }
      }
      VolunteeringOpportunity: {
        payload: Prisma.$VolunteeringOpportunityPayload<ExtArgs>
        fields: Prisma.VolunteeringOpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolunteeringOpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolunteeringOpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          findFirst: {
            args: Prisma.VolunteeringOpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolunteeringOpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          findMany: {
            args: Prisma.VolunteeringOpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>[]
          }
          create: {
            args: Prisma.VolunteeringOpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          createMany: {
            args: Prisma.VolunteeringOpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolunteeringOpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>[]
          }
          delete: {
            args: Prisma.VolunteeringOpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          update: {
            args: Prisma.VolunteeringOpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          deleteMany: {
            args: Prisma.VolunteeringOpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolunteeringOpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VolunteeringOpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolunteeringOpportunityPayload>
          }
          aggregate: {
            args: Prisma.VolunteeringOpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolunteeringOpportunity>
          }
          groupBy: {
            args: Prisma.VolunteeringOpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolunteeringOpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolunteeringOpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<VolunteeringOpportunityCountAggregateOutputType> | number
          }
        }
      }
      PermissionSlip: {
        payload: Prisma.$PermissionSlipPayload<ExtArgs>
        fields: Prisma.PermissionSlipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionSlipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionSlipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          findFirst: {
            args: Prisma.PermissionSlipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionSlipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          findMany: {
            args: Prisma.PermissionSlipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>[]
          }
          create: {
            args: Prisma.PermissionSlipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          createMany: {
            args: Prisma.PermissionSlipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionSlipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>[]
          }
          delete: {
            args: Prisma.PermissionSlipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          update: {
            args: Prisma.PermissionSlipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          deleteMany: {
            args: Prisma.PermissionSlipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionSlipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionSlipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionSlipPayload>
          }
          aggregate: {
            args: Prisma.PermissionSlipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissionSlip>
          }
          groupBy: {
            args: Prisma.PermissionSlipGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionSlipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionSlipCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionSlipCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      PdResource: {
        payload: Prisma.$PdResourcePayload<ExtArgs>
        fields: Prisma.PdResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PdResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PdResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          findFirst: {
            args: Prisma.PdResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PdResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          findMany: {
            args: Prisma.PdResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>[]
          }
          create: {
            args: Prisma.PdResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          createMany: {
            args: Prisma.PdResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PdResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>[]
          }
          delete: {
            args: Prisma.PdResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          update: {
            args: Prisma.PdResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          deleteMany: {
            args: Prisma.PdResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PdResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PdResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdResourcePayload>
          }
          aggregate: {
            args: Prisma.PdResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePdResource>
          }
          groupBy: {
            args: Prisma.PdResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PdResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PdResourceCountArgs<ExtArgs>
            result: $Utils.Optional<PdResourceCountAggregateOutputType> | number
          }
        }
      }
      AiGame: {
        payload: Prisma.$AiGamePayload<ExtArgs>
        fields: Prisma.AiGameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiGameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiGameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          findFirst: {
            args: Prisma.AiGameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiGameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          findMany: {
            args: Prisma.AiGameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>[]
          }
          create: {
            args: Prisma.AiGameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          createMany: {
            args: Prisma.AiGameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiGameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>[]
          }
          delete: {
            args: Prisma.AiGameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          update: {
            args: Prisma.AiGameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          deleteMany: {
            args: Prisma.AiGameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiGameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiGameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiGamePayload>
          }
          aggregate: {
            args: Prisma.AiGameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiGame>
          }
          groupBy: {
            args: Prisma.AiGameGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiGameGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiGameCountArgs<ExtArgs>
            result: $Utils.Optional<AiGameCountAggregateOutputType> | number
          }
        }
      }
      LessonPlan: {
        payload: Prisma.$LessonPlanPayload<ExtArgs>
        fields: Prisma.LessonPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          findFirst: {
            args: Prisma.LessonPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          findMany: {
            args: Prisma.LessonPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>[]
          }
          create: {
            args: Prisma.LessonPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          createMany: {
            args: Prisma.LessonPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>[]
          }
          delete: {
            args: Prisma.LessonPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          update: {
            args: Prisma.LessonPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          deleteMany: {
            args: Prisma.LessonPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPlanPayload>
          }
          aggregate: {
            args: Prisma.LessonPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonPlan>
          }
          groupBy: {
            args: Prisma.LessonPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonPlanCountArgs<ExtArgs>
            result: $Utils.Optional<LessonPlanCountAggregateOutputType> | number
          }
        }
      }
      GeneratedResource: {
        payload: Prisma.$GeneratedResourcePayload<ExtArgs>
        fields: Prisma.GeneratedResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          findFirst: {
            args: Prisma.GeneratedResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          findMany: {
            args: Prisma.GeneratedResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>[]
          }
          create: {
            args: Prisma.GeneratedResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          createMany: {
            args: Prisma.GeneratedResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>[]
          }
          delete: {
            args: Prisma.GeneratedResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          update: {
            args: Prisma.GeneratedResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          deleteMany: {
            args: Prisma.GeneratedResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GeneratedResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResourcePayload>
          }
          aggregate: {
            args: Prisma.GeneratedResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedResource>
          }
          groupBy: {
            args: Prisma.GeneratedResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedResourceCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedResourceCountAggregateOutputType> | number
          }
        }
      }
      ReportCard: {
        payload: Prisma.$ReportCardPayload<ExtArgs>
        fields: Prisma.ReportCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findFirst: {
            args: Prisma.ReportCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findMany: {
            args: Prisma.ReportCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          create: {
            args: Prisma.ReportCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          createMany: {
            args: Prisma.ReportCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          delete: {
            args: Prisma.ReportCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          update: {
            args: Prisma.ReportCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          deleteMany: {
            args: Prisma.ReportCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          aggregate: {
            args: Prisma.ReportCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportCard>
          }
          groupBy: {
            args: Prisma.ReportCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCardCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    messagesSent: number
    conversationsParticipated: number
    notifications: number
    complaints: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    conversationsParticipated?: boolean | UserCountOutputTypeCountConversationsParticipatedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    complaints?: boolean | UserCountOutputTypeCountComplaintsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsParticipatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parents: number
    attendanceRecords: number
    academicPerformance: number
    behaviorRecords: number
    badges: number
    certificates: number
    awards: number
    submissions: number
    fees: number
    cbtResults: number
    permissionSlips: number
    reportCards: number
    healthLogs: number
    notifications: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    attendanceRecords?: boolean | StudentCountOutputTypeCountAttendanceRecordsArgs
    academicPerformance?: boolean | StudentCountOutputTypeCountAcademicPerformanceArgs
    behaviorRecords?: boolean | StudentCountOutputTypeCountBehaviorRecordsArgs
    badges?: boolean | StudentCountOutputTypeCountBadgesArgs
    certificates?: boolean | StudentCountOutputTypeCountCertificatesArgs
    awards?: boolean | StudentCountOutputTypeCountAwardsArgs
    submissions?: boolean | StudentCountOutputTypeCountSubmissionsArgs
    fees?: boolean | StudentCountOutputTypeCountFeesArgs
    cbtResults?: boolean | StudentCountOutputTypeCountCbtResultsArgs
    permissionSlips?: boolean | StudentCountOutputTypeCountPermissionSlipsArgs
    reportCards?: boolean | StudentCountOutputTypeCountReportCardsArgs
    healthLogs?: boolean | StudentCountOutputTypeCountHealthLogsArgs
    notifications?: boolean | StudentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentChildWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAcademicPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPerformanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountBehaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCbtResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtResultWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountPermissionSlipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionSlipWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountReportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountHealthLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthLogWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    subjects: number
    classes: number
    timetableEntries: number
    exams: number
    createdAiGames: number
    lessonPlans: number
    generatedResources: number
    appointments: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | TeacherCountOutputTypeCountSubjectsArgs
    classes?: boolean | TeacherCountOutputTypeCountClassesArgs
    timetableEntries?: boolean | TeacherCountOutputTypeCountTimetableEntriesArgs
    exams?: boolean | TeacherCountOutputTypeCountExamsArgs
    createdAiGames?: boolean | TeacherCountOutputTypeCountCreatedAiGamesArgs
    lessonPlans?: boolean | TeacherCountOutputTypeCountLessonPlansArgs
    generatedResources?: boolean | TeacherCountOutputTypeCountGeneratedResourcesArgs
    appointments?: boolean | TeacherCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTimetableEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountCreatedAiGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGameWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountLessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonPlanWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountGeneratedResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResourceWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    children: number
    appointments: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ParentCountOutputTypeCountChildrenArgs
    appointments?: boolean | ParentCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentChildWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    submissions: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | AssignmentCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    participants: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }


  /**
   * Count Type ForumTopicCountOutputType
   */

  export type ForumTopicCountOutputType = {
    posts: number
  }

  export type ForumTopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumTopicCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopicCountOutputType
     */
    select?: ForumTopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumTopicCountOutputType without action
   */
  export type ForumTopicCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    roster: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | DriverCountOutputTypeCountRosterArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountRosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusRosterWhereInput
  }


  /**
   * Count Type BusRouteCountOutputType
   */

  export type BusRouteCountOutputType = {
    roster: number
    pickupPoints: number
  }

  export type BusRouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | BusRouteCountOutputTypeCountRosterArgs
    pickupPoints?: boolean | BusRouteCountOutputTypeCountPickupPointsArgs
  }

  // Custom InputTypes
  /**
   * BusRouteCountOutputType without action
   */
  export type BusRouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRouteCountOutputType
     */
    select?: BusRouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusRouteCountOutputType without action
   */
  export type BusRouteCountOutputTypeCountRosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusRosterWhereInput
  }

  /**
   * BusRouteCountOutputType without action
   */
  export type BusRouteCountOutputTypeCountPickupPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickupPointWhereInput
  }


  /**
   * Count Type StudentFeeCountOutputType
   */

  export type StudentFeeCountOutputType = {
    payments: number
  }

  export type StudentFeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | StudentFeeCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * StudentFeeCountOutputType without action
   */
  export type StudentFeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeCountOutputType
     */
    select?: StudentFeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentFeeCountOutputType without action
   */
  export type StudentFeeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
  }


  /**
   * Count Type CbtTestCountOutputType
   */

  export type CbtTestCountOutputType = {
    questions: number
    results: number
  }

  export type CbtTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CbtTestCountOutputTypeCountQuestionsArgs
    results?: boolean | CbtTestCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * CbtTestCountOutputType without action
   */
  export type CbtTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTestCountOutputType
     */
    select?: CbtTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CbtTestCountOutputType without action
   */
  export type CbtTestCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtQuestionWhereInput
  }

  /**
   * CbtTestCountOutputType without action
   */
  export type CbtTestCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtResultWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    supabaseUid: string | null
    email: string | null
    name: string | null
    role: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    supabaseUid: string | null
    email: string | null
    name: string | null
    role: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    supabaseUid: number
    email: number
    name: number
    role: number
    avatarUrl: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    supabaseUid?: true
    email?: true
    name?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    supabaseUid?: true
    email?: true
    name?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    supabaseUid?: true
    email?: true
    name?: true
    role?: true
    avatarUrl?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    supabaseUid: string | null
    email: string
    name: string
    role: string
    avatarUrl: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseUid?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    parentProfile?: boolean | User$parentProfileArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    conversationsParticipated?: boolean | User$conversationsParticipatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supabaseUid?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    supabaseUid?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    parentProfile?: boolean | User$parentProfileArgs<ExtArgs>
    messagesSent?: boolean | User$messagesSentArgs<ExtArgs>
    conversationsParticipated?: boolean | User$conversationsParticipatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    complaints?: boolean | User$complaintsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      studentProfile: Prisma.$StudentPayload<ExtArgs> | null
      teacherProfile: Prisma.$TeacherPayload<ExtArgs> | null
      parentProfile: Prisma.$ParentPayload<ExtArgs> | null
      messagesSent: Prisma.$MessagePayload<ExtArgs>[]
      conversationsParticipated: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supabaseUid: string | null
      email: string
      name: string
      role: string
      avatarUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends User$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$studentProfileArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teacherProfile<T extends User$teacherProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherProfileArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parentProfile<T extends User$parentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$parentProfileArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    messagesSent<T extends User$messagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    conversationsParticipated<T extends User$conversationsParticipatedArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsParticipatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    complaints<T extends User$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, User$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly supabaseUid: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.studentProfile
   */
  export type User$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.teacherProfile
   */
  export type User$teacherProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.parentProfile
   */
  export type User$parentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.messagesSent
   */
  export type User$messagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.conversationsParticipated
   */
  export type User$conversationsParticipatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.complaints
   */
  export type User$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    grade: number | null
  }

  export type StudentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    grade: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    avatarUrl: string | null
    grade: number | null
    section: string | null
    department: string | null
    attendanceStatus: string | null
    birthday: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    avatarUrl: string | null
    grade: number | null
    section: string | null
    department: string | null
    attendanceStatus: string | null
    birthday: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    avatarUrl: number
    grade: number
    section: number
    department: number
    attendanceStatus: number
    birthday: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    id?: true
    userId?: true
    grade?: true
  }

  export type StudentSumAggregateInputType = {
    id?: true
    userId?: true
    grade?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    grade?: true
    section?: true
    department?: true
    attendanceStatus?: true
    birthday?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    grade?: true
    section?: true
    department?: true
    attendanceStatus?: true
    birthday?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    grade?: true
    section?: true
    department?: true
    attendanceStatus?: true
    birthday?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: number
    userId: number | null
    name: string
    avatarUrl: string | null
    grade: number
    section: string
    department: string | null
    attendanceStatus: string | null
    birthday: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    attendanceStatus?: boolean
    birthday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Student$userArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    academicPerformance?: boolean | Student$academicPerformanceArgs<ExtArgs>
    behaviorRecords?: boolean | Student$behaviorRecordsArgs<ExtArgs>
    badges?: boolean | Student$badgesArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    awards?: boolean | Student$awardsArgs<ExtArgs>
    submissions?: boolean | Student$submissionsArgs<ExtArgs>
    fees?: boolean | Student$feesArgs<ExtArgs>
    cbtResults?: boolean | Student$cbtResultsArgs<ExtArgs>
    permissionSlips?: boolean | Student$permissionSlipsArgs<ExtArgs>
    reportCards?: boolean | Student$reportCardsArgs<ExtArgs>
    healthLogs?: boolean | Student$healthLogsArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    attendanceStatus?: boolean
    birthday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Student$userArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    attendanceStatus?: boolean
    birthday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Student$userArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    academicPerformance?: boolean | Student$academicPerformanceArgs<ExtArgs>
    behaviorRecords?: boolean | Student$behaviorRecordsArgs<ExtArgs>
    badges?: boolean | Student$badgesArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    awards?: boolean | Student$awardsArgs<ExtArgs>
    submissions?: boolean | Student$submissionsArgs<ExtArgs>
    fees?: boolean | Student$feesArgs<ExtArgs>
    cbtResults?: boolean | Student$cbtResultsArgs<ExtArgs>
    permissionSlips?: boolean | Student$permissionSlipsArgs<ExtArgs>
    reportCards?: boolean | Student$reportCardsArgs<ExtArgs>
    healthLogs?: boolean | Student$healthLogsArgs<ExtArgs>
    notifications?: boolean | Student$notificationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Student$userArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      parents: Prisma.$ParentChildPayload<ExtArgs>[]
      attendanceRecords: Prisma.$StudentAttendancePayload<ExtArgs>[]
      academicPerformance: Prisma.$AcademicPerformancePayload<ExtArgs>[]
      behaviorRecords: Prisma.$BehaviorRecordPayload<ExtArgs>[]
      badges: Prisma.$BadgePayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      awards: Prisma.$AwardPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
      fees: Prisma.$StudentFeePayload<ExtArgs>[]
      cbtResults: Prisma.$CbtResultPayload<ExtArgs>[]
      permissionSlips: Prisma.$PermissionSlipPayload<ExtArgs>[]
      reportCards: Prisma.$ReportCardPayload<ExtArgs>[]
      healthLogs: Prisma.$HealthLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      name: string
      avatarUrl: string | null
      grade: number
      section: string
      department: string | null
      attendanceStatus: string | null
      birthday: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Student$userArgs<ExtArgs> = {}>(args?: Subset<T, Student$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findMany"> | Null>
    attendanceRecords<T extends Student$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany"> | Null>
    academicPerformance<T extends Student$academicPerformanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$academicPerformanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findMany"> | Null>
    behaviorRecords<T extends Student$behaviorRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$behaviorRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends Student$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Student$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Student$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Student$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    awards<T extends Student$awardsArgs<ExtArgs> = {}>(args?: Subset<T, Student$awardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Student$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    fees<T extends Student$feesArgs<ExtArgs> = {}>(args?: Subset<T, Student$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany"> | Null>
    cbtResults<T extends Student$cbtResultsArgs<ExtArgs> = {}>(args?: Subset<T, Student$cbtResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findMany"> | Null>
    permissionSlips<T extends Student$permissionSlipsArgs<ExtArgs> = {}>(args?: Subset<T, Student$permissionSlipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findMany"> | Null>
    reportCards<T extends Student$reportCardsArgs<ExtArgs> = {}>(args?: Subset<T, Student$reportCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany"> | Null>
    healthLogs<T extends Student$healthLogsArgs<ExtArgs> = {}>(args?: Subset<T, Student$healthLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Student$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'Int'>
    readonly userId: FieldRef<"Student", 'Int'>
    readonly name: FieldRef<"Student", 'String'>
    readonly avatarUrl: FieldRef<"Student", 'String'>
    readonly grade: FieldRef<"Student", 'Int'>
    readonly section: FieldRef<"Student", 'String'>
    readonly department: FieldRef<"Student", 'String'>
    readonly attendanceStatus: FieldRef<"Student", 'String'>
    readonly birthday: FieldRef<"Student", 'DateTime'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.user
   */
  export type Student$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    where?: ParentChildWhereInput
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    cursor?: ParentChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentChildScalarFieldEnum | ParentChildScalarFieldEnum[]
  }

  /**
   * Student.attendanceRecords
   */
  export type Student$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    cursor?: StudentAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * Student.academicPerformance
   */
  export type Student$academicPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    where?: AcademicPerformanceWhereInput
    orderBy?: AcademicPerformanceOrderByWithRelationInput | AcademicPerformanceOrderByWithRelationInput[]
    cursor?: AcademicPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicPerformanceScalarFieldEnum | AcademicPerformanceScalarFieldEnum[]
  }

  /**
   * Student.behaviorRecords
   */
  export type Student$behaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    where?: BehaviorRecordWhereInput
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    cursor?: BehaviorRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * Student.badges
   */
  export type Student$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Student.certificates
   */
  export type Student$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Student.awards
   */
  export type Student$awardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    where?: AwardWhereInput
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    cursor?: AwardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Student.submissions
   */
  export type Student$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Student.fees
   */
  export type Student$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    cursor?: StudentFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * Student.cbtResults
   */
  export type Student$cbtResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    where?: CbtResultWhereInput
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    cursor?: CbtResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CbtResultScalarFieldEnum | CbtResultScalarFieldEnum[]
  }

  /**
   * Student.permissionSlips
   */
  export type Student$permissionSlipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    where?: PermissionSlipWhereInput
    orderBy?: PermissionSlipOrderByWithRelationInput | PermissionSlipOrderByWithRelationInput[]
    cursor?: PermissionSlipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionSlipScalarFieldEnum | PermissionSlipScalarFieldEnum[]
  }

  /**
   * Student.reportCards
   */
  export type Student$reportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    cursor?: ReportCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * Student.healthLogs
   */
  export type Student$healthLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    where?: HealthLogWhereInput
    orderBy?: HealthLogOrderByWithRelationInput | HealthLogOrderByWithRelationInput[]
    cursor?: HealthLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthLogScalarFieldEnum | HealthLogScalarFieldEnum[]
  }

  /**
   * Student.notifications
   */
  export type Student$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TeacherSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TeacherMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    phone: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    phone: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    avatarUrl: number
    email: number
    phone: number
    status: number
    createdAt: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TeacherSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    email?: true
    phone?: true
    status?: true
    createdAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    email?: true
    phone?: true
    status?: true
    createdAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    avatarUrl?: true
    email?: true
    phone?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: number
    userId: number | null
    name: string
    avatarUrl: string | null
    email: string
    phone: string | null
    status: string | null
    createdAt: Date
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | Teacher$userArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    timetableEntries?: boolean | Teacher$timetableEntriesArgs<ExtArgs>
    exams?: boolean | Teacher$examsArgs<ExtArgs>
    createdAiGames?: boolean | Teacher$createdAiGamesArgs<ExtArgs>
    lessonPlans?: boolean | Teacher$lessonPlansArgs<ExtArgs>
    generatedResources?: boolean | Teacher$generatedResourcesArgs<ExtArgs>
    appointments?: boolean | Teacher$appointmentsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | Teacher$userArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Teacher$userArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    timetableEntries?: boolean | Teacher$timetableEntriesArgs<ExtArgs>
    exams?: boolean | Teacher$examsArgs<ExtArgs>
    createdAiGames?: boolean | Teacher$createdAiGamesArgs<ExtArgs>
    lessonPlans?: boolean | Teacher$lessonPlansArgs<ExtArgs>
    generatedResources?: boolean | Teacher$generatedResourcesArgs<ExtArgs>
    appointments?: boolean | Teacher$appointmentsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Teacher$userArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      subjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      classes: Prisma.$TeacherClassPayload<ExtArgs>[]
      timetableEntries: Prisma.$TimetablePayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      createdAiGames: Prisma.$AiGamePayload<ExtArgs>[]
      lessonPlans: Prisma.$LessonPlanPayload<ExtArgs>[]
      generatedResources: Prisma.$GeneratedResourcePayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      name: string
      avatarUrl: string | null
      email: string
      phone: string | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Teacher$userArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subjects<T extends Teacher$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends Teacher$classesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findMany"> | Null>
    timetableEntries<T extends Teacher$timetableEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$timetableEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Teacher$examsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    createdAiGames<T extends Teacher$createdAiGamesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$createdAiGamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findMany"> | Null>
    lessonPlans<T extends Teacher$lessonPlansArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$lessonPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findMany"> | Null>
    generatedResources<T extends Teacher$generatedResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$generatedResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Teacher$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'Int'>
    readonly userId: FieldRef<"Teacher", 'Int'>
    readonly name: FieldRef<"Teacher", 'String'>
    readonly avatarUrl: FieldRef<"Teacher", 'String'>
    readonly email: FieldRef<"Teacher", 'String'>
    readonly phone: FieldRef<"Teacher", 'String'>
    readonly status: FieldRef<"Teacher", 'String'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher.user
   */
  export type Teacher$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Teacher.subjects
   */
  export type Teacher$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Teacher.classes
   */
  export type Teacher$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    where?: TeacherClassWhereInput
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    cursor?: TeacherClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * Teacher.timetableEntries
   */
  export type Teacher$timetableEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Teacher.exams
   */
  export type Teacher$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Teacher.createdAiGames
   */
  export type Teacher$createdAiGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    where?: AiGameWhereInput
    orderBy?: AiGameOrderByWithRelationInput | AiGameOrderByWithRelationInput[]
    cursor?: AiGameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiGameScalarFieldEnum | AiGameScalarFieldEnum[]
  }

  /**
   * Teacher.lessonPlans
   */
  export type Teacher$lessonPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    where?: LessonPlanWhereInput
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    cursor?: LessonPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * Teacher.generatedResources
   */
  export type Teacher$generatedResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    where?: GeneratedResourceWhereInput
    orderBy?: GeneratedResourceOrderByWithRelationInput | GeneratedResourceOrderByWithRelationInput[]
    cursor?: GeneratedResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedResourceScalarFieldEnum | GeneratedResourceScalarFieldEnum[]
  }

  /**
   * Teacher.appointments
   */
  export type Teacher$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ParentSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ParentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    email: string | null
    phone: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    email: string | null
    phone: string | null
    avatarUrl: string | null
    createdAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    email: number
    phone: number
    avatarUrl: number
    createdAt: number
    _all: number
  }


  export type ParentAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ParentSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    phone?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    phone?: true
    avatarUrl?: true
    createdAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    phone?: true
    avatarUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _avg?: ParentAvgAggregateInputType
    _sum?: ParentSumAggregateInputType
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: number
    userId: number | null
    name: string
    email: string
    phone: string | null
    avatarUrl: string | null
    createdAt: Date
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    user?: boolean | Parent$userArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    appointments?: boolean | Parent$appointmentsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    user?: boolean | Parent$userArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
  }

  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parent$userArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    appointments?: boolean | Parent$appointmentsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Parent$userArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      children: Prisma.$ParentChildPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      name: string
      email: string
      phone: string | null
      avatarUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Parent$userArgs<ExtArgs> = {}>(args?: Subset<T, Parent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Parent$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Parent$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Parent$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */ 
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'Int'>
    readonly userId: FieldRef<"Parent", 'Int'>
    readonly name: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly phone: FieldRef<"Parent", 'String'>
    readonly avatarUrl: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
  }

  /**
   * Parent.user
   */
  export type Parent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Parent.children
   */
  export type Parent$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    where?: ParentChildWhereInput
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    cursor?: ParentChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentChildScalarFieldEnum | ParentChildScalarFieldEnum[]
  }

  /**
   * Parent.appointments
   */
  export type Parent$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model ParentChild
   */

  export type AggregateParentChild = {
    _count: ParentChildCountAggregateOutputType | null
    _avg: ParentChildAvgAggregateOutputType | null
    _sum: ParentChildSumAggregateOutputType | null
    _min: ParentChildMinAggregateOutputType | null
    _max: ParentChildMaxAggregateOutputType | null
  }

  export type ParentChildAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    studentId: number | null
  }

  export type ParentChildSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    studentId: number | null
  }

  export type ParentChildMinAggregateOutputType = {
    id: number | null
    parentId: number | null
    studentId: number | null
  }

  export type ParentChildMaxAggregateOutputType = {
    id: number | null
    parentId: number | null
    studentId: number | null
  }

  export type ParentChildCountAggregateOutputType = {
    id: number
    parentId: number
    studentId: number
    _all: number
  }


  export type ParentChildAvgAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
  }

  export type ParentChildSumAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
  }

  export type ParentChildMinAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
  }

  export type ParentChildMaxAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
  }

  export type ParentChildCountAggregateInputType = {
    id?: true
    parentId?: true
    studentId?: true
    _all?: true
  }

  export type ParentChildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentChild to aggregate.
     */
    where?: ParentChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentChildren to fetch.
     */
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentChildren
    **/
    _count?: true | ParentChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentChildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentChildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentChildMaxAggregateInputType
  }

  export type GetParentChildAggregateType<T extends ParentChildAggregateArgs> = {
        [P in keyof T & keyof AggregateParentChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentChild[P]>
      : GetScalarType<T[P], AggregateParentChild[P]>
  }




  export type ParentChildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentChildWhereInput
    orderBy?: ParentChildOrderByWithAggregationInput | ParentChildOrderByWithAggregationInput[]
    by: ParentChildScalarFieldEnum[] | ParentChildScalarFieldEnum
    having?: ParentChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentChildCountAggregateInputType | true
    _avg?: ParentChildAvgAggregateInputType
    _sum?: ParentChildSumAggregateInputType
    _min?: ParentChildMinAggregateInputType
    _max?: ParentChildMaxAggregateInputType
  }

  export type ParentChildGroupByOutputType = {
    id: number
    parentId: number
    studentId: number
    _count: ParentChildCountAggregateOutputType | null
    _avg: ParentChildAvgAggregateOutputType | null
    _sum: ParentChildSumAggregateOutputType | null
    _min: ParentChildMinAggregateOutputType | null
    _max: ParentChildMaxAggregateOutputType | null
  }

  type GetParentChildGroupByPayload<T extends ParentChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentChildGroupByOutputType[P]>
            : GetScalarType<T[P], ParentChildGroupByOutputType[P]>
        }
      >
    >


  export type ParentChildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    studentId?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentChild"]>

  export type ParentChildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    studentId?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parentChild"]>

  export type ParentChildSelectScalar = {
    id?: boolean
    parentId?: boolean
    studentId?: boolean
  }

  export type ParentChildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ParentChildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ParentChildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParentChild"
    objects: {
      parent: Prisma.$ParentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parentId: number
      studentId: number
    }, ExtArgs["result"]["parentChild"]>
    composites: {}
  }

  type ParentChildGetPayload<S extends boolean | null | undefined | ParentChildDefaultArgs> = $Result.GetResult<Prisma.$ParentChildPayload, S>

  type ParentChildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentChildFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentChildCountAggregateInputType | true
    }

  export interface ParentChildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParentChild'], meta: { name: 'ParentChild' } }
    /**
     * Find zero or one ParentChild that matches the filter.
     * @param {ParentChildFindUniqueArgs} args - Arguments to find a ParentChild
     * @example
     * // Get one ParentChild
     * const parentChild = await prisma.parentChild.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentChildFindUniqueArgs>(args: SelectSubset<T, ParentChildFindUniqueArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParentChild that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentChildFindUniqueOrThrowArgs} args - Arguments to find a ParentChild
     * @example
     * // Get one ParentChild
     * const parentChild = await prisma.parentChild.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentChildFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentChildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParentChild that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildFindFirstArgs} args - Arguments to find a ParentChild
     * @example
     * // Get one ParentChild
     * const parentChild = await prisma.parentChild.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentChildFindFirstArgs>(args?: SelectSubset<T, ParentChildFindFirstArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParentChild that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildFindFirstOrThrowArgs} args - Arguments to find a ParentChild
     * @example
     * // Get one ParentChild
     * const parentChild = await prisma.parentChild.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentChildFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentChildFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParentChildren that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentChildren
     * const parentChildren = await prisma.parentChild.findMany()
     * 
     * // Get first 10 ParentChildren
     * const parentChildren = await prisma.parentChild.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentChildWithIdOnly = await prisma.parentChild.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentChildFindManyArgs>(args?: SelectSubset<T, ParentChildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParentChild.
     * @param {ParentChildCreateArgs} args - Arguments to create a ParentChild.
     * @example
     * // Create one ParentChild
     * const ParentChild = await prisma.parentChild.create({
     *   data: {
     *     // ... data to create a ParentChild
     *   }
     * })
     * 
     */
    create<T extends ParentChildCreateArgs>(args: SelectSubset<T, ParentChildCreateArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParentChildren.
     * @param {ParentChildCreateManyArgs} args - Arguments to create many ParentChildren.
     * @example
     * // Create many ParentChildren
     * const parentChild = await prisma.parentChild.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentChildCreateManyArgs>(args?: SelectSubset<T, ParentChildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParentChildren and returns the data saved in the database.
     * @param {ParentChildCreateManyAndReturnArgs} args - Arguments to create many ParentChildren.
     * @example
     * // Create many ParentChildren
     * const parentChild = await prisma.parentChild.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParentChildren and only return the `id`
     * const parentChildWithIdOnly = await prisma.parentChild.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentChildCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentChildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParentChild.
     * @param {ParentChildDeleteArgs} args - Arguments to delete one ParentChild.
     * @example
     * // Delete one ParentChild
     * const ParentChild = await prisma.parentChild.delete({
     *   where: {
     *     // ... filter to delete one ParentChild
     *   }
     * })
     * 
     */
    delete<T extends ParentChildDeleteArgs>(args: SelectSubset<T, ParentChildDeleteArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParentChild.
     * @param {ParentChildUpdateArgs} args - Arguments to update one ParentChild.
     * @example
     * // Update one ParentChild
     * const parentChild = await prisma.parentChild.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentChildUpdateArgs>(args: SelectSubset<T, ParentChildUpdateArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParentChildren.
     * @param {ParentChildDeleteManyArgs} args - Arguments to filter ParentChildren to delete.
     * @example
     * // Delete a few ParentChildren
     * const { count } = await prisma.parentChild.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentChildDeleteManyArgs>(args?: SelectSubset<T, ParentChildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentChildren
     * const parentChild = await prisma.parentChild.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentChildUpdateManyArgs>(args: SelectSubset<T, ParentChildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentChild.
     * @param {ParentChildUpsertArgs} args - Arguments to update or create a ParentChild.
     * @example
     * // Update or create a ParentChild
     * const parentChild = await prisma.parentChild.upsert({
     *   create: {
     *     // ... data to create a ParentChild
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentChild we want to update
     *   }
     * })
     */
    upsert<T extends ParentChildUpsertArgs>(args: SelectSubset<T, ParentChildUpsertArgs<ExtArgs>>): Prisma__ParentChildClient<$Result.GetResult<Prisma.$ParentChildPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParentChildren.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildCountArgs} args - Arguments to filter ParentChildren to count.
     * @example
     * // Count the number of ParentChildren
     * const count = await prisma.parentChild.count({
     *   where: {
     *     // ... the filter for the ParentChildren we want to count
     *   }
     * })
    **/
    count<T extends ParentChildCountArgs>(
      args?: Subset<T, ParentChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentChildAggregateArgs>(args: Subset<T, ParentChildAggregateArgs>): Prisma.PrismaPromise<GetParentChildAggregateType<T>>

    /**
     * Group by ParentChild.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentChildGroupByArgs['orderBy'] }
        : { orderBy?: ParentChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParentChild model
   */
  readonly fields: ParentChildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentChild.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentChildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParentChild model
   */ 
  interface ParentChildFieldRefs {
    readonly id: FieldRef<"ParentChild", 'Int'>
    readonly parentId: FieldRef<"ParentChild", 'Int'>
    readonly studentId: FieldRef<"ParentChild", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ParentChild findUnique
   */
  export type ParentChildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter, which ParentChild to fetch.
     */
    where: ParentChildWhereUniqueInput
  }

  /**
   * ParentChild findUniqueOrThrow
   */
  export type ParentChildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter, which ParentChild to fetch.
     */
    where: ParentChildWhereUniqueInput
  }

  /**
   * ParentChild findFirst
   */
  export type ParentChildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter, which ParentChild to fetch.
     */
    where?: ParentChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentChildren to fetch.
     */
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentChildren.
     */
    cursor?: ParentChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentChildren.
     */
    distinct?: ParentChildScalarFieldEnum | ParentChildScalarFieldEnum[]
  }

  /**
   * ParentChild findFirstOrThrow
   */
  export type ParentChildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter, which ParentChild to fetch.
     */
    where?: ParentChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentChildren to fetch.
     */
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentChildren.
     */
    cursor?: ParentChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentChildren.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentChildren.
     */
    distinct?: ParentChildScalarFieldEnum | ParentChildScalarFieldEnum[]
  }

  /**
   * ParentChild findMany
   */
  export type ParentChildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter, which ParentChildren to fetch.
     */
    where?: ParentChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentChildren to fetch.
     */
    orderBy?: ParentChildOrderByWithRelationInput | ParentChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentChildren.
     */
    cursor?: ParentChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentChildren from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentChildren.
     */
    skip?: number
    distinct?: ParentChildScalarFieldEnum | ParentChildScalarFieldEnum[]
  }

  /**
   * ParentChild create
   */
  export type ParentChildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * The data needed to create a ParentChild.
     */
    data: XOR<ParentChildCreateInput, ParentChildUncheckedCreateInput>
  }

  /**
   * ParentChild createMany
   */
  export type ParentChildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParentChildren.
     */
    data: ParentChildCreateManyInput | ParentChildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParentChild createManyAndReturn
   */
  export type ParentChildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParentChildren.
     */
    data: ParentChildCreateManyInput | ParentChildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParentChild update
   */
  export type ParentChildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * The data needed to update a ParentChild.
     */
    data: XOR<ParentChildUpdateInput, ParentChildUncheckedUpdateInput>
    /**
     * Choose, which ParentChild to update.
     */
    where: ParentChildWhereUniqueInput
  }

  /**
   * ParentChild updateMany
   */
  export type ParentChildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParentChildren.
     */
    data: XOR<ParentChildUpdateManyMutationInput, ParentChildUncheckedUpdateManyInput>
    /**
     * Filter which ParentChildren to update
     */
    where?: ParentChildWhereInput
  }

  /**
   * ParentChild upsert
   */
  export type ParentChildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * The filter to search for the ParentChild to update in case it exists.
     */
    where: ParentChildWhereUniqueInput
    /**
     * In case the ParentChild found by the `where` argument doesn't exist, create a new ParentChild with this data.
     */
    create: XOR<ParentChildCreateInput, ParentChildUncheckedCreateInput>
    /**
     * In case the ParentChild was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentChildUpdateInput, ParentChildUncheckedUpdateInput>
  }

  /**
   * ParentChild delete
   */
  export type ParentChildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
    /**
     * Filter which ParentChild to delete.
     */
    where: ParentChildWhereUniqueInput
  }

  /**
   * ParentChild deleteMany
   */
  export type ParentChildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParentChildren to delete
     */
    where?: ParentChildWhereInput
  }

  /**
   * ParentChild without action
   */
  export type ParentChildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentChild
     */
    select?: ParentChildSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentChildInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    grade: number | null
    studentCount: number | null
  }

  export type ClassSumAggregateOutputType = {
    grade: number | null
    studentCount: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    subject: string | null
    grade: number | null
    section: string | null
    department: string | null
    studentCount: number | null
    createdAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    grade: number | null
    section: string | null
    department: string | null
    studentCount: number | null
    createdAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    subject: number
    grade: number
    section: number
    department: number
    studentCount: number
    createdAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    grade?: true
    studentCount?: true
  }

  export type ClassSumAggregateInputType = {
    grade?: true
    studentCount?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    subject?: true
    grade?: true
    section?: true
    department?: true
    studentCount?: true
    createdAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    subject?: true
    grade?: true
    section?: true
    department?: true
    studentCount?: true
    createdAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    subject?: true
    grade?: true
    section?: true
    department?: true
    studentCount?: true
    createdAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    subject: string
    grade: number
    section: string
    department: string | null
    studentCount: number | null
    createdAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    studentCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    studentCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    subject?: boolean
    grade?: boolean
    section?: boolean
    department?: boolean
    studentCount?: boolean
    createdAt?: boolean
  }


  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      grade: number
      section: string
      department: string | null
      studentCount: number | null
      createdAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly subject: FieldRef<"Class", 'String'>
    readonly grade: FieldRef<"Class", 'Int'>
    readonly section: FieldRef<"Class", 'String'>
    readonly department: FieldRef<"Class", 'String'>
    readonly studentCount: FieldRef<"Class", 'Int'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
  }


  /**
   * Model TeacherSubject
   */

  export type AggregateTeacherSubject = {
    _count: TeacherSubjectCountAggregateOutputType | null
    _avg: TeacherSubjectAvgAggregateOutputType | null
    _sum: TeacherSubjectSumAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  export type TeacherSubjectAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TeacherSubjectSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TeacherSubjectMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
  }

  export type TeacherSubjectMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
  }

  export type TeacherSubjectCountAggregateOutputType = {
    id: number
    teacherId: number
    subject: number
    _all: number
  }


  export type TeacherSubjectAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TeacherSubjectSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TeacherSubjectMinAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
  }

  export type TeacherSubjectMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
  }

  export type TeacherSubjectCountAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    _all?: true
  }

  export type TeacherSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubject to aggregate.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherSubjects
    **/
    _count?: true | TeacherSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherSubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type GetTeacherSubjectAggregateType<T extends TeacherSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherSubject[P]>
      : GetScalarType<T[P], AggregateTeacherSubject[P]>
  }




  export type TeacherSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithAggregationInput | TeacherSubjectOrderByWithAggregationInput[]
    by: TeacherSubjectScalarFieldEnum[] | TeacherSubjectScalarFieldEnum
    having?: TeacherSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherSubjectCountAggregateInputType | true
    _avg?: TeacherSubjectAvgAggregateInputType
    _sum?: TeacherSubjectSumAggregateInputType
    _min?: TeacherSubjectMinAggregateInputType
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type TeacherSubjectGroupByOutputType = {
    id: number
    teacherId: number
    subject: string
    _count: TeacherSubjectCountAggregateOutputType | null
    _avg: TeacherSubjectAvgAggregateOutputType | null
    _sum: TeacherSubjectSumAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  type GetTeacherSubjectGroupByPayload<T extends TeacherSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subject?: boolean
  }

  export type TeacherSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type TeacherSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $TeacherSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherSubject"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number
      subject: string
    }, ExtArgs["result"]["teacherSubject"]>
    composites: {}
  }

  type TeacherSubjectGetPayload<S extends boolean | null | undefined | TeacherSubjectDefaultArgs> = $Result.GetResult<Prisma.$TeacherSubjectPayload, S>

  type TeacherSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherSubjectCountAggregateInputType | true
    }

  export interface TeacherSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherSubject'], meta: { name: 'TeacherSubject' } }
    /**
     * Find zero or one TeacherSubject that matches the filter.
     * @param {TeacherSubjectFindUniqueArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherSubjectFindUniqueArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherSubjectFindUniqueOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherSubjectFindFirstArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany()
     * 
     * // Get first 10 TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherSubjectFindManyArgs>(args?: SelectSubset<T, TeacherSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherSubject.
     * @param {TeacherSubjectCreateArgs} args - Arguments to create a TeacherSubject.
     * @example
     * // Create one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.create({
     *   data: {
     *     // ... data to create a TeacherSubject
     *   }
     * })
     * 
     */
    create<T extends TeacherSubjectCreateArgs>(args: SelectSubset<T, TeacherSubjectCreateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherSubjects.
     * @param {TeacherSubjectCreateManyArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherSubjectCreateManyArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherSubjects and returns the data saved in the database.
     * @param {TeacherSubjectCreateManyAndReturnArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherSubjects and only return the `id`
     * const teacherSubjectWithIdOnly = await prisma.teacherSubject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherSubject.
     * @param {TeacherSubjectDeleteArgs} args - Arguments to delete one TeacherSubject.
     * @example
     * // Delete one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.delete({
     *   where: {
     *     // ... filter to delete one TeacherSubject
     *   }
     * })
     * 
     */
    delete<T extends TeacherSubjectDeleteArgs>(args: SelectSubset<T, TeacherSubjectDeleteArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherSubject.
     * @param {TeacherSubjectUpdateArgs} args - Arguments to update one TeacherSubject.
     * @example
     * // Update one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherSubjectUpdateArgs>(args: SelectSubset<T, TeacherSubjectUpdateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherSubjects.
     * @param {TeacherSubjectDeleteManyArgs} args - Arguments to filter TeacherSubjects to delete.
     * @example
     * // Delete a few TeacherSubjects
     * const { count } = await prisma.teacherSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherSubjectDeleteManyArgs>(args?: SelectSubset<T, TeacherSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherSubjectUpdateManyArgs>(args: SelectSubset<T, TeacherSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherSubject.
     * @param {TeacherSubjectUpsertArgs} args - Arguments to update or create a TeacherSubject.
     * @example
     * // Update or create a TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.upsert({
     *   create: {
     *     // ... data to create a TeacherSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherSubject we want to update
     *   }
     * })
     */
    upsert<T extends TeacherSubjectUpsertArgs>(args: SelectSubset<T, TeacherSubjectUpsertArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectCountArgs} args - Arguments to filter TeacherSubjects to count.
     * @example
     * // Count the number of TeacherSubjects
     * const count = await prisma.teacherSubject.count({
     *   where: {
     *     // ... the filter for the TeacherSubjects we want to count
     *   }
     * })
    **/
    count<T extends TeacherSubjectCountArgs>(
      args?: Subset<T, TeacherSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherSubjectAggregateArgs>(args: Subset<T, TeacherSubjectAggregateArgs>): Prisma.PrismaPromise<GetTeacherSubjectAggregateType<T>>

    /**
     * Group by TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherSubjectGroupByArgs['orderBy'] }
        : { orderBy?: TeacherSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherSubject model
   */
  readonly fields: TeacherSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherSubject model
   */ 
  interface TeacherSubjectFieldRefs {
    readonly id: FieldRef<"TeacherSubject", 'Int'>
    readonly teacherId: FieldRef<"TeacherSubject", 'Int'>
    readonly subject: FieldRef<"TeacherSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherSubject findUnique
   */
  export type TeacherSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findUniqueOrThrow
   */
  export type TeacherSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findFirst
   */
  export type TeacherSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findFirstOrThrow
   */
  export type TeacherSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findMany
   */
  export type TeacherSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubjects to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject create
   */
  export type TeacherSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherSubject.
     */
    data: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
  }

  /**
   * TeacherSubject createMany
   */
  export type TeacherSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherSubject createManyAndReturn
   */
  export type TeacherSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherSubject update
   */
  export type TeacherSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherSubject.
     */
    data: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
    /**
     * Choose, which TeacherSubject to update.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject updateMany
   */
  export type TeacherSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherSubjects.
     */
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherSubjects to update
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject upsert
   */
  export type TeacherSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherSubject to update in case it exists.
     */
    where: TeacherSubjectWhereUniqueInput
    /**
     * In case the TeacherSubject found by the `where` argument doesn't exist, create a new TeacherSubject with this data.
     */
    create: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
    /**
     * In case the TeacherSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
  }

  /**
   * TeacherSubject delete
   */
  export type TeacherSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter which TeacherSubject to delete.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject deleteMany
   */
  export type TeacherSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubjects to delete
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject without action
   */
  export type TeacherSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TeacherClass
   */

  export type AggregateTeacherClass = {
    _count: TeacherClassCountAggregateOutputType | null
    _avg: TeacherClassAvgAggregateOutputType | null
    _sum: TeacherClassSumAggregateOutputType | null
    _min: TeacherClassMinAggregateOutputType | null
    _max: TeacherClassMaxAggregateOutputType | null
  }

  export type TeacherClassAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TeacherClassSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TeacherClassMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    className: string | null
  }

  export type TeacherClassMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    className: string | null
  }

  export type TeacherClassCountAggregateOutputType = {
    id: number
    teacherId: number
    className: number
    _all: number
  }


  export type TeacherClassAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TeacherClassSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TeacherClassMinAggregateInputType = {
    id?: true
    teacherId?: true
    className?: true
  }

  export type TeacherClassMaxAggregateInputType = {
    id?: true
    teacherId?: true
    className?: true
  }

  export type TeacherClassCountAggregateInputType = {
    id?: true
    teacherId?: true
    className?: true
    _all?: true
  }

  export type TeacherClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClass to aggregate.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherClasses
    **/
    _count?: true | TeacherClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherClassMaxAggregateInputType
  }

  export type GetTeacherClassAggregateType<T extends TeacherClassAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherClass[P]>
      : GetScalarType<T[P], AggregateTeacherClass[P]>
  }




  export type TeacherClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassWhereInput
    orderBy?: TeacherClassOrderByWithAggregationInput | TeacherClassOrderByWithAggregationInput[]
    by: TeacherClassScalarFieldEnum[] | TeacherClassScalarFieldEnum
    having?: TeacherClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherClassCountAggregateInputType | true
    _avg?: TeacherClassAvgAggregateInputType
    _sum?: TeacherClassSumAggregateInputType
    _min?: TeacherClassMinAggregateInputType
    _max?: TeacherClassMaxAggregateInputType
  }

  export type TeacherClassGroupByOutputType = {
    id: number
    teacherId: number
    className: string
    _count: TeacherClassCountAggregateOutputType | null
    _avg: TeacherClassAvgAggregateOutputType | null
    _sum: TeacherClassSumAggregateOutputType | null
    _min: TeacherClassMinAggregateOutputType | null
    _max: TeacherClassMaxAggregateOutputType | null
  }

  type GetTeacherClassGroupByPayload<T extends TeacherClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherClassGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherClassGroupByOutputType[P]>
        }
      >
    >


  export type TeacherClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    className?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClass"]>

  export type TeacherClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    className?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClass"]>

  export type TeacherClassSelectScalar = {
    id?: boolean
    teacherId?: boolean
    className?: boolean
  }

  export type TeacherClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type TeacherClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $TeacherClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherClass"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number
      className: string
    }, ExtArgs["result"]["teacherClass"]>
    composites: {}
  }

  type TeacherClassGetPayload<S extends boolean | null | undefined | TeacherClassDefaultArgs> = $Result.GetResult<Prisma.$TeacherClassPayload, S>

  type TeacherClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherClassCountAggregateInputType | true
    }

  export interface TeacherClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherClass'], meta: { name: 'TeacherClass' } }
    /**
     * Find zero or one TeacherClass that matches the filter.
     * @param {TeacherClassFindUniqueArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherClassFindUniqueArgs>(args: SelectSubset<T, TeacherClassFindUniqueArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherClassFindUniqueOrThrowArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherClassFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindFirstArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherClassFindFirstArgs>(args?: SelectSubset<T, TeacherClassFindFirstArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindFirstOrThrowArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherClassFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherClasses
     * const teacherClasses = await prisma.teacherClass.findMany()
     * 
     * // Get first 10 TeacherClasses
     * const teacherClasses = await prisma.teacherClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherClassWithIdOnly = await prisma.teacherClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherClassFindManyArgs>(args?: SelectSubset<T, TeacherClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherClass.
     * @param {TeacherClassCreateArgs} args - Arguments to create a TeacherClass.
     * @example
     * // Create one TeacherClass
     * const TeacherClass = await prisma.teacherClass.create({
     *   data: {
     *     // ... data to create a TeacherClass
     *   }
     * })
     * 
     */
    create<T extends TeacherClassCreateArgs>(args: SelectSubset<T, TeacherClassCreateArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherClasses.
     * @param {TeacherClassCreateManyArgs} args - Arguments to create many TeacherClasses.
     * @example
     * // Create many TeacherClasses
     * const teacherClass = await prisma.teacherClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherClassCreateManyArgs>(args?: SelectSubset<T, TeacherClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherClasses and returns the data saved in the database.
     * @param {TeacherClassCreateManyAndReturnArgs} args - Arguments to create many TeacherClasses.
     * @example
     * // Create many TeacherClasses
     * const teacherClass = await prisma.teacherClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherClasses and only return the `id`
     * const teacherClassWithIdOnly = await prisma.teacherClass.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherClassCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherClass.
     * @param {TeacherClassDeleteArgs} args - Arguments to delete one TeacherClass.
     * @example
     * // Delete one TeacherClass
     * const TeacherClass = await prisma.teacherClass.delete({
     *   where: {
     *     // ... filter to delete one TeacherClass
     *   }
     * })
     * 
     */
    delete<T extends TeacherClassDeleteArgs>(args: SelectSubset<T, TeacherClassDeleteArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherClass.
     * @param {TeacherClassUpdateArgs} args - Arguments to update one TeacherClass.
     * @example
     * // Update one TeacherClass
     * const teacherClass = await prisma.teacherClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherClassUpdateArgs>(args: SelectSubset<T, TeacherClassUpdateArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherClasses.
     * @param {TeacherClassDeleteManyArgs} args - Arguments to filter TeacherClasses to delete.
     * @example
     * // Delete a few TeacherClasses
     * const { count } = await prisma.teacherClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherClassDeleteManyArgs>(args?: SelectSubset<T, TeacherClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherClasses
     * const teacherClass = await prisma.teacherClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherClassUpdateManyArgs>(args: SelectSubset<T, TeacherClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherClass.
     * @param {TeacherClassUpsertArgs} args - Arguments to update or create a TeacherClass.
     * @example
     * // Update or create a TeacherClass
     * const teacherClass = await prisma.teacherClass.upsert({
     *   create: {
     *     // ... data to create a TeacherClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherClass we want to update
     *   }
     * })
     */
    upsert<T extends TeacherClassUpsertArgs>(args: SelectSubset<T, TeacherClassUpsertArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassCountArgs} args - Arguments to filter TeacherClasses to count.
     * @example
     * // Count the number of TeacherClasses
     * const count = await prisma.teacherClass.count({
     *   where: {
     *     // ... the filter for the TeacherClasses we want to count
     *   }
     * })
    **/
    count<T extends TeacherClassCountArgs>(
      args?: Subset<T, TeacherClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherClassAggregateArgs>(args: Subset<T, TeacherClassAggregateArgs>): Prisma.PrismaPromise<GetTeacherClassAggregateType<T>>

    /**
     * Group by TeacherClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherClassGroupByArgs['orderBy'] }
        : { orderBy?: TeacherClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherClass model
   */
  readonly fields: TeacherClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherClass model
   */ 
  interface TeacherClassFieldRefs {
    readonly id: FieldRef<"TeacherClass", 'Int'>
    readonly teacherId: FieldRef<"TeacherClass", 'Int'>
    readonly className: FieldRef<"TeacherClass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherClass findUnique
   */
  export type TeacherClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass findUniqueOrThrow
   */
  export type TeacherClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass findFirst
   */
  export type TeacherClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClasses.
     */
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass findFirstOrThrow
   */
  export type TeacherClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClasses.
     */
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass findMany
   */
  export type TeacherClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClasses to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass create
   */
  export type TeacherClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherClass.
     */
    data: XOR<TeacherClassCreateInput, TeacherClassUncheckedCreateInput>
  }

  /**
   * TeacherClass createMany
   */
  export type TeacherClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherClasses.
     */
    data: TeacherClassCreateManyInput | TeacherClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherClass createManyAndReturn
   */
  export type TeacherClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherClasses.
     */
    data: TeacherClassCreateManyInput | TeacherClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherClass update
   */
  export type TeacherClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherClass.
     */
    data: XOR<TeacherClassUpdateInput, TeacherClassUncheckedUpdateInput>
    /**
     * Choose, which TeacherClass to update.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass updateMany
   */
  export type TeacherClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherClasses.
     */
    data: XOR<TeacherClassUpdateManyMutationInput, TeacherClassUncheckedUpdateManyInput>
    /**
     * Filter which TeacherClasses to update
     */
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherClass upsert
   */
  export type TeacherClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherClass to update in case it exists.
     */
    where: TeacherClassWhereUniqueInput
    /**
     * In case the TeacherClass found by the `where` argument doesn't exist, create a new TeacherClass with this data.
     */
    create: XOR<TeacherClassCreateInput, TeacherClassUncheckedCreateInput>
    /**
     * In case the TeacherClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherClassUpdateInput, TeacherClassUncheckedUpdateInput>
  }

  /**
   * TeacherClass delete
   */
  export type TeacherClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter which TeacherClass to delete.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass deleteMany
   */
  export type TeacherClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClasses to delete
     */
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherClass without action
   */
  export type TeacherClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
  }


  /**
   * Model Timetable
   */

  export type AggregateTimetable = {
    _count: TimetableCountAggregateOutputType | null
    _avg: TimetableAvgAggregateOutputType | null
    _sum: TimetableSumAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  export type TimetableAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TimetableSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type TimetableMinAggregateOutputType = {
    id: number | null
    day: string | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    className: string | null
    teacherId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableMaxAggregateOutputType = {
    id: number | null
    day: string | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    className: string | null
    teacherId: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableCountAggregateOutputType = {
    id: number
    day: number
    startTime: number
    endTime: number
    subject: number
    className: number
    teacherId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimetableAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TimetableSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type TimetableMinAggregateInputType = {
    id?: true
    day?: true
    startTime?: true
    endTime?: true
    subject?: true
    className?: true
    teacherId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableMaxAggregateInputType = {
    id?: true
    day?: true
    startTime?: true
    endTime?: true
    subject?: true
    className?: true
    teacherId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableCountAggregateInputType = {
    id?: true
    day?: true
    startTime?: true
    endTime?: true
    subject?: true
    className?: true
    teacherId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimetableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetable to aggregate.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timetables
    **/
    _count?: true | TimetableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimetableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimetableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimetableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimetableMaxAggregateInputType
  }

  export type GetTimetableAggregateType<T extends TimetableAggregateArgs> = {
        [P in keyof T & keyof AggregateTimetable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimetable[P]>
      : GetScalarType<T[P], AggregateTimetable[P]>
  }




  export type TimetableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithAggregationInput | TimetableOrderByWithAggregationInput[]
    by: TimetableScalarFieldEnum[] | TimetableScalarFieldEnum
    having?: TimetableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimetableCountAggregateInputType | true
    _avg?: TimetableAvgAggregateInputType
    _sum?: TimetableSumAggregateInputType
    _min?: TimetableMinAggregateInputType
    _max?: TimetableMaxAggregateInputType
  }

  export type TimetableGroupByOutputType = {
    id: number
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    teacherId: number | null
    status: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimetableCountAggregateOutputType | null
    _avg: TimetableAvgAggregateOutputType | null
    _sum: TimetableSumAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  type GetTimetableGroupByPayload<T extends TimetableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimetableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimetableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimetableGroupByOutputType[P]>
            : GetScalarType<T[P], TimetableGroupByOutputType[P]>
        }
      >
    >


  export type TimetableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    className?: boolean
    teacherId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | Timetable$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["timetable"]>

  export type TimetableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    className?: boolean
    teacherId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | Timetable$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["timetable"]>

  export type TimetableSelectScalar = {
    id?: boolean
    day?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    className?: boolean
    teacherId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimetableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Timetable$teacherArgs<ExtArgs>
  }
  export type TimetableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Timetable$teacherArgs<ExtArgs>
  }

  export type $TimetablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timetable"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      day: string
      startTime: string
      endTime: string
      subject: string
      className: string
      teacherId: number | null
      status: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timetable"]>
    composites: {}
  }

  type TimetableGetPayload<S extends boolean | null | undefined | TimetableDefaultArgs> = $Result.GetResult<Prisma.$TimetablePayload, S>

  type TimetableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimetableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimetableCountAggregateInputType | true
    }

  export interface TimetableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timetable'], meta: { name: 'Timetable' } }
    /**
     * Find zero or one Timetable that matches the filter.
     * @param {TimetableFindUniqueArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimetableFindUniqueArgs>(args: SelectSubset<T, TimetableFindUniqueArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Timetable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimetableFindUniqueOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimetableFindUniqueOrThrowArgs>(args: SelectSubset<T, TimetableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Timetable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimetableFindFirstArgs>(args?: SelectSubset<T, TimetableFindFirstArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Timetable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimetableFindFirstOrThrowArgs>(args?: SelectSubset<T, TimetableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Timetables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timetables
     * const timetables = await prisma.timetable.findMany()
     * 
     * // Get first 10 Timetables
     * const timetables = await prisma.timetable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timetableWithIdOnly = await prisma.timetable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimetableFindManyArgs>(args?: SelectSubset<T, TimetableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Timetable.
     * @param {TimetableCreateArgs} args - Arguments to create a Timetable.
     * @example
     * // Create one Timetable
     * const Timetable = await prisma.timetable.create({
     *   data: {
     *     // ... data to create a Timetable
     *   }
     * })
     * 
     */
    create<T extends TimetableCreateArgs>(args: SelectSubset<T, TimetableCreateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Timetables.
     * @param {TimetableCreateManyArgs} args - Arguments to create many Timetables.
     * @example
     * // Create many Timetables
     * const timetable = await prisma.timetable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimetableCreateManyArgs>(args?: SelectSubset<T, TimetableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timetables and returns the data saved in the database.
     * @param {TimetableCreateManyAndReturnArgs} args - Arguments to create many Timetables.
     * @example
     * // Create many Timetables
     * const timetable = await prisma.timetable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timetables and only return the `id`
     * const timetableWithIdOnly = await prisma.timetable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimetableCreateManyAndReturnArgs>(args?: SelectSubset<T, TimetableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Timetable.
     * @param {TimetableDeleteArgs} args - Arguments to delete one Timetable.
     * @example
     * // Delete one Timetable
     * const Timetable = await prisma.timetable.delete({
     *   where: {
     *     // ... filter to delete one Timetable
     *   }
     * })
     * 
     */
    delete<T extends TimetableDeleteArgs>(args: SelectSubset<T, TimetableDeleteArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Timetable.
     * @param {TimetableUpdateArgs} args - Arguments to update one Timetable.
     * @example
     * // Update one Timetable
     * const timetable = await prisma.timetable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimetableUpdateArgs>(args: SelectSubset<T, TimetableUpdateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Timetables.
     * @param {TimetableDeleteManyArgs} args - Arguments to filter Timetables to delete.
     * @example
     * // Delete a few Timetables
     * const { count } = await prisma.timetable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimetableDeleteManyArgs>(args?: SelectSubset<T, TimetableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timetables
     * const timetable = await prisma.timetable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimetableUpdateManyArgs>(args: SelectSubset<T, TimetableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timetable.
     * @param {TimetableUpsertArgs} args - Arguments to update or create a Timetable.
     * @example
     * // Update or create a Timetable
     * const timetable = await prisma.timetable.upsert({
     *   create: {
     *     // ... data to create a Timetable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timetable we want to update
     *   }
     * })
     */
    upsert<T extends TimetableUpsertArgs>(args: SelectSubset<T, TimetableUpsertArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableCountArgs} args - Arguments to filter Timetables to count.
     * @example
     * // Count the number of Timetables
     * const count = await prisma.timetable.count({
     *   where: {
     *     // ... the filter for the Timetables we want to count
     *   }
     * })
    **/
    count<T extends TimetableCountArgs>(
      args?: Subset<T, TimetableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimetableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimetableAggregateArgs>(args: Subset<T, TimetableAggregateArgs>): Prisma.PrismaPromise<GetTimetableAggregateType<T>>

    /**
     * Group by Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimetableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimetableGroupByArgs['orderBy'] }
        : { orderBy?: TimetableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimetableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimetableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timetable model
   */
  readonly fields: TimetableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timetable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimetableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends Timetable$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Timetable$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timetable model
   */ 
  interface TimetableFieldRefs {
    readonly id: FieldRef<"Timetable", 'Int'>
    readonly day: FieldRef<"Timetable", 'String'>
    readonly startTime: FieldRef<"Timetable", 'String'>
    readonly endTime: FieldRef<"Timetable", 'String'>
    readonly subject: FieldRef<"Timetable", 'String'>
    readonly className: FieldRef<"Timetable", 'String'>
    readonly teacherId: FieldRef<"Timetable", 'Int'>
    readonly status: FieldRef<"Timetable", 'String'>
    readonly createdAt: FieldRef<"Timetable", 'DateTime'>
    readonly updatedAt: FieldRef<"Timetable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Timetable findUnique
   */
  export type TimetableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findUniqueOrThrow
   */
  export type TimetableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findFirst
   */
  export type TimetableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findFirstOrThrow
   */
  export type TimetableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findMany
   */
  export type TimetableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetables to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable create
   */
  export type TimetableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to create a Timetable.
     */
    data: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
  }

  /**
   * Timetable createMany
   */
  export type TimetableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timetables.
     */
    data: TimetableCreateManyInput | TimetableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Timetable createManyAndReturn
   */
  export type TimetableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Timetables.
     */
    data: TimetableCreateManyInput | TimetableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Timetable update
   */
  export type TimetableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to update a Timetable.
     */
    data: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
    /**
     * Choose, which Timetable to update.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable updateMany
   */
  export type TimetableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timetables.
     */
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyInput>
    /**
     * Filter which Timetables to update
     */
    where?: TimetableWhereInput
  }

  /**
   * Timetable upsert
   */
  export type TimetableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The filter to search for the Timetable to update in case it exists.
     */
    where: TimetableWhereUniqueInput
    /**
     * In case the Timetable found by the `where` argument doesn't exist, create a new Timetable with this data.
     */
    create: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
    /**
     * In case the Timetable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
  }

  /**
   * Timetable delete
   */
  export type TimetableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter which Timetable to delete.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable deleteMany
   */
  export type TimetableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetables to delete
     */
    where?: TimetableWhereInput
  }

  /**
   * Timetable.teacher
   */
  export type Timetable$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Timetable without action
   */
  export type TimetableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
  }


  /**
   * Model StudentAttendance
   */

  export type AggregateStudentAttendance = {
    _count: StudentAttendanceCountAggregateOutputType | null
    _avg: StudentAttendanceAvgAggregateOutputType | null
    _sum: StudentAttendanceSumAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  export type StudentAttendanceAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type StudentAttendanceSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type StudentAttendanceMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    date: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type StudentAttendanceMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    date: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type StudentAttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    status: number
    createdAt: number
    _all: number
  }


  export type StudentAttendanceAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type StudentAttendanceSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type StudentAttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    createdAt?: true
  }

  export type StudentAttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    createdAt?: true
  }

  export type StudentAttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type StudentAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendance to aggregate.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAttendances
    **/
    _count?: true | StudentAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type GetStudentAttendanceAggregateType<T extends StudentAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAttendance[P]>
      : GetScalarType<T[P], AggregateStudentAttendance[P]>
  }




  export type StudentAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAttendanceWhereInput
    orderBy?: StudentAttendanceOrderByWithAggregationInput | StudentAttendanceOrderByWithAggregationInput[]
    by: StudentAttendanceScalarFieldEnum[] | StudentAttendanceScalarFieldEnum
    having?: StudentAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAttendanceCountAggregateInputType | true
    _avg?: StudentAttendanceAvgAggregateInputType
    _sum?: StudentAttendanceSumAggregateInputType
    _min?: StudentAttendanceMinAggregateInputType
    _max?: StudentAttendanceMaxAggregateInputType
  }

  export type StudentAttendanceGroupByOutputType = {
    id: number
    studentId: number
    date: Date
    status: string
    createdAt: Date
    _count: StudentAttendanceCountAggregateOutputType | null
    _avg: StudentAttendanceAvgAggregateOutputType | null
    _sum: StudentAttendanceSumAggregateOutputType | null
    _min: StudentAttendanceMinAggregateOutputType | null
    _max: StudentAttendanceMaxAggregateOutputType | null
  }

  type GetStudentAttendanceGroupByPayload<T extends StudentAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type StudentAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAttendance"]>

  export type StudentAttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type StudentAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAttendance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      date: Date
      status: string
      createdAt: Date
    }, ExtArgs["result"]["studentAttendance"]>
    composites: {}
  }

  type StudentAttendanceGetPayload<S extends boolean | null | undefined | StudentAttendanceDefaultArgs> = $Result.GetResult<Prisma.$StudentAttendancePayload, S>

  type StudentAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentAttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentAttendanceCountAggregateInputType | true
    }

  export interface StudentAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAttendance'], meta: { name: 'StudentAttendance' } }
    /**
     * Find zero or one StudentAttendance that matches the filter.
     * @param {StudentAttendanceFindUniqueArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAttendanceFindUniqueArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentAttendance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentAttendanceFindUniqueOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAttendanceFindFirstArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindFirstOrThrowArgs} args - Arguments to find a StudentAttendance
     * @example
     * // Get one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany()
     * 
     * // Get first 10 StudentAttendances
     * const studentAttendances = await prisma.studentAttendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAttendanceFindManyArgs>(args?: SelectSubset<T, StudentAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentAttendance.
     * @param {StudentAttendanceCreateArgs} args - Arguments to create a StudentAttendance.
     * @example
     * // Create one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.create({
     *   data: {
     *     // ... data to create a StudentAttendance
     *   }
     * })
     * 
     */
    create<T extends StudentAttendanceCreateArgs>(args: SelectSubset<T, StudentAttendanceCreateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentAttendances.
     * @param {StudentAttendanceCreateManyArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAttendanceCreateManyArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAttendances and returns the data saved in the database.
     * @param {StudentAttendanceCreateManyAndReturnArgs} args - Arguments to create many StudentAttendances.
     * @example
     * // Create many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAttendances and only return the `id`
     * const studentAttendanceWithIdOnly = await prisma.studentAttendance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentAttendance.
     * @param {StudentAttendanceDeleteArgs} args - Arguments to delete one StudentAttendance.
     * @example
     * // Delete one StudentAttendance
     * const StudentAttendance = await prisma.studentAttendance.delete({
     *   where: {
     *     // ... filter to delete one StudentAttendance
     *   }
     * })
     * 
     */
    delete<T extends StudentAttendanceDeleteArgs>(args: SelectSubset<T, StudentAttendanceDeleteArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentAttendance.
     * @param {StudentAttendanceUpdateArgs} args - Arguments to update one StudentAttendance.
     * @example
     * // Update one StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAttendanceUpdateArgs>(args: SelectSubset<T, StudentAttendanceUpdateArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentAttendances.
     * @param {StudentAttendanceDeleteManyArgs} args - Arguments to filter StudentAttendances to delete.
     * @example
     * // Delete a few StudentAttendances
     * const { count } = await prisma.studentAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAttendanceDeleteManyArgs>(args?: SelectSubset<T, StudentAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAttendances
     * const studentAttendance = await prisma.studentAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAttendanceUpdateManyArgs>(args: SelectSubset<T, StudentAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAttendance.
     * @param {StudentAttendanceUpsertArgs} args - Arguments to update or create a StudentAttendance.
     * @example
     * // Update or create a StudentAttendance
     * const studentAttendance = await prisma.studentAttendance.upsert({
     *   create: {
     *     // ... data to create a StudentAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAttendance we want to update
     *   }
     * })
     */
    upsert<T extends StudentAttendanceUpsertArgs>(args: SelectSubset<T, StudentAttendanceUpsertArgs<ExtArgs>>): Prisma__StudentAttendanceClient<$Result.GetResult<Prisma.$StudentAttendancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceCountArgs} args - Arguments to filter StudentAttendances to count.
     * @example
     * // Count the number of StudentAttendances
     * const count = await prisma.studentAttendance.count({
     *   where: {
     *     // ... the filter for the StudentAttendances we want to count
     *   }
     * })
    **/
    count<T extends StudentAttendanceCountArgs>(
      args?: Subset<T, StudentAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAttendanceAggregateArgs>(args: Subset<T, StudentAttendanceAggregateArgs>): Prisma.PrismaPromise<GetStudentAttendanceAggregateType<T>>

    /**
     * Group by StudentAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: StudentAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAttendance model
   */
  readonly fields: StudentAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAttendance model
   */ 
  interface StudentAttendanceFieldRefs {
    readonly id: FieldRef<"StudentAttendance", 'Int'>
    readonly studentId: FieldRef<"StudentAttendance", 'Int'>
    readonly date: FieldRef<"StudentAttendance", 'DateTime'>
    readonly status: FieldRef<"StudentAttendance", 'String'>
    readonly createdAt: FieldRef<"StudentAttendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentAttendance findUnique
   */
  export type StudentAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findUniqueOrThrow
   */
  export type StudentAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance findFirst
   */
  export type StudentAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findFirstOrThrow
   */
  export type StudentAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendance to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAttendances.
     */
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance findMany
   */
  export type StudentAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which StudentAttendances to fetch.
     */
    where?: StudentAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAttendances to fetch.
     */
    orderBy?: StudentAttendanceOrderByWithRelationInput | StudentAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAttendances.
     */
    cursor?: StudentAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAttendances.
     */
    skip?: number
    distinct?: StudentAttendanceScalarFieldEnum | StudentAttendanceScalarFieldEnum[]
  }

  /**
   * StudentAttendance create
   */
  export type StudentAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAttendance.
     */
    data: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
  }

  /**
   * StudentAttendance createMany
   */
  export type StudentAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAttendance createManyAndReturn
   */
  export type StudentAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentAttendances.
     */
    data: StudentAttendanceCreateManyInput | StudentAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAttendance update
   */
  export type StudentAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAttendance.
     */
    data: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
    /**
     * Choose, which StudentAttendance to update.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance updateMany
   */
  export type StudentAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAttendances.
     */
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which StudentAttendances to update
     */
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentAttendance upsert
   */
  export type StudentAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAttendance to update in case it exists.
     */
    where: StudentAttendanceWhereUniqueInput
    /**
     * In case the StudentAttendance found by the `where` argument doesn't exist, create a new StudentAttendance with this data.
     */
    create: XOR<StudentAttendanceCreateInput, StudentAttendanceUncheckedCreateInput>
    /**
     * In case the StudentAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAttendanceUpdateInput, StudentAttendanceUncheckedUpdateInput>
  }

  /**
   * StudentAttendance delete
   */
  export type StudentAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
    /**
     * Filter which StudentAttendance to delete.
     */
    where: StudentAttendanceWhereUniqueInput
  }

  /**
   * StudentAttendance deleteMany
   */
  export type StudentAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAttendances to delete
     */
    where?: StudentAttendanceWhereInput
  }

  /**
   * StudentAttendance without action
   */
  export type StudentAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAttendance
     */
    select?: StudentAttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AcademicPerformance
   */

  export type AggregateAcademicPerformance = {
    _count: AcademicPerformanceCountAggregateOutputType | null
    _avg: AcademicPerformanceAvgAggregateOutputType | null
    _sum: AcademicPerformanceSumAggregateOutputType | null
    _min: AcademicPerformanceMinAggregateOutputType | null
    _max: AcademicPerformanceMaxAggregateOutputType | null
  }

  export type AcademicPerformanceAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    score: number | null
  }

  export type AcademicPerformanceSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    score: number | null
  }

  export type AcademicPerformanceMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    subject: string | null
    score: number | null
    term: string | null
    session: string | null
  }

  export type AcademicPerformanceMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    subject: string | null
    score: number | null
    term: string | null
    session: string | null
  }

  export type AcademicPerformanceCountAggregateOutputType = {
    id: number
    studentId: number
    subject: number
    score: number
    term: number
    session: number
    _all: number
  }


  export type AcademicPerformanceAvgAggregateInputType = {
    id?: true
    studentId?: true
    score?: true
  }

  export type AcademicPerformanceSumAggregateInputType = {
    id?: true
    studentId?: true
    score?: true
  }

  export type AcademicPerformanceMinAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    score?: true
    term?: true
    session?: true
  }

  export type AcademicPerformanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    score?: true
    term?: true
    session?: true
  }

  export type AcademicPerformanceCountAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    score?: true
    term?: true
    session?: true
    _all?: true
  }

  export type AcademicPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPerformance to aggregate.
     */
    where?: AcademicPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPerformances to fetch.
     */
    orderBy?: AcademicPerformanceOrderByWithRelationInput | AcademicPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicPerformances
    **/
    _count?: true | AcademicPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicPerformanceMaxAggregateInputType
  }

  export type GetAcademicPerformanceAggregateType<T extends AcademicPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicPerformance[P]>
      : GetScalarType<T[P], AggregateAcademicPerformance[P]>
  }




  export type AcademicPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicPerformanceWhereInput
    orderBy?: AcademicPerformanceOrderByWithAggregationInput | AcademicPerformanceOrderByWithAggregationInput[]
    by: AcademicPerformanceScalarFieldEnum[] | AcademicPerformanceScalarFieldEnum
    having?: AcademicPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicPerformanceCountAggregateInputType | true
    _avg?: AcademicPerformanceAvgAggregateInputType
    _sum?: AcademicPerformanceSumAggregateInputType
    _min?: AcademicPerformanceMinAggregateInputType
    _max?: AcademicPerformanceMaxAggregateInputType
  }

  export type AcademicPerformanceGroupByOutputType = {
    id: number
    studentId: number
    subject: string
    score: number | null
    term: string
    session: string | null
    _count: AcademicPerformanceCountAggregateOutputType | null
    _avg: AcademicPerformanceAvgAggregateOutputType | null
    _sum: AcademicPerformanceSumAggregateOutputType | null
    _min: AcademicPerformanceMinAggregateOutputType | null
    _max: AcademicPerformanceMaxAggregateOutputType | null
  }

  type GetAcademicPerformanceGroupByPayload<T extends AcademicPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type AcademicPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subject?: boolean
    score?: boolean
    term?: boolean
    session?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPerformance"]>

  export type AcademicPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subject?: boolean
    score?: boolean
    term?: boolean
    session?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicPerformance"]>

  export type AcademicPerformanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    subject?: boolean
    score?: boolean
    term?: boolean
    session?: boolean
  }

  export type AcademicPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AcademicPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AcademicPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicPerformance"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      subject: string
      score: number | null
      term: string
      session: string | null
    }, ExtArgs["result"]["academicPerformance"]>
    composites: {}
  }

  type AcademicPerformanceGetPayload<S extends boolean | null | undefined | AcademicPerformanceDefaultArgs> = $Result.GetResult<Prisma.$AcademicPerformancePayload, S>

  type AcademicPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicPerformanceCountAggregateInputType | true
    }

  export interface AcademicPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicPerformance'], meta: { name: 'AcademicPerformance' } }
    /**
     * Find zero or one AcademicPerformance that matches the filter.
     * @param {AcademicPerformanceFindUniqueArgs} args - Arguments to find a AcademicPerformance
     * @example
     * // Get one AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicPerformanceFindUniqueArgs>(args: SelectSubset<T, AcademicPerformanceFindUniqueArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicPerformanceFindUniqueOrThrowArgs} args - Arguments to find a AcademicPerformance
     * @example
     * // Get one AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceFindFirstArgs} args - Arguments to find a AcademicPerformance
     * @example
     * // Get one AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicPerformanceFindFirstArgs>(args?: SelectSubset<T, AcademicPerformanceFindFirstArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceFindFirstOrThrowArgs} args - Arguments to find a AcademicPerformance
     * @example
     * // Get one AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicPerformances
     * const academicPerformances = await prisma.academicPerformance.findMany()
     * 
     * // Get first 10 AcademicPerformances
     * const academicPerformances = await prisma.academicPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicPerformanceWithIdOnly = await prisma.academicPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicPerformanceFindManyArgs>(args?: SelectSubset<T, AcademicPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicPerformance.
     * @param {AcademicPerformanceCreateArgs} args - Arguments to create a AcademicPerformance.
     * @example
     * // Create one AcademicPerformance
     * const AcademicPerformance = await prisma.academicPerformance.create({
     *   data: {
     *     // ... data to create a AcademicPerformance
     *   }
     * })
     * 
     */
    create<T extends AcademicPerformanceCreateArgs>(args: SelectSubset<T, AcademicPerformanceCreateArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicPerformances.
     * @param {AcademicPerformanceCreateManyArgs} args - Arguments to create many AcademicPerformances.
     * @example
     * // Create many AcademicPerformances
     * const academicPerformance = await prisma.academicPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicPerformanceCreateManyArgs>(args?: SelectSubset<T, AcademicPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicPerformances and returns the data saved in the database.
     * @param {AcademicPerformanceCreateManyAndReturnArgs} args - Arguments to create many AcademicPerformances.
     * @example
     * // Create many AcademicPerformances
     * const academicPerformance = await prisma.academicPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicPerformances and only return the `id`
     * const academicPerformanceWithIdOnly = await prisma.academicPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicPerformance.
     * @param {AcademicPerformanceDeleteArgs} args - Arguments to delete one AcademicPerformance.
     * @example
     * // Delete one AcademicPerformance
     * const AcademicPerformance = await prisma.academicPerformance.delete({
     *   where: {
     *     // ... filter to delete one AcademicPerformance
     *   }
     * })
     * 
     */
    delete<T extends AcademicPerformanceDeleteArgs>(args: SelectSubset<T, AcademicPerformanceDeleteArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicPerformance.
     * @param {AcademicPerformanceUpdateArgs} args - Arguments to update one AcademicPerformance.
     * @example
     * // Update one AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicPerformanceUpdateArgs>(args: SelectSubset<T, AcademicPerformanceUpdateArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicPerformances.
     * @param {AcademicPerformanceDeleteManyArgs} args - Arguments to filter AcademicPerformances to delete.
     * @example
     * // Delete a few AcademicPerformances
     * const { count } = await prisma.academicPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicPerformanceDeleteManyArgs>(args?: SelectSubset<T, AcademicPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicPerformances
     * const academicPerformance = await prisma.academicPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicPerformanceUpdateManyArgs>(args: SelectSubset<T, AcademicPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicPerformance.
     * @param {AcademicPerformanceUpsertArgs} args - Arguments to update or create a AcademicPerformance.
     * @example
     * // Update or create a AcademicPerformance
     * const academicPerformance = await prisma.academicPerformance.upsert({
     *   create: {
     *     // ... data to create a AcademicPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicPerformance we want to update
     *   }
     * })
     */
    upsert<T extends AcademicPerformanceUpsertArgs>(args: SelectSubset<T, AcademicPerformanceUpsertArgs<ExtArgs>>): Prisma__AcademicPerformanceClient<$Result.GetResult<Prisma.$AcademicPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceCountArgs} args - Arguments to filter AcademicPerformances to count.
     * @example
     * // Count the number of AcademicPerformances
     * const count = await prisma.academicPerformance.count({
     *   where: {
     *     // ... the filter for the AcademicPerformances we want to count
     *   }
     * })
    **/
    count<T extends AcademicPerformanceCountArgs>(
      args?: Subset<T, AcademicPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicPerformanceAggregateArgs>(args: Subset<T, AcademicPerformanceAggregateArgs>): Prisma.PrismaPromise<GetAcademicPerformanceAggregateType<T>>

    /**
     * Group by AcademicPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: AcademicPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicPerformance model
   */
  readonly fields: AcademicPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicPerformance model
   */ 
  interface AcademicPerformanceFieldRefs {
    readonly id: FieldRef<"AcademicPerformance", 'Int'>
    readonly studentId: FieldRef<"AcademicPerformance", 'Int'>
    readonly subject: FieldRef<"AcademicPerformance", 'String'>
    readonly score: FieldRef<"AcademicPerformance", 'Int'>
    readonly term: FieldRef<"AcademicPerformance", 'String'>
    readonly session: FieldRef<"AcademicPerformance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicPerformance findUnique
   */
  export type AcademicPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPerformance to fetch.
     */
    where: AcademicPerformanceWhereUniqueInput
  }

  /**
   * AcademicPerformance findUniqueOrThrow
   */
  export type AcademicPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPerformance to fetch.
     */
    where: AcademicPerformanceWhereUniqueInput
  }

  /**
   * AcademicPerformance findFirst
   */
  export type AcademicPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPerformance to fetch.
     */
    where?: AcademicPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPerformances to fetch.
     */
    orderBy?: AcademicPerformanceOrderByWithRelationInput | AcademicPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPerformances.
     */
    cursor?: AcademicPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPerformances.
     */
    distinct?: AcademicPerformanceScalarFieldEnum | AcademicPerformanceScalarFieldEnum[]
  }

  /**
   * AcademicPerformance findFirstOrThrow
   */
  export type AcademicPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPerformance to fetch.
     */
    where?: AcademicPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPerformances to fetch.
     */
    orderBy?: AcademicPerformanceOrderByWithRelationInput | AcademicPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicPerformances.
     */
    cursor?: AcademicPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicPerformances.
     */
    distinct?: AcademicPerformanceScalarFieldEnum | AcademicPerformanceScalarFieldEnum[]
  }

  /**
   * AcademicPerformance findMany
   */
  export type AcademicPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which AcademicPerformances to fetch.
     */
    where?: AcademicPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicPerformances to fetch.
     */
    orderBy?: AcademicPerformanceOrderByWithRelationInput | AcademicPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicPerformances.
     */
    cursor?: AcademicPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicPerformances.
     */
    skip?: number
    distinct?: AcademicPerformanceScalarFieldEnum | AcademicPerformanceScalarFieldEnum[]
  }

  /**
   * AcademicPerformance create
   */
  export type AcademicPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicPerformance.
     */
    data: XOR<AcademicPerformanceCreateInput, AcademicPerformanceUncheckedCreateInput>
  }

  /**
   * AcademicPerformance createMany
   */
  export type AcademicPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicPerformances.
     */
    data: AcademicPerformanceCreateManyInput | AcademicPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicPerformance createManyAndReturn
   */
  export type AcademicPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicPerformances.
     */
    data: AcademicPerformanceCreateManyInput | AcademicPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicPerformance update
   */
  export type AcademicPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicPerformance.
     */
    data: XOR<AcademicPerformanceUpdateInput, AcademicPerformanceUncheckedUpdateInput>
    /**
     * Choose, which AcademicPerformance to update.
     */
    where: AcademicPerformanceWhereUniqueInput
  }

  /**
   * AcademicPerformance updateMany
   */
  export type AcademicPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicPerformances.
     */
    data: XOR<AcademicPerformanceUpdateManyMutationInput, AcademicPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which AcademicPerformances to update
     */
    where?: AcademicPerformanceWhereInput
  }

  /**
   * AcademicPerformance upsert
   */
  export type AcademicPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicPerformance to update in case it exists.
     */
    where: AcademicPerformanceWhereUniqueInput
    /**
     * In case the AcademicPerformance found by the `where` argument doesn't exist, create a new AcademicPerformance with this data.
     */
    create: XOR<AcademicPerformanceCreateInput, AcademicPerformanceUncheckedCreateInput>
    /**
     * In case the AcademicPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicPerformanceUpdateInput, AcademicPerformanceUncheckedUpdateInput>
  }

  /**
   * AcademicPerformance delete
   */
  export type AcademicPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
    /**
     * Filter which AcademicPerformance to delete.
     */
    where: AcademicPerformanceWhereUniqueInput
  }

  /**
   * AcademicPerformance deleteMany
   */
  export type AcademicPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicPerformances to delete
     */
    where?: AcademicPerformanceWhereInput
  }

  /**
   * AcademicPerformance without action
   */
  export type AcademicPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicPerformance
     */
    select?: AcademicPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model BehaviorRecord
   */

  export type AggregateBehaviorRecord = {
    _count: BehaviorRecordCountAggregateOutputType | null
    _avg: BehaviorRecordAvgAggregateOutputType | null
    _sum: BehaviorRecordSumAggregateOutputType | null
    _min: BehaviorRecordMinAggregateOutputType | null
    _max: BehaviorRecordMaxAggregateOutputType | null
  }

  export type BehaviorRecordAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type BehaviorRecordSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type BehaviorRecordMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    type: string | null
    title: string | null
    summary: string | null
    timestamp: Date | null
  }

  export type BehaviorRecordMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    type: string | null
    title: string | null
    summary: string | null
    timestamp: Date | null
  }

  export type BehaviorRecordCountAggregateOutputType = {
    id: number
    studentId: number
    type: number
    title: number
    summary: number
    timestamp: number
    _all: number
  }


  export type BehaviorRecordAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type BehaviorRecordSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type BehaviorRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    title?: true
    summary?: true
    timestamp?: true
  }

  export type BehaviorRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    title?: true
    summary?: true
    timestamp?: true
  }

  export type BehaviorRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    title?: true
    summary?: true
    timestamp?: true
    _all?: true
  }

  export type BehaviorRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorRecord to aggregate.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehaviorRecords
    **/
    _count?: true | BehaviorRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehaviorRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehaviorRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehaviorRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehaviorRecordMaxAggregateInputType
  }

  export type GetBehaviorRecordAggregateType<T extends BehaviorRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBehaviorRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehaviorRecord[P]>
      : GetScalarType<T[P], AggregateBehaviorRecord[P]>
  }




  export type BehaviorRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorRecordWhereInput
    orderBy?: BehaviorRecordOrderByWithAggregationInput | BehaviorRecordOrderByWithAggregationInput[]
    by: BehaviorRecordScalarFieldEnum[] | BehaviorRecordScalarFieldEnum
    having?: BehaviorRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehaviorRecordCountAggregateInputType | true
    _avg?: BehaviorRecordAvgAggregateInputType
    _sum?: BehaviorRecordSumAggregateInputType
    _min?: BehaviorRecordMinAggregateInputType
    _max?: BehaviorRecordMaxAggregateInputType
  }

  export type BehaviorRecordGroupByOutputType = {
    id: number
    studentId: number
    type: string
    title: string
    summary: string | null
    timestamp: Date
    _count: BehaviorRecordCountAggregateOutputType | null
    _avg: BehaviorRecordAvgAggregateOutputType | null
    _sum: BehaviorRecordSumAggregateOutputType | null
    _min: BehaviorRecordMinAggregateOutputType | null
    _max: BehaviorRecordMaxAggregateOutputType | null
  }

  type GetBehaviorRecordGroupByPayload<T extends BehaviorRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehaviorRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehaviorRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehaviorRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BehaviorRecordGroupByOutputType[P]>
        }
      >
    >


  export type BehaviorRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    summary?: boolean
    timestamp?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorRecord"]>

  export type BehaviorRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    summary?: boolean
    timestamp?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorRecord"]>

  export type BehaviorRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    type?: boolean
    title?: boolean
    summary?: boolean
    timestamp?: boolean
  }

  export type BehaviorRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BehaviorRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $BehaviorRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehaviorRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      type: string
      title: string
      summary: string | null
      timestamp: Date
    }, ExtArgs["result"]["behaviorRecord"]>
    composites: {}
  }

  type BehaviorRecordGetPayload<S extends boolean | null | undefined | BehaviorRecordDefaultArgs> = $Result.GetResult<Prisma.$BehaviorRecordPayload, S>

  type BehaviorRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehaviorRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehaviorRecordCountAggregateInputType | true
    }

  export interface BehaviorRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehaviorRecord'], meta: { name: 'BehaviorRecord' } }
    /**
     * Find zero or one BehaviorRecord that matches the filter.
     * @param {BehaviorRecordFindUniqueArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehaviorRecordFindUniqueArgs>(args: SelectSubset<T, BehaviorRecordFindUniqueArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehaviorRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehaviorRecordFindUniqueOrThrowArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehaviorRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, BehaviorRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehaviorRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindFirstArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehaviorRecordFindFirstArgs>(args?: SelectSubset<T, BehaviorRecordFindFirstArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehaviorRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindFirstOrThrowArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehaviorRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, BehaviorRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehaviorRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehaviorRecords
     * const behaviorRecords = await prisma.behaviorRecord.findMany()
     * 
     * // Get first 10 BehaviorRecords
     * const behaviorRecords = await prisma.behaviorRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behaviorRecordWithIdOnly = await prisma.behaviorRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehaviorRecordFindManyArgs>(args?: SelectSubset<T, BehaviorRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehaviorRecord.
     * @param {BehaviorRecordCreateArgs} args - Arguments to create a BehaviorRecord.
     * @example
     * // Create one BehaviorRecord
     * const BehaviorRecord = await prisma.behaviorRecord.create({
     *   data: {
     *     // ... data to create a BehaviorRecord
     *   }
     * })
     * 
     */
    create<T extends BehaviorRecordCreateArgs>(args: SelectSubset<T, BehaviorRecordCreateArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehaviorRecords.
     * @param {BehaviorRecordCreateManyArgs} args - Arguments to create many BehaviorRecords.
     * @example
     * // Create many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehaviorRecordCreateManyArgs>(args?: SelectSubset<T, BehaviorRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehaviorRecords and returns the data saved in the database.
     * @param {BehaviorRecordCreateManyAndReturnArgs} args - Arguments to create many BehaviorRecords.
     * @example
     * // Create many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehaviorRecords and only return the `id`
     * const behaviorRecordWithIdOnly = await prisma.behaviorRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehaviorRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, BehaviorRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehaviorRecord.
     * @param {BehaviorRecordDeleteArgs} args - Arguments to delete one BehaviorRecord.
     * @example
     * // Delete one BehaviorRecord
     * const BehaviorRecord = await prisma.behaviorRecord.delete({
     *   where: {
     *     // ... filter to delete one BehaviorRecord
     *   }
     * })
     * 
     */
    delete<T extends BehaviorRecordDeleteArgs>(args: SelectSubset<T, BehaviorRecordDeleteArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehaviorRecord.
     * @param {BehaviorRecordUpdateArgs} args - Arguments to update one BehaviorRecord.
     * @example
     * // Update one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehaviorRecordUpdateArgs>(args: SelectSubset<T, BehaviorRecordUpdateArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehaviorRecords.
     * @param {BehaviorRecordDeleteManyArgs} args - Arguments to filter BehaviorRecords to delete.
     * @example
     * // Delete a few BehaviorRecords
     * const { count } = await prisma.behaviorRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehaviorRecordDeleteManyArgs>(args?: SelectSubset<T, BehaviorRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehaviorRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehaviorRecordUpdateManyArgs>(args: SelectSubset<T, BehaviorRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehaviorRecord.
     * @param {BehaviorRecordUpsertArgs} args - Arguments to update or create a BehaviorRecord.
     * @example
     * // Update or create a BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.upsert({
     *   create: {
     *     // ... data to create a BehaviorRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehaviorRecord we want to update
     *   }
     * })
     */
    upsert<T extends BehaviorRecordUpsertArgs>(args: SelectSubset<T, BehaviorRecordUpsertArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehaviorRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordCountArgs} args - Arguments to filter BehaviorRecords to count.
     * @example
     * // Count the number of BehaviorRecords
     * const count = await prisma.behaviorRecord.count({
     *   where: {
     *     // ... the filter for the BehaviorRecords we want to count
     *   }
     * })
    **/
    count<T extends BehaviorRecordCountArgs>(
      args?: Subset<T, BehaviorRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehaviorRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehaviorRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehaviorRecordAggregateArgs>(args: Subset<T, BehaviorRecordAggregateArgs>): Prisma.PrismaPromise<GetBehaviorRecordAggregateType<T>>

    /**
     * Group by BehaviorRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehaviorRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehaviorRecordGroupByArgs['orderBy'] }
        : { orderBy?: BehaviorRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehaviorRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehaviorRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehaviorRecord model
   */
  readonly fields: BehaviorRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehaviorRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehaviorRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehaviorRecord model
   */ 
  interface BehaviorRecordFieldRefs {
    readonly id: FieldRef<"BehaviorRecord", 'Int'>
    readonly studentId: FieldRef<"BehaviorRecord", 'Int'>
    readonly type: FieldRef<"BehaviorRecord", 'String'>
    readonly title: FieldRef<"BehaviorRecord", 'String'>
    readonly summary: FieldRef<"BehaviorRecord", 'String'>
    readonly timestamp: FieldRef<"BehaviorRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BehaviorRecord findUnique
   */
  export type BehaviorRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord findUniqueOrThrow
   */
  export type BehaviorRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord findFirst
   */
  export type BehaviorRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorRecords.
     */
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord findFirstOrThrow
   */
  export type BehaviorRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorRecords.
     */
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord findMany
   */
  export type BehaviorRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecords to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord create
   */
  export type BehaviorRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BehaviorRecord.
     */
    data: XOR<BehaviorRecordCreateInput, BehaviorRecordUncheckedCreateInput>
  }

  /**
   * BehaviorRecord createMany
   */
  export type BehaviorRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehaviorRecords.
     */
    data: BehaviorRecordCreateManyInput | BehaviorRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehaviorRecord createManyAndReturn
   */
  export type BehaviorRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehaviorRecords.
     */
    data: BehaviorRecordCreateManyInput | BehaviorRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehaviorRecord update
   */
  export type BehaviorRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BehaviorRecord.
     */
    data: XOR<BehaviorRecordUpdateInput, BehaviorRecordUncheckedUpdateInput>
    /**
     * Choose, which BehaviorRecord to update.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord updateMany
   */
  export type BehaviorRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehaviorRecords.
     */
    data: XOR<BehaviorRecordUpdateManyMutationInput, BehaviorRecordUncheckedUpdateManyInput>
    /**
     * Filter which BehaviorRecords to update
     */
    where?: BehaviorRecordWhereInput
  }

  /**
   * BehaviorRecord upsert
   */
  export type BehaviorRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BehaviorRecord to update in case it exists.
     */
    where: BehaviorRecordWhereUniqueInput
    /**
     * In case the BehaviorRecord found by the `where` argument doesn't exist, create a new BehaviorRecord with this data.
     */
    create: XOR<BehaviorRecordCreateInput, BehaviorRecordUncheckedCreateInput>
    /**
     * In case the BehaviorRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehaviorRecordUpdateInput, BehaviorRecordUncheckedUpdateInput>
  }

  /**
   * BehaviorRecord delete
   */
  export type BehaviorRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter which BehaviorRecord to delete.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord deleteMany
   */
  export type BehaviorRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorRecords to delete
     */
    where?: BehaviorRecordWhereInput
  }

  /**
   * BehaviorRecord without action
   */
  export type BehaviorRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type BadgeSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    description: string | null
    iconName: string | null
    color: string | null
    awardedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    description: string | null
    iconName: string | null
    color: string | null
    awardedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    studentId: number
    name: number
    description: number
    iconName: number
    color: number
    awardedAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type BadgeSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    iconName?: true
    color?: true
    awardedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    iconName?: true
    color?: true
    awardedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    iconName?: true
    color?: true
    awardedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: number
    studentId: number
    name: string
    description: string | null
    iconName: string | null
    color: string | null
    awardedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    color?: boolean
    awardedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    color?: boolean
    awardedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    iconName?: boolean
    color?: boolean
    awardedAt?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      name: string
      description: string | null
      iconName: string | null
      color: string | null
      awardedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'Int'>
    readonly studentId: FieldRef<"Badge", 'Int'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly iconName: FieldRef<"Badge", 'String'>
    readonly color: FieldRef<"Badge", 'String'>
    readonly awardedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type CertificateSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    issuer: string | null
    fileUrl: string | null
    issuedDate: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    issuer: string | null
    fileUrl: string | null
    issuedDate: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    studentId: number
    name: number
    issuer: number
    fileUrl: number
    issuedDate: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type CertificateSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    issuer?: true
    fileUrl?: true
    issuedDate?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    issuer?: true
    fileUrl?: true
    issuedDate?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    issuer?: true
    fileUrl?: true
    issuedDate?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: number
    studentId: number
    name: string
    issuer: string | null
    fileUrl: string | null
    issuedDate: Date | null
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    issuer?: boolean
    fileUrl?: boolean
    issuedDate?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    issuer?: boolean
    fileUrl?: boolean
    issuedDate?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    studentId?: boolean
    name?: boolean
    issuer?: boolean
    fileUrl?: boolean
    issuedDate?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      name: string
      issuer: string | null
      fileUrl: string | null
      issuedDate: Date | null
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'Int'>
    readonly studentId: FieldRef<"Certificate", 'Int'>
    readonly name: FieldRef<"Certificate", 'String'>
    readonly issuer: FieldRef<"Certificate", 'String'>
    readonly fileUrl: FieldRef<"Certificate", 'String'>
    readonly issuedDate: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Award
   */

  export type AggregateAward = {
    _count: AwardCountAggregateOutputType | null
    _avg: AwardAvgAggregateOutputType | null
    _sum: AwardSumAggregateOutputType | null
    _min: AwardMinAggregateOutputType | null
    _max: AwardMaxAggregateOutputType | null
  }

  export type AwardAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type AwardSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type AwardMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    description: string | null
    date: Date | null
  }

  export type AwardMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    name: string | null
    description: string | null
    date: Date | null
  }

  export type AwardCountAggregateOutputType = {
    id: number
    studentId: number
    name: number
    description: number
    date: number
    _all: number
  }


  export type AwardAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type AwardSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type AwardMinAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    date?: true
  }

  export type AwardMaxAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    date?: true
  }

  export type AwardCountAggregateInputType = {
    id?: true
    studentId?: true
    name?: true
    description?: true
    date?: true
    _all?: true
  }

  export type AwardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Award to aggregate.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Awards
    **/
    _count?: true | AwardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AwardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AwardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardMaxAggregateInputType
  }

  export type GetAwardAggregateType<T extends AwardAggregateArgs> = {
        [P in keyof T & keyof AggregateAward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAward[P]>
      : GetScalarType<T[P], AggregateAward[P]>
  }




  export type AwardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AwardWhereInput
    orderBy?: AwardOrderByWithAggregationInput | AwardOrderByWithAggregationInput[]
    by: AwardScalarFieldEnum[] | AwardScalarFieldEnum
    having?: AwardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardCountAggregateInputType | true
    _avg?: AwardAvgAggregateInputType
    _sum?: AwardSumAggregateInputType
    _min?: AwardMinAggregateInputType
    _max?: AwardMaxAggregateInputType
  }

  export type AwardGroupByOutputType = {
    id: number
    studentId: number
    name: string
    description: string | null
    date: Date | null
    _count: AwardCountAggregateOutputType | null
    _avg: AwardAvgAggregateOutputType | null
    _sum: AwardSumAggregateOutputType | null
    _min: AwardMinAggregateOutputType | null
    _max: AwardMaxAggregateOutputType | null
  }

  type GetAwardGroupByPayload<T extends AwardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardGroupByOutputType[P]>
            : GetScalarType<T[P], AwardGroupByOutputType[P]>
        }
      >
    >


  export type AwardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["award"]>

  export type AwardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["award"]>

  export type AwardSelectScalar = {
    id?: boolean
    studentId?: boolean
    name?: boolean
    description?: boolean
    date?: boolean
  }

  export type AwardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type AwardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AwardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Award"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      name: string
      description: string | null
      date: Date | null
    }, ExtArgs["result"]["award"]>
    composites: {}
  }

  type AwardGetPayload<S extends boolean | null | undefined | AwardDefaultArgs> = $Result.GetResult<Prisma.$AwardPayload, S>

  type AwardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AwardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AwardCountAggregateInputType | true
    }

  export interface AwardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Award'], meta: { name: 'Award' } }
    /**
     * Find zero or one Award that matches the filter.
     * @param {AwardFindUniqueArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AwardFindUniqueArgs>(args: SelectSubset<T, AwardFindUniqueArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Award that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AwardFindUniqueOrThrowArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AwardFindUniqueOrThrowArgs>(args: SelectSubset<T, AwardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Award that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindFirstArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AwardFindFirstArgs>(args?: SelectSubset<T, AwardFindFirstArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Award that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindFirstOrThrowArgs} args - Arguments to find a Award
     * @example
     * // Get one Award
     * const award = await prisma.award.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AwardFindFirstOrThrowArgs>(args?: SelectSubset<T, AwardFindFirstOrThrowArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Awards
     * const awards = await prisma.award.findMany()
     * 
     * // Get first 10 Awards
     * const awards = await prisma.award.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardWithIdOnly = await prisma.award.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AwardFindManyArgs>(args?: SelectSubset<T, AwardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Award.
     * @param {AwardCreateArgs} args - Arguments to create a Award.
     * @example
     * // Create one Award
     * const Award = await prisma.award.create({
     *   data: {
     *     // ... data to create a Award
     *   }
     * })
     * 
     */
    create<T extends AwardCreateArgs>(args: SelectSubset<T, AwardCreateArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Awards.
     * @param {AwardCreateManyArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const award = await prisma.award.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AwardCreateManyArgs>(args?: SelectSubset<T, AwardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Awards and returns the data saved in the database.
     * @param {AwardCreateManyAndReturnArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const award = await prisma.award.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Awards and only return the `id`
     * const awardWithIdOnly = await prisma.award.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AwardCreateManyAndReturnArgs>(args?: SelectSubset<T, AwardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Award.
     * @param {AwardDeleteArgs} args - Arguments to delete one Award.
     * @example
     * // Delete one Award
     * const Award = await prisma.award.delete({
     *   where: {
     *     // ... filter to delete one Award
     *   }
     * })
     * 
     */
    delete<T extends AwardDeleteArgs>(args: SelectSubset<T, AwardDeleteArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Award.
     * @param {AwardUpdateArgs} args - Arguments to update one Award.
     * @example
     * // Update one Award
     * const award = await prisma.award.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AwardUpdateArgs>(args: SelectSubset<T, AwardUpdateArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Awards.
     * @param {AwardDeleteManyArgs} args - Arguments to filter Awards to delete.
     * @example
     * // Delete a few Awards
     * const { count } = await prisma.award.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AwardDeleteManyArgs>(args?: SelectSubset<T, AwardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Awards
     * const award = await prisma.award.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AwardUpdateManyArgs>(args: SelectSubset<T, AwardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Award.
     * @param {AwardUpsertArgs} args - Arguments to update or create a Award.
     * @example
     * // Update or create a Award
     * const award = await prisma.award.upsert({
     *   create: {
     *     // ... data to create a Award
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Award we want to update
     *   }
     * })
     */
    upsert<T extends AwardUpsertArgs>(args: SelectSubset<T, AwardUpsertArgs<ExtArgs>>): Prisma__AwardClient<$Result.GetResult<Prisma.$AwardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardCountArgs} args - Arguments to filter Awards to count.
     * @example
     * // Count the number of Awards
     * const count = await prisma.award.count({
     *   where: {
     *     // ... the filter for the Awards we want to count
     *   }
     * })
    **/
    count<T extends AwardCountArgs>(
      args?: Subset<T, AwardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Award.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardAggregateArgs>(args: Subset<T, AwardAggregateArgs>): Prisma.PrismaPromise<GetAwardAggregateType<T>>

    /**
     * Group by Award.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AwardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AwardGroupByArgs['orderBy'] }
        : { orderBy?: AwardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AwardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Award model
   */
  readonly fields: AwardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Award.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AwardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Award model
   */ 
  interface AwardFieldRefs {
    readonly id: FieldRef<"Award", 'Int'>
    readonly studentId: FieldRef<"Award", 'Int'>
    readonly name: FieldRef<"Award", 'String'>
    readonly description: FieldRef<"Award", 'String'>
    readonly date: FieldRef<"Award", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Award findUnique
   */
  export type AwardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award findUniqueOrThrow
   */
  export type AwardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award findFirst
   */
  export type AwardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award findFirstOrThrow
   */
  export type AwardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Award to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Awards.
     */
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award findMany
   */
  export type AwardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter, which Awards to fetch.
     */
    where?: AwardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Awards to fetch.
     */
    orderBy?: AwardOrderByWithRelationInput | AwardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Awards.
     */
    cursor?: AwardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Awards.
     */
    skip?: number
    distinct?: AwardScalarFieldEnum | AwardScalarFieldEnum[]
  }

  /**
   * Award create
   */
  export type AwardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The data needed to create a Award.
     */
    data: XOR<AwardCreateInput, AwardUncheckedCreateInput>
  }

  /**
   * Award createMany
   */
  export type AwardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Awards.
     */
    data: AwardCreateManyInput | AwardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Award createManyAndReturn
   */
  export type AwardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Awards.
     */
    data: AwardCreateManyInput | AwardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Award update
   */
  export type AwardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The data needed to update a Award.
     */
    data: XOR<AwardUpdateInput, AwardUncheckedUpdateInput>
    /**
     * Choose, which Award to update.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award updateMany
   */
  export type AwardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Awards.
     */
    data: XOR<AwardUpdateManyMutationInput, AwardUncheckedUpdateManyInput>
    /**
     * Filter which Awards to update
     */
    where?: AwardWhereInput
  }

  /**
   * Award upsert
   */
  export type AwardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * The filter to search for the Award to update in case it exists.
     */
    where: AwardWhereUniqueInput
    /**
     * In case the Award found by the `where` argument doesn't exist, create a new Award with this data.
     */
    create: XOR<AwardCreateInput, AwardUncheckedCreateInput>
    /**
     * In case the Award was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AwardUpdateInput, AwardUncheckedUpdateInput>
  }

  /**
   * Award delete
   */
  export type AwardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
    /**
     * Filter which Award to delete.
     */
    where: AwardWhereUniqueInput
  }

  /**
   * Award deleteMany
   */
  export type AwardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Awards to delete
     */
    where?: AwardWhereInput
  }

  /**
   * Award without action
   */
  export type AwardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Award
     */
    select?: AwardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AwardInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    id: number | null
    totalStudents: number | null
    submissionsCount: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    id: number | null
    totalStudents: number | null
    submissionsCount: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    className: string | null
    subject: string | null
    dueDate: Date | null
    totalStudents: number | null
    submissionsCount: number | null
    createdAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    className: string | null
    subject: string | null
    dueDate: Date | null
    totalStudents: number | null
    submissionsCount: number | null
    createdAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    className: number
    subject: number
    dueDate: number
    totalStudents: number
    submissionsCount: number
    createdAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    id?: true
    totalStudents?: true
    submissionsCount?: true
  }

  export type AssignmentSumAggregateInputType = {
    id?: true
    totalStudents?: true
    submissionsCount?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    className?: true
    subject?: true
    dueDate?: true
    totalStudents?: true
    submissionsCount?: true
    createdAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    className?: true
    subject?: true
    dueDate?: true
    totalStudents?: true
    submissionsCount?: true
    createdAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    className?: true
    subject?: true
    dueDate?: true
    totalStudents?: true
    submissionsCount?: true
    createdAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: number
    title: string
    description: string | null
    className: string
    subject: string
    dueDate: Date
    totalStudents: number | null
    submissionsCount: number | null
    createdAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    className?: boolean
    subject?: boolean
    dueDate?: boolean
    totalStudents?: boolean
    submissionsCount?: boolean
    createdAt?: boolean
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    className?: boolean
    subject?: boolean
    dueDate?: boolean
    totalStudents?: boolean
    submissionsCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    className?: boolean
    subject?: boolean
    dueDate?: boolean
    totalStudents?: boolean
    submissionsCount?: boolean
    createdAt?: boolean
  }

  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      className: string
      subject: string
      dueDate: Date
      totalStudents: number | null
      submissionsCount: number | null
      createdAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submissions<T extends Assignment$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'Int'>
    readonly title: FieldRef<"Assignment", 'String'>
    readonly description: FieldRef<"Assignment", 'String'>
    readonly className: FieldRef<"Assignment", 'String'>
    readonly subject: FieldRef<"Assignment", 'String'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly totalStudents: FieldRef<"Assignment", 'Int'>
    readonly submissionsCount: FieldRef<"Assignment", 'Int'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment.submissions
   */
  export type Assignment$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    studentId: number | null
    grade: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    studentId: number | null
    grade: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    studentId: number | null
    submittedAt: Date | null
    isLate: boolean | null
    status: string | null
    grade: number | null
    feedback: string | null
    textSubmission: string | null
    fileUrl: string | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    studentId: number | null
    submittedAt: Date | null
    isLate: boolean | null
    status: string | null
    grade: number | null
    feedback: string | null
    textSubmission: string | null
    fileUrl: string | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    assignmentId: number
    studentId: number
    submittedAt: number
    isLate: number
    status: number
    grade: number
    feedback: number
    textSubmission: number
    fileUrl: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    grade?: true
  }

  export type SubmissionSumAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    grade?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    isLate?: true
    status?: true
    grade?: true
    feedback?: true
    textSubmission?: true
    fileUrl?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    isLate?: true
    status?: true
    grade?: true
    feedback?: true
    textSubmission?: true
    fileUrl?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    submittedAt?: true
    isLate?: true
    status?: true
    grade?: true
    feedback?: true
    textSubmission?: true
    fileUrl?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    id: number
    assignmentId: number
    studentId: number
    submittedAt: Date
    isLate: boolean | null
    status: string | null
    grade: number | null
    feedback: string | null
    textSubmission: string | null
    fileUrl: string | null
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    isLate?: boolean
    status?: boolean
    grade?: boolean
    feedback?: boolean
    textSubmission?: boolean
    fileUrl?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    isLate?: boolean
    status?: boolean
    grade?: boolean
    feedback?: boolean
    textSubmission?: boolean
    fileUrl?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    submittedAt?: boolean
    isLate?: boolean
    status?: boolean
    grade?: boolean
    feedback?: boolean
    textSubmission?: boolean
    fileUrl?: boolean
  }

  export type SubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type SubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $SubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submission"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assignmentId: number
      studentId: number
      submittedAt: Date
      isLate: boolean | null
      status: string | null
      grade: number | null
      feedback: string | null
      textSubmission: string | null
      fileUrl: string | null
    }, ExtArgs["result"]["submission"]>
    composites: {}
  }

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> = $Result.GetResult<Prisma.$SubmissionPayload, S>

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submission'], meta: { name: 'Submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionFindManyArgs>(args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
     */
    create<T extends SubmissionCreateArgs>(args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionCreateManyArgs>(args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Submissions and returns the data saved in the database.
     * @param {SubmissionCreateManyAndReturnArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
     */
    delete<T extends SubmissionDeleteArgs>(args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionUpdateArgs>(args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionUpdateManyArgs>(args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submission model
   */
  readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submission model
   */ 
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", 'Int'>
    readonly assignmentId: FieldRef<"Submission", 'Int'>
    readonly studentId: FieldRef<"Submission", 'Int'>
    readonly submittedAt: FieldRef<"Submission", 'DateTime'>
    readonly isLate: FieldRef<"Submission", 'Boolean'>
    readonly status: FieldRef<"Submission", 'String'>
    readonly grade: FieldRef<"Submission", 'Int'>
    readonly feedback: FieldRef<"Submission", 'String'>
    readonly textSubmission: FieldRef<"Submission", 'String'>
    readonly fileUrl: FieldRef<"Submission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Submission createManyAndReturn
   */
  export type SubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type ExamSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: number | null
    type: string | null
    date: Date | null
    time: string | null
    className: string | null
    subject: string | null
    isPublished: boolean | null
    teacherId: number | null
  }

  export type ExamMaxAggregateOutputType = {
    id: number | null
    type: string | null
    date: Date | null
    time: string | null
    className: string | null
    subject: string | null
    isPublished: boolean | null
    teacherId: number | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    type: number
    date: number
    time: number
    className: number
    subject: number
    isPublished: number
    teacherId: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type ExamSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    type?: true
    date?: true
    time?: true
    className?: true
    subject?: true
    isPublished?: true
    teacherId?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    type?: true
    date?: true
    time?: true
    className?: true
    subject?: true
    isPublished?: true
    teacherId?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    type?: true
    date?: true
    time?: true
    className?: true
    subject?: true
    isPublished?: true
    teacherId?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: number
    type: string
    date: Date
    time: string
    className: string
    subject: string
    isPublished: boolean | null
    teacherId: number | null
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    time?: boolean
    className?: boolean
    subject?: boolean
    isPublished?: boolean
    teacherId?: boolean
    teacher?: boolean | Exam$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    date?: boolean
    time?: boolean
    className?: boolean
    subject?: boolean
    isPublished?: boolean
    teacherId?: boolean
    teacher?: boolean | Exam$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    type?: boolean
    date?: boolean
    time?: boolean
    className?: boolean
    subject?: boolean
    isPublished?: boolean
    teacherId?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Exam$teacherArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Exam$teacherArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      date: Date
      time: string
      className: string
      subject: string
      isPublished: boolean | null
      teacherId: number | null
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends Exam$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Exam$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'Int'>
    readonly type: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly time: FieldRef<"Exam", 'String'>
    readonly className: FieldRef<"Exam", 'String'>
    readonly subject: FieldRef<"Exam", 'String'>
    readonly isPublished: FieldRef<"Exam", 'Boolean'>
    readonly teacherId: FieldRef<"Exam", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam.teacher
   */
  export type Exam$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model Notice
   */

  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    timestamp: Date | null
    category: string | null
    isPinned: boolean | null
    createdBy: string | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    timestamp: Date | null
    category: string | null
    isPinned: boolean | null
    createdBy: string | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    timestamp: number
    category: number
    isPinned: number
    audience: number
    createdBy: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timestamp?: true
    category?: true
    isPinned?: true
    createdBy?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timestamp?: true
    category?: true
    isPinned?: true
    createdBy?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    timestamp?: true
    category?: true
    isPinned?: true
    audience?: true
    createdBy?: true
    _all?: true
  }

  export type NoticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeWhereInput
    orderBy?: NoticeOrderByWithAggregationInput | NoticeOrderByWithAggregationInput[]
    by: NoticeScalarFieldEnum[] | NoticeScalarFieldEnum
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }

  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    timestamp: Date
    category: string
    isPinned: boolean | null
    audience: JsonValue | null
    createdBy: string | null
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    timestamp?: boolean
    category?: boolean
    isPinned?: boolean
    audience?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    timestamp?: boolean
    category?: boolean
    isPinned?: boolean
    audience?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["notice"]>

  export type NoticeSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    timestamp?: boolean
    category?: boolean
    isPinned?: boolean
    audience?: boolean
    createdBy?: boolean
  }


  export type $NoticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      timestamp: Date
      category: string
      isPinned: boolean | null
      audience: Prisma.JsonValue | null
      createdBy: string | null
    }, ExtArgs["result"]["notice"]>
    composites: {}
  }

  type NoticeGetPayload<S extends boolean | null | undefined | NoticeDefaultArgs> = $Result.GetResult<Prisma.$NoticePayload, S>

  type NoticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoticeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notice'], meta: { name: 'Notice' } }
    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeFindUniqueArgs>(args: SelectSubset<T, NoticeFindUniqueArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeFindFirstArgs>(args?: SelectSubset<T, NoticeFindFirstArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeFindManyArgs>(args?: SelectSubset<T, NoticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
     */
    create<T extends NoticeCreateArgs>(args: SelectSubset<T, NoticeCreateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notices.
     * @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeCreateManyArgs>(args?: SelectSubset<T, NoticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notices and returns the data saved in the database.
     * @param {NoticeCreateManyAndReturnArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notice = await prisma.notice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notices and only return the `id`
     * const noticeWithIdOnly = await prisma.notice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoticeCreateManyAndReturnArgs>(args?: SelectSubset<T, NoticeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
     */
    delete<T extends NoticeDeleteArgs>(args: SelectSubset<T, NoticeDeleteArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeUpdateArgs>(args: SelectSubset<T, NoticeUpdateArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeDeleteManyArgs>(args?: SelectSubset<T, NoticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeUpdateManyArgs>(args: SelectSubset<T, NoticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
     */
    upsert<T extends NoticeUpsertArgs>(args: SelectSubset<T, NoticeUpsertArgs<ExtArgs>>): Prisma__NoticeClient<$Result.GetResult<Prisma.$NoticePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notice model
   */
  readonly fields: NoticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notice model
   */ 
  interface NoticeFieldRefs {
    readonly id: FieldRef<"Notice", 'Int'>
    readonly title: FieldRef<"Notice", 'String'>
    readonly content: FieldRef<"Notice", 'String'>
    readonly timestamp: FieldRef<"Notice", 'DateTime'>
    readonly category: FieldRef<"Notice", 'String'>
    readonly isPinned: FieldRef<"Notice", 'Boolean'>
    readonly audience: FieldRef<"Notice", 'Json'>
    readonly createdBy: FieldRef<"Notice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notice findUnique
   */
  export type NoticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findFirst
   */
  export type NoticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: NoticeOrderByWithRelationInput | NoticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: NoticeScalarFieldEnum | NoticeScalarFieldEnum[]
  }

  /**
   * Notice create
   */
  export type NoticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }

  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice createManyAndReturn
   */
  export type NoticeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notices.
     */
    data: NoticeCreateManyInput | NoticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notice update
   */
  export type NoticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
  }

  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }

  /**
   * Notice delete
   */
  export type NoticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
  }

  /**
   * Notice without action
   */
  export type NoticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    studentId: number | null
    relatedId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    studentId: number | null
    relatedId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    category: string | null
    title: string | null
    summary: string | null
    isRead: boolean | null
    timestamp: Date | null
    studentId: number | null
    relatedId: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    category: string | null
    title: string | null
    summary: string | null
    isRead: boolean | null
    timestamp: Date | null
    studentId: number | null
    relatedId: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    title: number
    summary: number
    isRead: number
    timestamp: number
    studentId: number
    relatedId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    relatedId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
    studentId?: true
    relatedId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    title?: true
    summary?: true
    isRead?: true
    timestamp?: true
    studentId?: true
    relatedId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    title?: true
    summary?: true
    isRead?: true
    timestamp?: true
    studentId?: true
    relatedId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    title?: true
    summary?: true
    isRead?: true
    timestamp?: true
    studentId?: true
    relatedId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number | null
    category: string
    title: string
    summary: string | null
    isRead: boolean | null
    timestamp: Date
    studentId: number | null
    relatedId: number | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    title?: boolean
    summary?: boolean
    isRead?: boolean
    timestamp?: boolean
    studentId?: boolean
    relatedId?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    title?: boolean
    summary?: boolean
    isRead?: boolean
    timestamp?: boolean
    studentId?: boolean
    relatedId?: boolean
    user?: boolean | Notification$userArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    title?: boolean
    summary?: boolean
    isRead?: boolean
    timestamp?: boolean
    studentId?: boolean
    relatedId?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Notification$userArgs<ExtArgs>
    student?: boolean | Notification$studentArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      category: string
      title: string
      summary: string | null
      isRead: boolean | null
      timestamp: Date
      studentId: number | null
      relatedId: number | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    student<T extends Notification$studentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly category: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly summary: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly timestamp: FieldRef<"Notification", 'DateTime'>
    readonly studentId: FieldRef<"Notification", 'Int'>
    readonly relatedId: FieldRef<"Notification", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification.student
   */
  export type Notification$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    createdAt: Date | null
    lastMessageAt: Date | null
    lastMessageText: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    createdAt: Date | null
    lastMessageAt: Date | null
    lastMessageText: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    type: number
    name: number
    createdAt: number
    lastMessageAt: number
    lastMessageText: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    createdAt?: true
    lastMessageAt?: true
    lastMessageText?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    createdAt?: true
    lastMessageAt?: true
    lastMessageText?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    createdAt?: true
    lastMessageAt?: true
    lastMessageText?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: number
    type: string
    name: string | null
    createdAt: Date
    lastMessageAt: Date | null
    lastMessageText: string | null
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    lastMessageAt?: boolean
    lastMessageText?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    lastMessageAt?: boolean
    lastMessageText?: boolean
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    createdAt?: boolean
    lastMessageAt?: boolean
    lastMessageText?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      name: string | null
      createdAt: Date
      lastMessageAt: Date | null
      lastMessageText: string | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'Int'>
    readonly type: FieldRef<"Conversation", 'String'>
    readonly name: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessageText: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data?: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _avg: ConversationParticipantAvgAggregateOutputType | null
    _sum: ConversationParticipantSumAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantAvgAggregateOutputType = {
    conversationId: number | null
    userId: number | null
  }

  export type ConversationParticipantSumAggregateOutputType = {
    conversationId: number | null
    userId: number | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    conversationId: number | null
    userId: number | null
    role: string | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    conversationId: number | null
    userId: number | null
    role: string | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    conversationId: number
    userId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantAvgAggregateInputType = {
    conversationId?: true
    userId?: true
  }

  export type ConversationParticipantSumAggregateInputType = {
    conversationId?: true
    userId?: true
  }

  export type ConversationParticipantMinAggregateInputType = {
    conversationId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    conversationId?: true
    userId?: true
    role?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    conversationId?: true
    userId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _avg?: ConversationParticipantAvgAggregateInputType
    _sum?: ConversationParticipantSumAggregateInputType
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    conversationId: number
    userId: number
    role: string | null
    joinedAt: Date | null
    _count: ConversationParticipantCountAggregateOutputType | null
    _avg: ConversationParticipantAvgAggregateOutputType | null
    _sum: ConversationParticipantSumAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    conversationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      conversationId: number
      userId: number
      role: string | null
      joinedAt: Date | null
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.findMany({ select: { conversationId: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `conversationId`
     * const conversationParticipantWithConversationIdOnly = await prisma.conversationParticipant.createManyAndReturn({ 
     *   select: { conversationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */ 
  interface ConversationParticipantFieldRefs {
    readonly conversationId: FieldRef<"ConversationParticipant", 'Int'>
    readonly userId: FieldRef<"ConversationParticipant", 'Int'>
    readonly role: FieldRef<"ConversationParticipant", 'String'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
    content: string | null
    type: string | null
    mediaUrl: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    conversationId: number | null
    senderId: number | null
    content: string | null
    type: string | null
    mediaUrl: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    type: number
    mediaUrl: number
    createdAt: number
    isRead: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    mediaUrl?: true
    createdAt?: true
    isRead?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    mediaUrl?: true
    createdAt?: true
    isRead?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    type?: true
    mediaUrl?: true
    createdAt?: true
    isRead?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    conversationId: number
    senderId: number | null
    content: string | null
    type: string | null
    mediaUrl: string | null
    createdAt: Date
    isRead: boolean | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    isRead?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    isRead?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    isRead?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conversationId: number
      senderId: number | null
      content: string | null
      type: string | null
      mediaUrl: string | null
      createdAt: Date
      isRead: boolean | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends Message$senderArgs<ExtArgs> = {}>(args?: Subset<T, Message$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly conversationId: FieldRef<"Message", 'Int'>
    readonly senderId: FieldRef<"Message", 'Int'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.sender
   */
  export type Message$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ForumTopic
   */

  export type AggregateForumTopic = {
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  export type ForumTopicAvgAggregateOutputType = {
    id: number | null
    postCount: number | null
  }

  export type ForumTopicSumAggregateOutputType = {
    id: number | null
    postCount: number | null
  }

  export type ForumTopicMinAggregateOutputType = {
    id: number | null
    title: string | null
    authorName: string | null
    createdAt: Date | null
    postCount: number | null
    lastActivity: Date | null
  }

  export type ForumTopicMaxAggregateOutputType = {
    id: number | null
    title: string | null
    authorName: string | null
    createdAt: Date | null
    postCount: number | null
    lastActivity: Date | null
  }

  export type ForumTopicCountAggregateOutputType = {
    id: number
    title: number
    authorName: number
    createdAt: number
    postCount: number
    lastActivity: number
    _all: number
  }


  export type ForumTopicAvgAggregateInputType = {
    id?: true
    postCount?: true
  }

  export type ForumTopicSumAggregateInputType = {
    id?: true
    postCount?: true
  }

  export type ForumTopicMinAggregateInputType = {
    id?: true
    title?: true
    authorName?: true
    createdAt?: true
    postCount?: true
    lastActivity?: true
  }

  export type ForumTopicMaxAggregateInputType = {
    id?: true
    title?: true
    authorName?: true
    createdAt?: true
    postCount?: true
    lastActivity?: true
  }

  export type ForumTopicCountAggregateInputType = {
    id?: true
    title?: true
    authorName?: true
    createdAt?: true
    postCount?: true
    lastActivity?: true
    _all?: true
  }

  export type ForumTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopic to aggregate.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumTopics
    **/
    _count?: true | ForumTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumTopicMaxAggregateInputType
  }

  export type GetForumTopicAggregateType<T extends ForumTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateForumTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumTopic[P]>
      : GetScalarType<T[P], AggregateForumTopic[P]>
  }




  export type ForumTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumTopicWhereInput
    orderBy?: ForumTopicOrderByWithAggregationInput | ForumTopicOrderByWithAggregationInput[]
    by: ForumTopicScalarFieldEnum[] | ForumTopicScalarFieldEnum
    having?: ForumTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumTopicCountAggregateInputType | true
    _avg?: ForumTopicAvgAggregateInputType
    _sum?: ForumTopicSumAggregateInputType
    _min?: ForumTopicMinAggregateInputType
    _max?: ForumTopicMaxAggregateInputType
  }

  export type ForumTopicGroupByOutputType = {
    id: number
    title: string
    authorName: string
    createdAt: Date
    postCount: number | null
    lastActivity: Date
    _count: ForumTopicCountAggregateOutputType | null
    _avg: ForumTopicAvgAggregateOutputType | null
    _sum: ForumTopicSumAggregateOutputType | null
    _min: ForumTopicMinAggregateOutputType | null
    _max: ForumTopicMaxAggregateOutputType | null
  }

  type GetForumTopicGroupByPayload<T extends ForumTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ForumTopicGroupByOutputType[P]>
        }
      >
    >


  export type ForumTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authorName?: boolean
    createdAt?: boolean
    postCount?: boolean
    lastActivity?: boolean
    posts?: boolean | ForumTopic$postsArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    authorName?: boolean
    createdAt?: boolean
    postCount?: boolean
    lastActivity?: boolean
  }, ExtArgs["result"]["forumTopic"]>

  export type ForumTopicSelectScalar = {
    id?: boolean
    title?: boolean
    authorName?: boolean
    createdAt?: boolean
    postCount?: boolean
    lastActivity?: boolean
  }

  export type ForumTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | ForumTopic$postsArgs<ExtArgs>
    _count?: boolean | ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ForumTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumTopic"
    objects: {
      posts: Prisma.$ForumPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      authorName: string
      createdAt: Date
      postCount: number | null
      lastActivity: Date
    }, ExtArgs["result"]["forumTopic"]>
    composites: {}
  }

  type ForumTopicGetPayload<S extends boolean | null | undefined | ForumTopicDefaultArgs> = $Result.GetResult<Prisma.$ForumTopicPayload, S>

  type ForumTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumTopicCountAggregateInputType | true
    }

  export interface ForumTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumTopic'], meta: { name: 'ForumTopic' } }
    /**
     * Find zero or one ForumTopic that matches the filter.
     * @param {ForumTopicFindUniqueArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumTopicFindUniqueArgs>(args: SelectSubset<T, ForumTopicFindUniqueArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumTopicFindUniqueOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumTopicFindFirstArgs>(args?: SelectSubset<T, ForumTopicFindFirstArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindFirstOrThrowArgs} args - Arguments to find a ForumTopic
     * @example
     * // Get one ForumTopic
     * const forumTopic = await prisma.forumTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany()
     * 
     * // Get first 10 ForumTopics
     * const forumTopics = await prisma.forumTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumTopicFindManyArgs>(args?: SelectSubset<T, ForumTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumTopic.
     * @param {ForumTopicCreateArgs} args - Arguments to create a ForumTopic.
     * @example
     * // Create one ForumTopic
     * const ForumTopic = await prisma.forumTopic.create({
     *   data: {
     *     // ... data to create a ForumTopic
     *   }
     * })
     * 
     */
    create<T extends ForumTopicCreateArgs>(args: SelectSubset<T, ForumTopicCreateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumTopics.
     * @param {ForumTopicCreateManyArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumTopicCreateManyArgs>(args?: SelectSubset<T, ForumTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumTopics and returns the data saved in the database.
     * @param {ForumTopicCreateManyAndReturnArgs} args - Arguments to create many ForumTopics.
     * @example
     * // Create many ForumTopics
     * const forumTopic = await prisma.forumTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumTopics and only return the `id`
     * const forumTopicWithIdOnly = await prisma.forumTopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumTopic.
     * @param {ForumTopicDeleteArgs} args - Arguments to delete one ForumTopic.
     * @example
     * // Delete one ForumTopic
     * const ForumTopic = await prisma.forumTopic.delete({
     *   where: {
     *     // ... filter to delete one ForumTopic
     *   }
     * })
     * 
     */
    delete<T extends ForumTopicDeleteArgs>(args: SelectSubset<T, ForumTopicDeleteArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumTopic.
     * @param {ForumTopicUpdateArgs} args - Arguments to update one ForumTopic.
     * @example
     * // Update one ForumTopic
     * const forumTopic = await prisma.forumTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumTopicUpdateArgs>(args: SelectSubset<T, ForumTopicUpdateArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumTopics.
     * @param {ForumTopicDeleteManyArgs} args - Arguments to filter ForumTopics to delete.
     * @example
     * // Delete a few ForumTopics
     * const { count } = await prisma.forumTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumTopicDeleteManyArgs>(args?: SelectSubset<T, ForumTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumTopics
     * const forumTopic = await prisma.forumTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumTopicUpdateManyArgs>(args: SelectSubset<T, ForumTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumTopic.
     * @param {ForumTopicUpsertArgs} args - Arguments to update or create a ForumTopic.
     * @example
     * // Update or create a ForumTopic
     * const forumTopic = await prisma.forumTopic.upsert({
     *   create: {
     *     // ... data to create a ForumTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumTopic we want to update
     *   }
     * })
     */
    upsert<T extends ForumTopicUpsertArgs>(args: SelectSubset<T, ForumTopicUpsertArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicCountArgs} args - Arguments to filter ForumTopics to count.
     * @example
     * // Count the number of ForumTopics
     * const count = await prisma.forumTopic.count({
     *   where: {
     *     // ... the filter for the ForumTopics we want to count
     *   }
     * })
    **/
    count<T extends ForumTopicCountArgs>(
      args?: Subset<T, ForumTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumTopicAggregateArgs>(args: Subset<T, ForumTopicAggregateArgs>): Prisma.PrismaPromise<GetForumTopicAggregateType<T>>

    /**
     * Group by ForumTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumTopicGroupByArgs['orderBy'] }
        : { orderBy?: ForumTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumTopic model
   */
  readonly fields: ForumTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends ForumTopic$postsArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopic$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumTopic model
   */ 
  interface ForumTopicFieldRefs {
    readonly id: FieldRef<"ForumTopic", 'Int'>
    readonly title: FieldRef<"ForumTopic", 'String'>
    readonly authorName: FieldRef<"ForumTopic", 'String'>
    readonly createdAt: FieldRef<"ForumTopic", 'DateTime'>
    readonly postCount: FieldRef<"ForumTopic", 'Int'>
    readonly lastActivity: FieldRef<"ForumTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumTopic findUnique
   */
  export type ForumTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findUniqueOrThrow
   */
  export type ForumTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic findFirst
   */
  export type ForumTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findFirstOrThrow
   */
  export type ForumTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopic to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumTopics.
     */
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic findMany
   */
  export type ForumTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter, which ForumTopics to fetch.
     */
    where?: ForumTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumTopics to fetch.
     */
    orderBy?: ForumTopicOrderByWithRelationInput | ForumTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumTopics.
     */
    cursor?: ForumTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumTopics.
     */
    skip?: number
    distinct?: ForumTopicScalarFieldEnum | ForumTopicScalarFieldEnum[]
  }

  /**
   * ForumTopic create
   */
  export type ForumTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumTopic.
     */
    data: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
  }

  /**
   * ForumTopic createMany
   */
  export type ForumTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopic createManyAndReturn
   */
  export type ForumTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumTopics.
     */
    data: ForumTopicCreateManyInput | ForumTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumTopic update
   */
  export type ForumTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumTopic.
     */
    data: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
    /**
     * Choose, which ForumTopic to update.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic updateMany
   */
  export type ForumTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumTopics.
     */
    data: XOR<ForumTopicUpdateManyMutationInput, ForumTopicUncheckedUpdateManyInput>
    /**
     * Filter which ForumTopics to update
     */
    where?: ForumTopicWhereInput
  }

  /**
   * ForumTopic upsert
   */
  export type ForumTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumTopic to update in case it exists.
     */
    where: ForumTopicWhereUniqueInput
    /**
     * In case the ForumTopic found by the `where` argument doesn't exist, create a new ForumTopic with this data.
     */
    create: XOR<ForumTopicCreateInput, ForumTopicUncheckedCreateInput>
    /**
     * In case the ForumTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumTopicUpdateInput, ForumTopicUncheckedUpdateInput>
  }

  /**
   * ForumTopic delete
   */
  export type ForumTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
    /**
     * Filter which ForumTopic to delete.
     */
    where: ForumTopicWhereUniqueInput
  }

  /**
   * ForumTopic deleteMany
   */
  export type ForumTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumTopics to delete
     */
    where?: ForumTopicWhereInput
  }

  /**
   * ForumTopic.posts
   */
  export type ForumTopic$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumTopic without action
   */
  export type ForumTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumTopic
     */
    select?: ForumTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumTopicInclude<ExtArgs> | null
  }


  /**
   * Model ForumPost
   */

  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostAvgAggregateOutputType = {
    id: number | null
    topicId: number | null
  }

  export type ForumPostSumAggregateOutputType = {
    id: number | null
    topicId: number | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: number | null
    topicId: number | null
    authorName: string | null
    content: string | null
    timestamp: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: number | null
    topicId: number | null
    authorName: string | null
    content: string | null
    timestamp: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    topicId: number
    authorName: number
    content: number
    timestamp: number
    _all: number
  }


  export type ForumPostAvgAggregateInputType = {
    id?: true
    topicId?: true
  }

  export type ForumPostSumAggregateInputType = {
    id?: true
    topicId?: true
  }

  export type ForumPostMinAggregateInputType = {
    id?: true
    topicId?: true
    authorName?: true
    content?: true
    timestamp?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    topicId?: true
    authorName?: true
    content?: true
    timestamp?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    topicId?: true
    authorName?: true
    content?: true
    timestamp?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithAggregationInput | ForumPostOrderByWithAggregationInput[]
    by: ForumPostScalarFieldEnum[] | ForumPostScalarFieldEnum
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _avg?: ForumPostAvgAggregateInputType
    _sum?: ForumPostSumAggregateInputType
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }

  export type ForumPostGroupByOutputType = {
    id: number
    topicId: number
    authorName: string
    content: string
    timestamp: Date
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorName?: boolean
    content?: boolean
    timestamp?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    authorName?: boolean
    content?: boolean
    timestamp?: boolean
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    topicId?: boolean
    authorName?: boolean
    content?: boolean
    timestamp?: boolean
  }

  export type ForumPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | ForumTopicDefaultArgs<ExtArgs>
  }

  export type $ForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPost"
    objects: {
      topic: Prisma.$ForumTopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      topicId: number
      authorName: string
      content: string
      timestamp: Date
    }, ExtArgs["result"]["forumPost"]>
    composites: {}
  }

  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostDefaultArgs> = $Result.GetResult<Prisma.$ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostFindUniqueArgs>(args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostFindFirstArgs>(args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostFindManyArgs>(args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
     */
    create<T extends ForumPostCreateArgs>(args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumPosts.
     * @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostCreateManyArgs>(args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
     */
    delete<T extends ForumPostDeleteArgs>(args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostUpdateArgs>(args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostDeleteManyArgs>(args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostUpdateManyArgs>(args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostUpsertArgs>(args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPost model
   */
  readonly fields: ForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends ForumTopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumTopicDefaultArgs<ExtArgs>>): Prisma__ForumTopicClient<$Result.GetResult<Prisma.$ForumTopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPost model
   */ 
  interface ForumPostFieldRefs {
    readonly id: FieldRef<"ForumPost", 'Int'>
    readonly topicId: FieldRef<"ForumPost", 'Int'>
    readonly authorName: FieldRef<"ForumPost", 'String'>
    readonly content: FieldRef<"ForumPost", 'String'>
    readonly timestamp: FieldRef<"ForumPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPost findUnique
   */
  export type ForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findFirst
   */
  export type ForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }

  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ForumPost createManyAndReturn
   */
  export type ForumPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }

  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost without action
   */
  export type ForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    userId: number | null
    rating: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    userId: number | null
    rating: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: string | null
    userId: number | null
    category: string | null
    rating: number | null
    comment: string | null
    status: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    category: string | null
    rating: number | null
    comment: string | null
    status: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    rating: number
    comment: number
    status: number
    timeline: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    userId?: true
    rating?: true
  }

  export type ComplaintSumAggregateInputType = {
    userId?: true
    rating?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rating?: true
    comment?: true
    status?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rating?: true
    comment?: true
    status?: true
    imageUrl?: true
    createdAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    rating?: true
    comment?: true
    status?: true
    timeline?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: string
    userId: number | null
    category: string
    rating: number | null
    comment: string | null
    status: string | null
    timeline: JsonValue | null
    imageUrl: string | null
    createdAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    timeline?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    user?: boolean | Complaint$userArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    timeline?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    user?: boolean | Complaint$userArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>

  export type ComplaintSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    rating?: boolean
    comment?: boolean
    status?: boolean
    timeline?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Complaint$userArgs<ExtArgs>
  }
  export type ComplaintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Complaint$userArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number | null
      category: string
      rating: number | null
      comment: string | null
      status: string | null
      timeline: Prisma.JsonValue | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Complaints and returns the data saved in the database.
     * @param {ComplaintCreateManyAndReturnArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Complaints and only return the `id`
     * const complaintWithIdOnly = await prisma.complaint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplaintCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplaintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Complaint$userArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */ 
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'String'>
    readonly userId: FieldRef<"Complaint", 'Int'>
    readonly category: FieldRef<"Complaint", 'String'>
    readonly rating: FieldRef<"Complaint", 'Int'>
    readonly comment: FieldRef<"Complaint", 'String'>
    readonly status: FieldRef<"Complaint", 'String'>
    readonly timeline: FieldRef<"Complaint", 'Json'>
    readonly imageUrl: FieldRef<"Complaint", 'String'>
    readonly createdAt: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint createManyAndReturn
   */
  export type ComplaintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
  }

  /**
   * Complaint.user
   */
  export type Complaint$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    id: number | null
  }

  export type DriverSumAggregateOutputType = {
    id: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    avatarUrl: string | null
  }

  export type DriverMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    avatarUrl: string | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    avatarUrl: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    id?: true
  }

  export type DriverSumAggregateInputType = {
    id?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    avatarUrl?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    avatarUrl?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    avatarUrl?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    avatarUrl: string | null
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    avatarUrl?: boolean
    roster?: boolean | Driver$rosterArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    avatarUrl?: boolean
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    avatarUrl?: boolean
  }

  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | Driver$rosterArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      roster: Prisma.$BusRosterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      avatarUrl: string | null
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roster<T extends Driver$rosterArgs<ExtArgs> = {}>(args?: Subset<T, Driver$rosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */ 
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'Int'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly phone: FieldRef<"Driver", 'String'>
    readonly avatarUrl: FieldRef<"Driver", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
  }

  /**
   * Driver.roster
   */
  export type Driver$rosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    where?: BusRosterWhereInput
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    cursor?: BusRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusRosterScalarFieldEnum | BusRosterScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model BusRoute
   */

  export type AggregateBusRoute = {
    _count: BusRouteCountAggregateOutputType | null
    _min: BusRouteMinAggregateOutputType | null
    _max: BusRouteMaxAggregateOutputType | null
  }

  export type BusRouteMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type BusRouteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type BusRouteCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type BusRouteMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type BusRouteMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type BusRouteCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type BusRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRoute to aggregate.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: BusRouteOrderByWithRelationInput | BusRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusRoutes
    **/
    _count?: true | BusRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusRouteMaxAggregateInputType
  }

  export type GetBusRouteAggregateType<T extends BusRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateBusRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusRoute[P]>
      : GetScalarType<T[P], AggregateBusRoute[P]>
  }




  export type BusRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusRouteWhereInput
    orderBy?: BusRouteOrderByWithAggregationInput | BusRouteOrderByWithAggregationInput[]
    by: BusRouteScalarFieldEnum[] | BusRouteScalarFieldEnum
    having?: BusRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusRouteCountAggregateInputType | true
    _min?: BusRouteMinAggregateInputType
    _max?: BusRouteMaxAggregateInputType
  }

  export type BusRouteGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: BusRouteCountAggregateOutputType | null
    _min: BusRouteMinAggregateOutputType | null
    _max: BusRouteMaxAggregateOutputType | null
  }

  type GetBusRouteGroupByPayload<T extends BusRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusRouteGroupByOutputType[P]>
            : GetScalarType<T[P], BusRouteGroupByOutputType[P]>
        }
      >
    >


  export type BusRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    roster?: boolean | BusRoute$rosterArgs<ExtArgs>
    pickupPoints?: boolean | BusRoute$pickupPointsArgs<ExtArgs>
    _count?: boolean | BusRouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["busRoute"]>

  export type BusRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["busRoute"]>

  export type BusRouteSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type BusRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roster?: boolean | BusRoute$rosterArgs<ExtArgs>
    pickupPoints?: boolean | BusRoute$pickupPointsArgs<ExtArgs>
    _count?: boolean | BusRouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusRoute"
    objects: {
      roster: Prisma.$BusRosterPayload<ExtArgs>[]
      pickupPoints: Prisma.$PickupPointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["busRoute"]>
    composites: {}
  }

  type BusRouteGetPayload<S extends boolean | null | undefined | BusRouteDefaultArgs> = $Result.GetResult<Prisma.$BusRoutePayload, S>

  type BusRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusRouteCountAggregateInputType | true
    }

  export interface BusRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusRoute'], meta: { name: 'BusRoute' } }
    /**
     * Find zero or one BusRoute that matches the filter.
     * @param {BusRouteFindUniqueArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusRouteFindUniqueArgs>(args: SelectSubset<T, BusRouteFindUniqueArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusRouteFindUniqueOrThrowArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, BusRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindFirstArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusRouteFindFirstArgs>(args?: SelectSubset<T, BusRouteFindFirstArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindFirstOrThrowArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, BusRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusRoutes
     * const busRoutes = await prisma.busRoute.findMany()
     * 
     * // Get first 10 BusRoutes
     * const busRoutes = await prisma.busRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const busRouteWithIdOnly = await prisma.busRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusRouteFindManyArgs>(args?: SelectSubset<T, BusRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusRoute.
     * @param {BusRouteCreateArgs} args - Arguments to create a BusRoute.
     * @example
     * // Create one BusRoute
     * const BusRoute = await prisma.busRoute.create({
     *   data: {
     *     // ... data to create a BusRoute
     *   }
     * })
     * 
     */
    create<T extends BusRouteCreateArgs>(args: SelectSubset<T, BusRouteCreateArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusRoutes.
     * @param {BusRouteCreateManyArgs} args - Arguments to create many BusRoutes.
     * @example
     * // Create many BusRoutes
     * const busRoute = await prisma.busRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusRouteCreateManyArgs>(args?: SelectSubset<T, BusRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusRoutes and returns the data saved in the database.
     * @param {BusRouteCreateManyAndReturnArgs} args - Arguments to create many BusRoutes.
     * @example
     * // Create many BusRoutes
     * const busRoute = await prisma.busRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusRoutes and only return the `id`
     * const busRouteWithIdOnly = await prisma.busRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, BusRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusRoute.
     * @param {BusRouteDeleteArgs} args - Arguments to delete one BusRoute.
     * @example
     * // Delete one BusRoute
     * const BusRoute = await prisma.busRoute.delete({
     *   where: {
     *     // ... filter to delete one BusRoute
     *   }
     * })
     * 
     */
    delete<T extends BusRouteDeleteArgs>(args: SelectSubset<T, BusRouteDeleteArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusRoute.
     * @param {BusRouteUpdateArgs} args - Arguments to update one BusRoute.
     * @example
     * // Update one BusRoute
     * const busRoute = await prisma.busRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusRouteUpdateArgs>(args: SelectSubset<T, BusRouteUpdateArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusRoutes.
     * @param {BusRouteDeleteManyArgs} args - Arguments to filter BusRoutes to delete.
     * @example
     * // Delete a few BusRoutes
     * const { count } = await prisma.busRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusRouteDeleteManyArgs>(args?: SelectSubset<T, BusRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusRoutes
     * const busRoute = await prisma.busRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusRouteUpdateManyArgs>(args: SelectSubset<T, BusRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusRoute.
     * @param {BusRouteUpsertArgs} args - Arguments to update or create a BusRoute.
     * @example
     * // Update or create a BusRoute
     * const busRoute = await prisma.busRoute.upsert({
     *   create: {
     *     // ... data to create a BusRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusRoute we want to update
     *   }
     * })
     */
    upsert<T extends BusRouteUpsertArgs>(args: SelectSubset<T, BusRouteUpsertArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteCountArgs} args - Arguments to filter BusRoutes to count.
     * @example
     * // Count the number of BusRoutes
     * const count = await prisma.busRoute.count({
     *   where: {
     *     // ... the filter for the BusRoutes we want to count
     *   }
     * })
    **/
    count<T extends BusRouteCountArgs>(
      args?: Subset<T, BusRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusRouteAggregateArgs>(args: Subset<T, BusRouteAggregateArgs>): Prisma.PrismaPromise<GetBusRouteAggregateType<T>>

    /**
     * Group by BusRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusRouteGroupByArgs['orderBy'] }
        : { orderBy?: BusRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusRoute model
   */
  readonly fields: BusRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roster<T extends BusRoute$rosterArgs<ExtArgs> = {}>(args?: Subset<T, BusRoute$rosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findMany"> | Null>
    pickupPoints<T extends BusRoute$pickupPointsArgs<ExtArgs> = {}>(args?: Subset<T, BusRoute$pickupPointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusRoute model
   */ 
  interface BusRouteFieldRefs {
    readonly id: FieldRef<"BusRoute", 'String'>
    readonly name: FieldRef<"BusRoute", 'String'>
    readonly description: FieldRef<"BusRoute", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusRoute findUnique
   */
  export type BusRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where: BusRouteWhereUniqueInput
  }

  /**
   * BusRoute findUniqueOrThrow
   */
  export type BusRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where: BusRouteWhereUniqueInput
  }

  /**
   * BusRoute findFirst
   */
  export type BusRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: BusRouteOrderByWithRelationInput | BusRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRoutes.
     */
    distinct?: BusRouteScalarFieldEnum | BusRouteScalarFieldEnum[]
  }

  /**
   * BusRoute findFirstOrThrow
   */
  export type BusRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: BusRouteOrderByWithRelationInput | BusRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRoutes.
     */
    distinct?: BusRouteScalarFieldEnum | BusRouteScalarFieldEnum[]
  }

  /**
   * BusRoute findMany
   */
  export type BusRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter, which BusRoutes to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: BusRouteOrderByWithRelationInput | BusRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    distinct?: BusRouteScalarFieldEnum | BusRouteScalarFieldEnum[]
  }

  /**
   * BusRoute create
   */
  export type BusRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a BusRoute.
     */
    data: XOR<BusRouteCreateInput, BusRouteUncheckedCreateInput>
  }

  /**
   * BusRoute createMany
   */
  export type BusRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusRoutes.
     */
    data: BusRouteCreateManyInput | BusRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusRoute createManyAndReturn
   */
  export type BusRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusRoutes.
     */
    data: BusRouteCreateManyInput | BusRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusRoute update
   */
  export type BusRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a BusRoute.
     */
    data: XOR<BusRouteUpdateInput, BusRouteUncheckedUpdateInput>
    /**
     * Choose, which BusRoute to update.
     */
    where: BusRouteWhereUniqueInput
  }

  /**
   * BusRoute updateMany
   */
  export type BusRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusRoutes.
     */
    data: XOR<BusRouteUpdateManyMutationInput, BusRouteUncheckedUpdateManyInput>
    /**
     * Filter which BusRoutes to update
     */
    where?: BusRouteWhereInput
  }

  /**
   * BusRoute upsert
   */
  export type BusRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the BusRoute to update in case it exists.
     */
    where: BusRouteWhereUniqueInput
    /**
     * In case the BusRoute found by the `where` argument doesn't exist, create a new BusRoute with this data.
     */
    create: XOR<BusRouteCreateInput, BusRouteUncheckedCreateInput>
    /**
     * In case the BusRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusRouteUpdateInput, BusRouteUncheckedUpdateInput>
  }

  /**
   * BusRoute delete
   */
  export type BusRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    /**
     * Filter which BusRoute to delete.
     */
    where: BusRouteWhereUniqueInput
  }

  /**
   * BusRoute deleteMany
   */
  export type BusRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRoutes to delete
     */
    where?: BusRouteWhereInput
  }

  /**
   * BusRoute.roster
   */
  export type BusRoute$rosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    where?: BusRosterWhereInput
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    cursor?: BusRosterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusRosterScalarFieldEnum | BusRosterScalarFieldEnum[]
  }

  /**
   * BusRoute.pickupPoints
   */
  export type BusRoute$pickupPointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    where?: PickupPointWhereInput
    orderBy?: PickupPointOrderByWithRelationInput | PickupPointOrderByWithRelationInput[]
    cursor?: PickupPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PickupPointScalarFieldEnum | PickupPointScalarFieldEnum[]
  }

  /**
   * BusRoute without action
   */
  export type BusRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
  }


  /**
   * Model BusRoster
   */

  export type AggregateBusRoster = {
    _count: BusRosterCountAggregateOutputType | null
    _avg: BusRosterAvgAggregateOutputType | null
    _sum: BusRosterSumAggregateOutputType | null
    _min: BusRosterMinAggregateOutputType | null
    _max: BusRosterMaxAggregateOutputType | null
  }

  export type BusRosterAvgAggregateOutputType = {
    id: number | null
    driverId: number | null
  }

  export type BusRosterSumAggregateOutputType = {
    id: number | null
    driverId: number | null
  }

  export type BusRosterMinAggregateOutputType = {
    id: number | null
    routeId: string | null
    driverId: number | null
    date: Date | null
  }

  export type BusRosterMaxAggregateOutputType = {
    id: number | null
    routeId: string | null
    driverId: number | null
    date: Date | null
  }

  export type BusRosterCountAggregateOutputType = {
    id: number
    routeId: number
    driverId: number
    date: number
    _all: number
  }


  export type BusRosterAvgAggregateInputType = {
    id?: true
    driverId?: true
  }

  export type BusRosterSumAggregateInputType = {
    id?: true
    driverId?: true
  }

  export type BusRosterMinAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
  }

  export type BusRosterMaxAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
  }

  export type BusRosterCountAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
    _all?: true
  }

  export type BusRosterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRoster to aggregate.
     */
    where?: BusRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRosters to fetch.
     */
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusRosters
    **/
    _count?: true | BusRosterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusRosterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusRosterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusRosterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusRosterMaxAggregateInputType
  }

  export type GetBusRosterAggregateType<T extends BusRosterAggregateArgs> = {
        [P in keyof T & keyof AggregateBusRoster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusRoster[P]>
      : GetScalarType<T[P], AggregateBusRoster[P]>
  }




  export type BusRosterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusRosterWhereInput
    orderBy?: BusRosterOrderByWithAggregationInput | BusRosterOrderByWithAggregationInput[]
    by: BusRosterScalarFieldEnum[] | BusRosterScalarFieldEnum
    having?: BusRosterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusRosterCountAggregateInputType | true
    _avg?: BusRosterAvgAggregateInputType
    _sum?: BusRosterSumAggregateInputType
    _min?: BusRosterMinAggregateInputType
    _max?: BusRosterMaxAggregateInputType
  }

  export type BusRosterGroupByOutputType = {
    id: number
    routeId: string | null
    driverId: number | null
    date: Date
    _count: BusRosterCountAggregateOutputType | null
    _avg: BusRosterAvgAggregateOutputType | null
    _sum: BusRosterSumAggregateOutputType | null
    _min: BusRosterMinAggregateOutputType | null
    _max: BusRosterMaxAggregateOutputType | null
  }

  type GetBusRosterGroupByPayload<T extends BusRosterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusRosterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusRosterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusRosterGroupByOutputType[P]>
            : GetScalarType<T[P], BusRosterGroupByOutputType[P]>
        }
      >
    >


  export type BusRosterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    route?: boolean | BusRoster$routeArgs<ExtArgs>
    driver?: boolean | BusRoster$driverArgs<ExtArgs>
  }, ExtArgs["result"]["busRoster"]>

  export type BusRosterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    route?: boolean | BusRoster$routeArgs<ExtArgs>
    driver?: boolean | BusRoster$driverArgs<ExtArgs>
  }, ExtArgs["result"]["busRoster"]>

  export type BusRosterSelectScalar = {
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
  }

  export type BusRosterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | BusRoster$routeArgs<ExtArgs>
    driver?: boolean | BusRoster$driverArgs<ExtArgs>
  }
  export type BusRosterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | BusRoster$routeArgs<ExtArgs>
    driver?: boolean | BusRoster$driverArgs<ExtArgs>
  }

  export type $BusRosterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusRoster"
    objects: {
      route: Prisma.$BusRoutePayload<ExtArgs> | null
      driver: Prisma.$DriverPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      routeId: string | null
      driverId: number | null
      date: Date
    }, ExtArgs["result"]["busRoster"]>
    composites: {}
  }

  type BusRosterGetPayload<S extends boolean | null | undefined | BusRosterDefaultArgs> = $Result.GetResult<Prisma.$BusRosterPayload, S>

  type BusRosterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusRosterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusRosterCountAggregateInputType | true
    }

  export interface BusRosterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusRoster'], meta: { name: 'BusRoster' } }
    /**
     * Find zero or one BusRoster that matches the filter.
     * @param {BusRosterFindUniqueArgs} args - Arguments to find a BusRoster
     * @example
     * // Get one BusRoster
     * const busRoster = await prisma.busRoster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusRosterFindUniqueArgs>(args: SelectSubset<T, BusRosterFindUniqueArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusRoster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusRosterFindUniqueOrThrowArgs} args - Arguments to find a BusRoster
     * @example
     * // Get one BusRoster
     * const busRoster = await prisma.busRoster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusRosterFindUniqueOrThrowArgs>(args: SelectSubset<T, BusRosterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusRoster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterFindFirstArgs} args - Arguments to find a BusRoster
     * @example
     * // Get one BusRoster
     * const busRoster = await prisma.busRoster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusRosterFindFirstArgs>(args?: SelectSubset<T, BusRosterFindFirstArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusRoster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterFindFirstOrThrowArgs} args - Arguments to find a BusRoster
     * @example
     * // Get one BusRoster
     * const busRoster = await prisma.busRoster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusRosterFindFirstOrThrowArgs>(args?: SelectSubset<T, BusRosterFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusRosters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusRosters
     * const busRosters = await prisma.busRoster.findMany()
     * 
     * // Get first 10 BusRosters
     * const busRosters = await prisma.busRoster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const busRosterWithIdOnly = await prisma.busRoster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusRosterFindManyArgs>(args?: SelectSubset<T, BusRosterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusRoster.
     * @param {BusRosterCreateArgs} args - Arguments to create a BusRoster.
     * @example
     * // Create one BusRoster
     * const BusRoster = await prisma.busRoster.create({
     *   data: {
     *     // ... data to create a BusRoster
     *   }
     * })
     * 
     */
    create<T extends BusRosterCreateArgs>(args: SelectSubset<T, BusRosterCreateArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusRosters.
     * @param {BusRosterCreateManyArgs} args - Arguments to create many BusRosters.
     * @example
     * // Create many BusRosters
     * const busRoster = await prisma.busRoster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusRosterCreateManyArgs>(args?: SelectSubset<T, BusRosterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusRosters and returns the data saved in the database.
     * @param {BusRosterCreateManyAndReturnArgs} args - Arguments to create many BusRosters.
     * @example
     * // Create many BusRosters
     * const busRoster = await prisma.busRoster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusRosters and only return the `id`
     * const busRosterWithIdOnly = await prisma.busRoster.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusRosterCreateManyAndReturnArgs>(args?: SelectSubset<T, BusRosterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusRoster.
     * @param {BusRosterDeleteArgs} args - Arguments to delete one BusRoster.
     * @example
     * // Delete one BusRoster
     * const BusRoster = await prisma.busRoster.delete({
     *   where: {
     *     // ... filter to delete one BusRoster
     *   }
     * })
     * 
     */
    delete<T extends BusRosterDeleteArgs>(args: SelectSubset<T, BusRosterDeleteArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusRoster.
     * @param {BusRosterUpdateArgs} args - Arguments to update one BusRoster.
     * @example
     * // Update one BusRoster
     * const busRoster = await prisma.busRoster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusRosterUpdateArgs>(args: SelectSubset<T, BusRosterUpdateArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusRosters.
     * @param {BusRosterDeleteManyArgs} args - Arguments to filter BusRosters to delete.
     * @example
     * // Delete a few BusRosters
     * const { count } = await prisma.busRoster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusRosterDeleteManyArgs>(args?: SelectSubset<T, BusRosterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusRosters
     * const busRoster = await prisma.busRoster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusRosterUpdateManyArgs>(args: SelectSubset<T, BusRosterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusRoster.
     * @param {BusRosterUpsertArgs} args - Arguments to update or create a BusRoster.
     * @example
     * // Update or create a BusRoster
     * const busRoster = await prisma.busRoster.upsert({
     *   create: {
     *     // ... data to create a BusRoster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusRoster we want to update
     *   }
     * })
     */
    upsert<T extends BusRosterUpsertArgs>(args: SelectSubset<T, BusRosterUpsertArgs<ExtArgs>>): Prisma__BusRosterClient<$Result.GetResult<Prisma.$BusRosterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusRosters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterCountArgs} args - Arguments to filter BusRosters to count.
     * @example
     * // Count the number of BusRosters
     * const count = await prisma.busRoster.count({
     *   where: {
     *     // ... the filter for the BusRosters we want to count
     *   }
     * })
    **/
    count<T extends BusRosterCountArgs>(
      args?: Subset<T, BusRosterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusRosterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusRosterAggregateArgs>(args: Subset<T, BusRosterAggregateArgs>): Prisma.PrismaPromise<GetBusRosterAggregateType<T>>

    /**
     * Group by BusRoster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRosterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusRosterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusRosterGroupByArgs['orderBy'] }
        : { orderBy?: BusRosterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusRosterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusRosterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusRoster model
   */
  readonly fields: BusRosterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusRoster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusRosterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends BusRoster$routeArgs<ExtArgs> = {}>(args?: Subset<T, BusRoster$routeArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends BusRoster$driverArgs<ExtArgs> = {}>(args?: Subset<T, BusRoster$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusRoster model
   */ 
  interface BusRosterFieldRefs {
    readonly id: FieldRef<"BusRoster", 'Int'>
    readonly routeId: FieldRef<"BusRoster", 'String'>
    readonly driverId: FieldRef<"BusRoster", 'Int'>
    readonly date: FieldRef<"BusRoster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusRoster findUnique
   */
  export type BusRosterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter, which BusRoster to fetch.
     */
    where: BusRosterWhereUniqueInput
  }

  /**
   * BusRoster findUniqueOrThrow
   */
  export type BusRosterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter, which BusRoster to fetch.
     */
    where: BusRosterWhereUniqueInput
  }

  /**
   * BusRoster findFirst
   */
  export type BusRosterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter, which BusRoster to fetch.
     */
    where?: BusRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRosters to fetch.
     */
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRosters.
     */
    cursor?: BusRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRosters.
     */
    distinct?: BusRosterScalarFieldEnum | BusRosterScalarFieldEnum[]
  }

  /**
   * BusRoster findFirstOrThrow
   */
  export type BusRosterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter, which BusRoster to fetch.
     */
    where?: BusRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRosters to fetch.
     */
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRosters.
     */
    cursor?: BusRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRosters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRosters.
     */
    distinct?: BusRosterScalarFieldEnum | BusRosterScalarFieldEnum[]
  }

  /**
   * BusRoster findMany
   */
  export type BusRosterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter, which BusRosters to fetch.
     */
    where?: BusRosterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRosters to fetch.
     */
    orderBy?: BusRosterOrderByWithRelationInput | BusRosterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusRosters.
     */
    cursor?: BusRosterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRosters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRosters.
     */
    skip?: number
    distinct?: BusRosterScalarFieldEnum | BusRosterScalarFieldEnum[]
  }

  /**
   * BusRoster create
   */
  export type BusRosterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * The data needed to create a BusRoster.
     */
    data: XOR<BusRosterCreateInput, BusRosterUncheckedCreateInput>
  }

  /**
   * BusRoster createMany
   */
  export type BusRosterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusRosters.
     */
    data: BusRosterCreateManyInput | BusRosterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusRoster createManyAndReturn
   */
  export type BusRosterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusRosters.
     */
    data: BusRosterCreateManyInput | BusRosterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusRoster update
   */
  export type BusRosterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * The data needed to update a BusRoster.
     */
    data: XOR<BusRosterUpdateInput, BusRosterUncheckedUpdateInput>
    /**
     * Choose, which BusRoster to update.
     */
    where: BusRosterWhereUniqueInput
  }

  /**
   * BusRoster updateMany
   */
  export type BusRosterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusRosters.
     */
    data: XOR<BusRosterUpdateManyMutationInput, BusRosterUncheckedUpdateManyInput>
    /**
     * Filter which BusRosters to update
     */
    where?: BusRosterWhereInput
  }

  /**
   * BusRoster upsert
   */
  export type BusRosterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * The filter to search for the BusRoster to update in case it exists.
     */
    where: BusRosterWhereUniqueInput
    /**
     * In case the BusRoster found by the `where` argument doesn't exist, create a new BusRoster with this data.
     */
    create: XOR<BusRosterCreateInput, BusRosterUncheckedCreateInput>
    /**
     * In case the BusRoster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusRosterUpdateInput, BusRosterUncheckedUpdateInput>
  }

  /**
   * BusRoster delete
   */
  export type BusRosterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
    /**
     * Filter which BusRoster to delete.
     */
    where: BusRosterWhereUniqueInput
  }

  /**
   * BusRoster deleteMany
   */
  export type BusRosterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRosters to delete
     */
    where?: BusRosterWhereInput
  }

  /**
   * BusRoster.route
   */
  export type BusRoster$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    where?: BusRouteWhereInput
  }

  /**
   * BusRoster.driver
   */
  export type BusRoster$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * BusRoster without action
   */
  export type BusRosterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoster
     */
    select?: BusRosterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRosterInclude<ExtArgs> | null
  }


  /**
   * Model PickupPoint
   */

  export type AggregatePickupPoint = {
    _count: PickupPointCountAggregateOutputType | null
    _avg: PickupPointAvgAggregateOutputType | null
    _sum: PickupPointSumAggregateOutputType | null
    _min: PickupPointMinAggregateOutputType | null
    _max: PickupPointMaxAggregateOutputType | null
  }

  export type PickupPointAvgAggregateOutputType = {
    id: number | null
    lat: number | null
    lng: number | null
  }

  export type PickupPointSumAggregateOutputType = {
    id: number | null
    lat: number | null
    lng: number | null
  }

  export type PickupPointMinAggregateOutputType = {
    id: number | null
    name: string | null
    routeId: string | null
    lat: number | null
    lng: number | null
    uiPositionTop: string | null
    uiPositionLeft: string | null
    isUserStop: boolean | null
  }

  export type PickupPointMaxAggregateOutputType = {
    id: number | null
    name: string | null
    routeId: string | null
    lat: number | null
    lng: number | null
    uiPositionTop: string | null
    uiPositionLeft: string | null
    isUserStop: boolean | null
  }

  export type PickupPointCountAggregateOutputType = {
    id: number
    name: number
    routeId: number
    lat: number
    lng: number
    uiPositionTop: number
    uiPositionLeft: number
    isUserStop: number
    _all: number
  }


  export type PickupPointAvgAggregateInputType = {
    id?: true
    lat?: true
    lng?: true
  }

  export type PickupPointSumAggregateInputType = {
    id?: true
    lat?: true
    lng?: true
  }

  export type PickupPointMinAggregateInputType = {
    id?: true
    name?: true
    routeId?: true
    lat?: true
    lng?: true
    uiPositionTop?: true
    uiPositionLeft?: true
    isUserStop?: true
  }

  export type PickupPointMaxAggregateInputType = {
    id?: true
    name?: true
    routeId?: true
    lat?: true
    lng?: true
    uiPositionTop?: true
    uiPositionLeft?: true
    isUserStop?: true
  }

  export type PickupPointCountAggregateInputType = {
    id?: true
    name?: true
    routeId?: true
    lat?: true
    lng?: true
    uiPositionTop?: true
    uiPositionLeft?: true
    isUserStop?: true
    _all?: true
  }

  export type PickupPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupPoint to aggregate.
     */
    where?: PickupPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupPoints to fetch.
     */
    orderBy?: PickupPointOrderByWithRelationInput | PickupPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PickupPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PickupPoints
    **/
    _count?: true | PickupPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PickupPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PickupPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PickupPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PickupPointMaxAggregateInputType
  }

  export type GetPickupPointAggregateType<T extends PickupPointAggregateArgs> = {
        [P in keyof T & keyof AggregatePickupPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePickupPoint[P]>
      : GetScalarType<T[P], AggregatePickupPoint[P]>
  }




  export type PickupPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PickupPointWhereInput
    orderBy?: PickupPointOrderByWithAggregationInput | PickupPointOrderByWithAggregationInput[]
    by: PickupPointScalarFieldEnum[] | PickupPointScalarFieldEnum
    having?: PickupPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PickupPointCountAggregateInputType | true
    _avg?: PickupPointAvgAggregateInputType
    _sum?: PickupPointSumAggregateInputType
    _min?: PickupPointMinAggregateInputType
    _max?: PickupPointMaxAggregateInputType
  }

  export type PickupPointGroupByOutputType = {
    id: number
    name: string
    routeId: string | null
    lat: number | null
    lng: number | null
    uiPositionTop: string | null
    uiPositionLeft: string | null
    isUserStop: boolean | null
    _count: PickupPointCountAggregateOutputType | null
    _avg: PickupPointAvgAggregateOutputType | null
    _sum: PickupPointSumAggregateOutputType | null
    _min: PickupPointMinAggregateOutputType | null
    _max: PickupPointMaxAggregateOutputType | null
  }

  type GetPickupPointGroupByPayload<T extends PickupPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PickupPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PickupPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PickupPointGroupByOutputType[P]>
            : GetScalarType<T[P], PickupPointGroupByOutputType[P]>
        }
      >
    >


  export type PickupPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    routeId?: boolean
    lat?: boolean
    lng?: boolean
    uiPositionTop?: boolean
    uiPositionLeft?: boolean
    isUserStop?: boolean
    route?: boolean | PickupPoint$routeArgs<ExtArgs>
  }, ExtArgs["result"]["pickupPoint"]>

  export type PickupPointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    routeId?: boolean
    lat?: boolean
    lng?: boolean
    uiPositionTop?: boolean
    uiPositionLeft?: boolean
    isUserStop?: boolean
    route?: boolean | PickupPoint$routeArgs<ExtArgs>
  }, ExtArgs["result"]["pickupPoint"]>

  export type PickupPointSelectScalar = {
    id?: boolean
    name?: boolean
    routeId?: boolean
    lat?: boolean
    lng?: boolean
    uiPositionTop?: boolean
    uiPositionLeft?: boolean
    isUserStop?: boolean
  }

  export type PickupPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | PickupPoint$routeArgs<ExtArgs>
  }
  export type PickupPointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | PickupPoint$routeArgs<ExtArgs>
  }

  export type $PickupPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PickupPoint"
    objects: {
      route: Prisma.$BusRoutePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      routeId: string | null
      lat: number | null
      lng: number | null
      uiPositionTop: string | null
      uiPositionLeft: string | null
      isUserStop: boolean | null
    }, ExtArgs["result"]["pickupPoint"]>
    composites: {}
  }

  type PickupPointGetPayload<S extends boolean | null | undefined | PickupPointDefaultArgs> = $Result.GetResult<Prisma.$PickupPointPayload, S>

  type PickupPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PickupPointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PickupPointCountAggregateInputType | true
    }

  export interface PickupPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PickupPoint'], meta: { name: 'PickupPoint' } }
    /**
     * Find zero or one PickupPoint that matches the filter.
     * @param {PickupPointFindUniqueArgs} args - Arguments to find a PickupPoint
     * @example
     * // Get one PickupPoint
     * const pickupPoint = await prisma.pickupPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PickupPointFindUniqueArgs>(args: SelectSubset<T, PickupPointFindUniqueArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PickupPoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PickupPointFindUniqueOrThrowArgs} args - Arguments to find a PickupPoint
     * @example
     * // Get one PickupPoint
     * const pickupPoint = await prisma.pickupPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PickupPointFindUniqueOrThrowArgs>(args: SelectSubset<T, PickupPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PickupPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointFindFirstArgs} args - Arguments to find a PickupPoint
     * @example
     * // Get one PickupPoint
     * const pickupPoint = await prisma.pickupPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PickupPointFindFirstArgs>(args?: SelectSubset<T, PickupPointFindFirstArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PickupPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointFindFirstOrThrowArgs} args - Arguments to find a PickupPoint
     * @example
     * // Get one PickupPoint
     * const pickupPoint = await prisma.pickupPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PickupPointFindFirstOrThrowArgs>(args?: SelectSubset<T, PickupPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PickupPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PickupPoints
     * const pickupPoints = await prisma.pickupPoint.findMany()
     * 
     * // Get first 10 PickupPoints
     * const pickupPoints = await prisma.pickupPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pickupPointWithIdOnly = await prisma.pickupPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PickupPointFindManyArgs>(args?: SelectSubset<T, PickupPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PickupPoint.
     * @param {PickupPointCreateArgs} args - Arguments to create a PickupPoint.
     * @example
     * // Create one PickupPoint
     * const PickupPoint = await prisma.pickupPoint.create({
     *   data: {
     *     // ... data to create a PickupPoint
     *   }
     * })
     * 
     */
    create<T extends PickupPointCreateArgs>(args: SelectSubset<T, PickupPointCreateArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PickupPoints.
     * @param {PickupPointCreateManyArgs} args - Arguments to create many PickupPoints.
     * @example
     * // Create many PickupPoints
     * const pickupPoint = await prisma.pickupPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PickupPointCreateManyArgs>(args?: SelectSubset<T, PickupPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PickupPoints and returns the data saved in the database.
     * @param {PickupPointCreateManyAndReturnArgs} args - Arguments to create many PickupPoints.
     * @example
     * // Create many PickupPoints
     * const pickupPoint = await prisma.pickupPoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PickupPoints and only return the `id`
     * const pickupPointWithIdOnly = await prisma.pickupPoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PickupPointCreateManyAndReturnArgs>(args?: SelectSubset<T, PickupPointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PickupPoint.
     * @param {PickupPointDeleteArgs} args - Arguments to delete one PickupPoint.
     * @example
     * // Delete one PickupPoint
     * const PickupPoint = await prisma.pickupPoint.delete({
     *   where: {
     *     // ... filter to delete one PickupPoint
     *   }
     * })
     * 
     */
    delete<T extends PickupPointDeleteArgs>(args: SelectSubset<T, PickupPointDeleteArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PickupPoint.
     * @param {PickupPointUpdateArgs} args - Arguments to update one PickupPoint.
     * @example
     * // Update one PickupPoint
     * const pickupPoint = await prisma.pickupPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PickupPointUpdateArgs>(args: SelectSubset<T, PickupPointUpdateArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PickupPoints.
     * @param {PickupPointDeleteManyArgs} args - Arguments to filter PickupPoints to delete.
     * @example
     * // Delete a few PickupPoints
     * const { count } = await prisma.pickupPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PickupPointDeleteManyArgs>(args?: SelectSubset<T, PickupPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PickupPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PickupPoints
     * const pickupPoint = await prisma.pickupPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PickupPointUpdateManyArgs>(args: SelectSubset<T, PickupPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PickupPoint.
     * @param {PickupPointUpsertArgs} args - Arguments to update or create a PickupPoint.
     * @example
     * // Update or create a PickupPoint
     * const pickupPoint = await prisma.pickupPoint.upsert({
     *   create: {
     *     // ... data to create a PickupPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PickupPoint we want to update
     *   }
     * })
     */
    upsert<T extends PickupPointUpsertArgs>(args: SelectSubset<T, PickupPointUpsertArgs<ExtArgs>>): Prisma__PickupPointClient<$Result.GetResult<Prisma.$PickupPointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PickupPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointCountArgs} args - Arguments to filter PickupPoints to count.
     * @example
     * // Count the number of PickupPoints
     * const count = await prisma.pickupPoint.count({
     *   where: {
     *     // ... the filter for the PickupPoints we want to count
     *   }
     * })
    **/
    count<T extends PickupPointCountArgs>(
      args?: Subset<T, PickupPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PickupPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PickupPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PickupPointAggregateArgs>(args: Subset<T, PickupPointAggregateArgs>): Prisma.PrismaPromise<GetPickupPointAggregateType<T>>

    /**
     * Group by PickupPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PickupPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PickupPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PickupPointGroupByArgs['orderBy'] }
        : { orderBy?: PickupPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PickupPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPickupPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PickupPoint model
   */
  readonly fields: PickupPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PickupPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PickupPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends PickupPoint$routeArgs<ExtArgs> = {}>(args?: Subset<T, PickupPoint$routeArgs<ExtArgs>>): Prisma__BusRouteClient<$Result.GetResult<Prisma.$BusRoutePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PickupPoint model
   */ 
  interface PickupPointFieldRefs {
    readonly id: FieldRef<"PickupPoint", 'Int'>
    readonly name: FieldRef<"PickupPoint", 'String'>
    readonly routeId: FieldRef<"PickupPoint", 'String'>
    readonly lat: FieldRef<"PickupPoint", 'Float'>
    readonly lng: FieldRef<"PickupPoint", 'Float'>
    readonly uiPositionTop: FieldRef<"PickupPoint", 'String'>
    readonly uiPositionLeft: FieldRef<"PickupPoint", 'String'>
    readonly isUserStop: FieldRef<"PickupPoint", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PickupPoint findUnique
   */
  export type PickupPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter, which PickupPoint to fetch.
     */
    where: PickupPointWhereUniqueInput
  }

  /**
   * PickupPoint findUniqueOrThrow
   */
  export type PickupPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter, which PickupPoint to fetch.
     */
    where: PickupPointWhereUniqueInput
  }

  /**
   * PickupPoint findFirst
   */
  export type PickupPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter, which PickupPoint to fetch.
     */
    where?: PickupPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupPoints to fetch.
     */
    orderBy?: PickupPointOrderByWithRelationInput | PickupPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupPoints.
     */
    cursor?: PickupPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupPoints.
     */
    distinct?: PickupPointScalarFieldEnum | PickupPointScalarFieldEnum[]
  }

  /**
   * PickupPoint findFirstOrThrow
   */
  export type PickupPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter, which PickupPoint to fetch.
     */
    where?: PickupPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupPoints to fetch.
     */
    orderBy?: PickupPointOrderByWithRelationInput | PickupPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PickupPoints.
     */
    cursor?: PickupPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PickupPoints.
     */
    distinct?: PickupPointScalarFieldEnum | PickupPointScalarFieldEnum[]
  }

  /**
   * PickupPoint findMany
   */
  export type PickupPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter, which PickupPoints to fetch.
     */
    where?: PickupPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PickupPoints to fetch.
     */
    orderBy?: PickupPointOrderByWithRelationInput | PickupPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PickupPoints.
     */
    cursor?: PickupPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PickupPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PickupPoints.
     */
    skip?: number
    distinct?: PickupPointScalarFieldEnum | PickupPointScalarFieldEnum[]
  }

  /**
   * PickupPoint create
   */
  export type PickupPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * The data needed to create a PickupPoint.
     */
    data: XOR<PickupPointCreateInput, PickupPointUncheckedCreateInput>
  }

  /**
   * PickupPoint createMany
   */
  export type PickupPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PickupPoints.
     */
    data: PickupPointCreateManyInput | PickupPointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PickupPoint createManyAndReturn
   */
  export type PickupPointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PickupPoints.
     */
    data: PickupPointCreateManyInput | PickupPointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PickupPoint update
   */
  export type PickupPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * The data needed to update a PickupPoint.
     */
    data: XOR<PickupPointUpdateInput, PickupPointUncheckedUpdateInput>
    /**
     * Choose, which PickupPoint to update.
     */
    where: PickupPointWhereUniqueInput
  }

  /**
   * PickupPoint updateMany
   */
  export type PickupPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PickupPoints.
     */
    data: XOR<PickupPointUpdateManyMutationInput, PickupPointUncheckedUpdateManyInput>
    /**
     * Filter which PickupPoints to update
     */
    where?: PickupPointWhereInput
  }

  /**
   * PickupPoint upsert
   */
  export type PickupPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * The filter to search for the PickupPoint to update in case it exists.
     */
    where: PickupPointWhereUniqueInput
    /**
     * In case the PickupPoint found by the `where` argument doesn't exist, create a new PickupPoint with this data.
     */
    create: XOR<PickupPointCreateInput, PickupPointUncheckedCreateInput>
    /**
     * In case the PickupPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PickupPointUpdateInput, PickupPointUncheckedUpdateInput>
  }

  /**
   * PickupPoint delete
   */
  export type PickupPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
    /**
     * Filter which PickupPoint to delete.
     */
    where: PickupPointWhereUniqueInput
  }

  /**
   * PickupPoint deleteMany
   */
  export type PickupPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PickupPoints to delete
     */
    where?: PickupPointWhereInput
  }

  /**
   * PickupPoint.route
   */
  export type PickupPoint$routeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusRouteInclude<ExtArgs> | null
    where?: BusRouteWhereInput
  }

  /**
   * PickupPoint without action
   */
  export type PickupPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PickupPoint
     */
    select?: PickupPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PickupPointInclude<ExtArgs> | null
  }


  /**
   * Model StudentFee
   */

  export type AggregateStudentFee = {
    _count: StudentFeeCountAggregateOutputType | null
    _avg: StudentFeeAvgAggregateOutputType | null
    _sum: StudentFeeSumAggregateOutputType | null
    _min: StudentFeeMinAggregateOutputType | null
    _max: StudentFeeMaxAggregateOutputType | null
  }

  export type StudentFeeAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    totalFee: Decimal | null
    paidAmount: Decimal | null
  }

  export type StudentFeeSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    totalFee: Decimal | null
    paidAmount: Decimal | null
  }

  export type StudentFeeMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    totalFee: Decimal | null
    paidAmount: Decimal | null
    dueDate: Date | null
    status: string | null
  }

  export type StudentFeeMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    totalFee: Decimal | null
    paidAmount: Decimal | null
    dueDate: Date | null
    status: string | null
  }

  export type StudentFeeCountAggregateOutputType = {
    id: number
    studentId: number
    totalFee: number
    paidAmount: number
    dueDate: number
    status: number
    _all: number
  }


  export type StudentFeeAvgAggregateInputType = {
    id?: true
    studentId?: true
    totalFee?: true
    paidAmount?: true
  }

  export type StudentFeeSumAggregateInputType = {
    id?: true
    studentId?: true
    totalFee?: true
    paidAmount?: true
  }

  export type StudentFeeMinAggregateInputType = {
    id?: true
    studentId?: true
    totalFee?: true
    paidAmount?: true
    dueDate?: true
    status?: true
  }

  export type StudentFeeMaxAggregateInputType = {
    id?: true
    studentId?: true
    totalFee?: true
    paidAmount?: true
    dueDate?: true
    status?: true
  }

  export type StudentFeeCountAggregateInputType = {
    id?: true
    studentId?: true
    totalFee?: true
    paidAmount?: true
    dueDate?: true
    status?: true
    _all?: true
  }

  export type StudentFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFee to aggregate.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentFees
    **/
    _count?: true | StudentFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentFeeMaxAggregateInputType
  }

  export type GetStudentFeeAggregateType<T extends StudentFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentFee[P]>
      : GetScalarType<T[P], AggregateStudentFee[P]>
  }




  export type StudentFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithAggregationInput | StudentFeeOrderByWithAggregationInput[]
    by: StudentFeeScalarFieldEnum[] | StudentFeeScalarFieldEnum
    having?: StudentFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentFeeCountAggregateInputType | true
    _avg?: StudentFeeAvgAggregateInputType
    _sum?: StudentFeeSumAggregateInputType
    _min?: StudentFeeMinAggregateInputType
    _max?: StudentFeeMaxAggregateInputType
  }

  export type StudentFeeGroupByOutputType = {
    id: number
    studentId: number
    totalFee: Decimal
    paidAmount: Decimal | null
    dueDate: Date
    status: string | null
    _count: StudentFeeCountAggregateOutputType | null
    _avg: StudentFeeAvgAggregateOutputType | null
    _sum: StudentFeeSumAggregateOutputType | null
    _min: StudentFeeMinAggregateOutputType | null
    _max: StudentFeeMaxAggregateOutputType | null
  }

  type GetStudentFeeGroupByPayload<T extends StudentFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentFeeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentFeeGroupByOutputType[P]>
        }
      >
    >


  export type StudentFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    dueDate?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    payments?: boolean | StudentFee$paymentsArgs<ExtArgs>
    _count?: boolean | StudentFeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFee"]>

  export type StudentFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    dueDate?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFee"]>

  export type StudentFeeSelectScalar = {
    id?: boolean
    studentId?: boolean
    totalFee?: boolean
    paidAmount?: boolean
    dueDate?: boolean
    status?: boolean
  }

  export type StudentFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    payments?: boolean | StudentFee$paymentsArgs<ExtArgs>
    _count?: boolean | StudentFeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentFee"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      payments: Prisma.$FeePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      totalFee: Prisma.Decimal
      paidAmount: Prisma.Decimal | null
      dueDate: Date
      status: string | null
    }, ExtArgs["result"]["studentFee"]>
    composites: {}
  }

  type StudentFeeGetPayload<S extends boolean | null | undefined | StudentFeeDefaultArgs> = $Result.GetResult<Prisma.$StudentFeePayload, S>

  type StudentFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentFeeCountAggregateInputType | true
    }

  export interface StudentFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentFee'], meta: { name: 'StudentFee' } }
    /**
     * Find zero or one StudentFee that matches the filter.
     * @param {StudentFeeFindUniqueArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFeeFindUniqueArgs>(args: SelectSubset<T, StudentFeeFindUniqueArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentFee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFeeFindUniqueOrThrowArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindFirstArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFeeFindFirstArgs>(args?: SelectSubset<T, StudentFeeFindFirstArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindFirstOrThrowArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentFees
     * const studentFees = await prisma.studentFee.findMany()
     * 
     * // Get first 10 StudentFees
     * const studentFees = await prisma.studentFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentFeeWithIdOnly = await prisma.studentFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFeeFindManyArgs>(args?: SelectSubset<T, StudentFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentFee.
     * @param {StudentFeeCreateArgs} args - Arguments to create a StudentFee.
     * @example
     * // Create one StudentFee
     * const StudentFee = await prisma.studentFee.create({
     *   data: {
     *     // ... data to create a StudentFee
     *   }
     * })
     * 
     */
    create<T extends StudentFeeCreateArgs>(args: SelectSubset<T, StudentFeeCreateArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentFees.
     * @param {StudentFeeCreateManyArgs} args - Arguments to create many StudentFees.
     * @example
     * // Create many StudentFees
     * const studentFee = await prisma.studentFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentFeeCreateManyArgs>(args?: SelectSubset<T, StudentFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentFees and returns the data saved in the database.
     * @param {StudentFeeCreateManyAndReturnArgs} args - Arguments to create many StudentFees.
     * @example
     * // Create many StudentFees
     * const studentFee = await prisma.studentFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentFees and only return the `id`
     * const studentFeeWithIdOnly = await prisma.studentFee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentFee.
     * @param {StudentFeeDeleteArgs} args - Arguments to delete one StudentFee.
     * @example
     * // Delete one StudentFee
     * const StudentFee = await prisma.studentFee.delete({
     *   where: {
     *     // ... filter to delete one StudentFee
     *   }
     * })
     * 
     */
    delete<T extends StudentFeeDeleteArgs>(args: SelectSubset<T, StudentFeeDeleteArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentFee.
     * @param {StudentFeeUpdateArgs} args - Arguments to update one StudentFee.
     * @example
     * // Update one StudentFee
     * const studentFee = await prisma.studentFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentFeeUpdateArgs>(args: SelectSubset<T, StudentFeeUpdateArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentFees.
     * @param {StudentFeeDeleteManyArgs} args - Arguments to filter StudentFees to delete.
     * @example
     * // Delete a few StudentFees
     * const { count } = await prisma.studentFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentFeeDeleteManyArgs>(args?: SelectSubset<T, StudentFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentFees
     * const studentFee = await prisma.studentFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentFeeUpdateManyArgs>(args: SelectSubset<T, StudentFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentFee.
     * @param {StudentFeeUpsertArgs} args - Arguments to update or create a StudentFee.
     * @example
     * // Update or create a StudentFee
     * const studentFee = await prisma.studentFee.upsert({
     *   create: {
     *     // ... data to create a StudentFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentFee we want to update
     *   }
     * })
     */
    upsert<T extends StudentFeeUpsertArgs>(args: SelectSubset<T, StudentFeeUpsertArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeCountArgs} args - Arguments to filter StudentFees to count.
     * @example
     * // Count the number of StudentFees
     * const count = await prisma.studentFee.count({
     *   where: {
     *     // ... the filter for the StudentFees we want to count
     *   }
     * })
    **/
    count<T extends StudentFeeCountArgs>(
      args?: Subset<T, StudentFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentFeeAggregateArgs>(args: Subset<T, StudentFeeAggregateArgs>): Prisma.PrismaPromise<GetStudentFeeAggregateType<T>>

    /**
     * Group by StudentFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentFeeGroupByArgs['orderBy'] }
        : { orderBy?: StudentFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentFee model
   */
  readonly fields: StudentFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends StudentFee$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, StudentFee$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentFee model
   */ 
  interface StudentFeeFieldRefs {
    readonly id: FieldRef<"StudentFee", 'Int'>
    readonly studentId: FieldRef<"StudentFee", 'Int'>
    readonly totalFee: FieldRef<"StudentFee", 'Decimal'>
    readonly paidAmount: FieldRef<"StudentFee", 'Decimal'>
    readonly dueDate: FieldRef<"StudentFee", 'DateTime'>
    readonly status: FieldRef<"StudentFee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentFee findUnique
   */
  export type StudentFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee findUniqueOrThrow
   */
  export type StudentFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee findFirst
   */
  export type StudentFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFees.
     */
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee findFirstOrThrow
   */
  export type StudentFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFees.
     */
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee findMany
   */
  export type StudentFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFees to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee create
   */
  export type StudentFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentFee.
     */
    data: XOR<StudentFeeCreateInput, StudentFeeUncheckedCreateInput>
  }

  /**
   * StudentFee createMany
   */
  export type StudentFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentFees.
     */
    data: StudentFeeCreateManyInput | StudentFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentFee createManyAndReturn
   */
  export type StudentFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentFees.
     */
    data: StudentFeeCreateManyInput | StudentFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFee update
   */
  export type StudentFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentFee.
     */
    data: XOR<StudentFeeUpdateInput, StudentFeeUncheckedUpdateInput>
    /**
     * Choose, which StudentFee to update.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee updateMany
   */
  export type StudentFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentFees.
     */
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyInput>
    /**
     * Filter which StudentFees to update
     */
    where?: StudentFeeWhereInput
  }

  /**
   * StudentFee upsert
   */
  export type StudentFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentFee to update in case it exists.
     */
    where: StudentFeeWhereUniqueInput
    /**
     * In case the StudentFee found by the `where` argument doesn't exist, create a new StudentFee with this data.
     */
    create: XOR<StudentFeeCreateInput, StudentFeeUncheckedCreateInput>
    /**
     * In case the StudentFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentFeeUpdateInput, StudentFeeUncheckedUpdateInput>
  }

  /**
   * StudentFee delete
   */
  export type StudentFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter which StudentFee to delete.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee deleteMany
   */
  export type StudentFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFees to delete
     */
    where?: StudentFeeWhereInput
  }

  /**
   * StudentFee.payments
   */
  export type StudentFee$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    cursor?: FeePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * StudentFee without action
   */
  export type StudentFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
  }


  /**
   * Model FeePayment
   */

  export type AggregateFeePayment = {
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  export type FeePaymentAvgAggregateOutputType = {
    id: number | null
    feeId: number | null
    amount: Decimal | null
  }

  export type FeePaymentSumAggregateOutputType = {
    id: number | null
    feeId: number | null
    amount: Decimal | null
  }

  export type FeePaymentMinAggregateOutputType = {
    id: number | null
    feeId: number | null
    amount: Decimal | null
    date: Date | null
    method: string | null
    reference: string | null
    recordedBy: string | null
  }

  export type FeePaymentMaxAggregateOutputType = {
    id: number | null
    feeId: number | null
    amount: Decimal | null
    date: Date | null
    method: string | null
    reference: string | null
    recordedBy: string | null
  }

  export type FeePaymentCountAggregateOutputType = {
    id: number
    feeId: number
    amount: number
    date: number
    method: number
    reference: number
    recordedBy: number
    _all: number
  }


  export type FeePaymentAvgAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
  }

  export type FeePaymentSumAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
  }

  export type FeePaymentMinAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    recordedBy?: true
  }

  export type FeePaymentMaxAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    recordedBy?: true
  }

  export type FeePaymentCountAggregateInputType = {
    id?: true
    feeId?: true
    amount?: true
    date?: true
    method?: true
    reference?: true
    recordedBy?: true
    _all?: true
  }

  export type FeePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayment to aggregate.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeePayments
    **/
    _count?: true | FeePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeePaymentMaxAggregateInputType
  }

  export type GetFeePaymentAggregateType<T extends FeePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateFeePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeePayment[P]>
      : GetScalarType<T[P], AggregateFeePayment[P]>
  }




  export type FeePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeePaymentWhereInput
    orderBy?: FeePaymentOrderByWithAggregationInput | FeePaymentOrderByWithAggregationInput[]
    by: FeePaymentScalarFieldEnum[] | FeePaymentScalarFieldEnum
    having?: FeePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeePaymentCountAggregateInputType | true
    _avg?: FeePaymentAvgAggregateInputType
    _sum?: FeePaymentSumAggregateInputType
    _min?: FeePaymentMinAggregateInputType
    _max?: FeePaymentMaxAggregateInputType
  }

  export type FeePaymentGroupByOutputType = {
    id: number
    feeId: number
    amount: Decimal
    date: Date | null
    method: string | null
    reference: string | null
    recordedBy: string | null
    _count: FeePaymentCountAggregateOutputType | null
    _avg: FeePaymentAvgAggregateOutputType | null
    _sum: FeePaymentSumAggregateOutputType | null
    _min: FeePaymentMinAggregateOutputType | null
    _max: FeePaymentMaxAggregateOutputType | null
  }

  type GetFeePaymentGroupByPayload<T extends FeePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], FeePaymentGroupByOutputType[P]>
        }
      >
    >


  export type FeePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    amount?: boolean
    date?: boolean
    method?: boolean
    reference?: boolean
    recordedBy?: boolean
    fee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    amount?: boolean
    date?: boolean
    method?: boolean
    reference?: boolean
    recordedBy?: boolean
    fee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feePayment"]>

  export type FeePaymentSelectScalar = {
    id?: boolean
    feeId?: boolean
    amount?: boolean
    date?: boolean
    method?: boolean
    reference?: boolean
    recordedBy?: boolean
  }

  export type FeePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }
  export type FeePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }

  export type $FeePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeePayment"
    objects: {
      fee: Prisma.$StudentFeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feeId: number
      amount: Prisma.Decimal
      date: Date | null
      method: string | null
      reference: string | null
      recordedBy: string | null
    }, ExtArgs["result"]["feePayment"]>
    composites: {}
  }

  type FeePaymentGetPayload<S extends boolean | null | undefined | FeePaymentDefaultArgs> = $Result.GetResult<Prisma.$FeePaymentPayload, S>

  type FeePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeePaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeePaymentCountAggregateInputType | true
    }

  export interface FeePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeePayment'], meta: { name: 'FeePayment' } }
    /**
     * Find zero or one FeePayment that matches the filter.
     * @param {FeePaymentFindUniqueArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeePaymentFindUniqueArgs>(args: SelectSubset<T, FeePaymentFindUniqueArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeePayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeePaymentFindUniqueOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, FeePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeePaymentFindFirstArgs>(args?: SelectSubset<T, FeePaymentFindFirstArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindFirstOrThrowArgs} args - Arguments to find a FeePayment
     * @example
     * // Get one FeePayment
     * const feePayment = await prisma.feePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, FeePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeePayments
     * const feePayments = await prisma.feePayment.findMany()
     * 
     * // Get first 10 FeePayments
     * const feePayments = await prisma.feePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeePaymentFindManyArgs>(args?: SelectSubset<T, FeePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeePayment.
     * @param {FeePaymentCreateArgs} args - Arguments to create a FeePayment.
     * @example
     * // Create one FeePayment
     * const FeePayment = await prisma.feePayment.create({
     *   data: {
     *     // ... data to create a FeePayment
     *   }
     * })
     * 
     */
    create<T extends FeePaymentCreateArgs>(args: SelectSubset<T, FeePaymentCreateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeePayments.
     * @param {FeePaymentCreateManyArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeePaymentCreateManyArgs>(args?: SelectSubset<T, FeePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeePayments and returns the data saved in the database.
     * @param {FeePaymentCreateManyAndReturnArgs} args - Arguments to create many FeePayments.
     * @example
     * // Create many FeePayments
     * const feePayment = await prisma.feePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeePayments and only return the `id`
     * const feePaymentWithIdOnly = await prisma.feePayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, FeePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeePayment.
     * @param {FeePaymentDeleteArgs} args - Arguments to delete one FeePayment.
     * @example
     * // Delete one FeePayment
     * const FeePayment = await prisma.feePayment.delete({
     *   where: {
     *     // ... filter to delete one FeePayment
     *   }
     * })
     * 
     */
    delete<T extends FeePaymentDeleteArgs>(args: SelectSubset<T, FeePaymentDeleteArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeePayment.
     * @param {FeePaymentUpdateArgs} args - Arguments to update one FeePayment.
     * @example
     * // Update one FeePayment
     * const feePayment = await prisma.feePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeePaymentUpdateArgs>(args: SelectSubset<T, FeePaymentUpdateArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeePayments.
     * @param {FeePaymentDeleteManyArgs} args - Arguments to filter FeePayments to delete.
     * @example
     * // Delete a few FeePayments
     * const { count } = await prisma.feePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeePaymentDeleteManyArgs>(args?: SelectSubset<T, FeePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeePayments
     * const feePayment = await prisma.feePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeePaymentUpdateManyArgs>(args: SelectSubset<T, FeePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeePayment.
     * @param {FeePaymentUpsertArgs} args - Arguments to update or create a FeePayment.
     * @example
     * // Update or create a FeePayment
     * const feePayment = await prisma.feePayment.upsert({
     *   create: {
     *     // ... data to create a FeePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeePayment we want to update
     *   }
     * })
     */
    upsert<T extends FeePaymentUpsertArgs>(args: SelectSubset<T, FeePaymentUpsertArgs<ExtArgs>>): Prisma__FeePaymentClient<$Result.GetResult<Prisma.$FeePaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentCountArgs} args - Arguments to filter FeePayments to count.
     * @example
     * // Count the number of FeePayments
     * const count = await prisma.feePayment.count({
     *   where: {
     *     // ... the filter for the FeePayments we want to count
     *   }
     * })
    **/
    count<T extends FeePaymentCountArgs>(
      args?: Subset<T, FeePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeePaymentAggregateArgs>(args: Subset<T, FeePaymentAggregateArgs>): Prisma.PrismaPromise<GetFeePaymentAggregateType<T>>

    /**
     * Group by FeePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeePaymentGroupByArgs['orderBy'] }
        : { orderBy?: FeePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeePayment model
   */
  readonly fields: FeePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fee<T extends StudentFeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentFeeDefaultArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeePayment model
   */ 
  interface FeePaymentFieldRefs {
    readonly id: FieldRef<"FeePayment", 'Int'>
    readonly feeId: FieldRef<"FeePayment", 'Int'>
    readonly amount: FieldRef<"FeePayment", 'Decimal'>
    readonly date: FieldRef<"FeePayment", 'DateTime'>
    readonly method: FieldRef<"FeePayment", 'String'>
    readonly reference: FieldRef<"FeePayment", 'String'>
    readonly recordedBy: FieldRef<"FeePayment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeePayment findUnique
   */
  export type FeePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findUniqueOrThrow
   */
  export type FeePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment findFirst
   */
  export type FeePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findFirstOrThrow
   */
  export type FeePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayment to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeePayments.
     */
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment findMany
   */
  export type FeePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter, which FeePayments to fetch.
     */
    where?: FeePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeePayments to fetch.
     */
    orderBy?: FeePaymentOrderByWithRelationInput | FeePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeePayments.
     */
    cursor?: FeePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeePayments.
     */
    skip?: number
    distinct?: FeePaymentScalarFieldEnum | FeePaymentScalarFieldEnum[]
  }

  /**
   * FeePayment create
   */
  export type FeePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a FeePayment.
     */
    data: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
  }

  /**
   * FeePayment createMany
   */
  export type FeePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeePayment createManyAndReturn
   */
  export type FeePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeePayments.
     */
    data: FeePaymentCreateManyInput | FeePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeePayment update
   */
  export type FeePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a FeePayment.
     */
    data: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
    /**
     * Choose, which FeePayment to update.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment updateMany
   */
  export type FeePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeePayments.
     */
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyInput>
    /**
     * Filter which FeePayments to update
     */
    where?: FeePaymentWhereInput
  }

  /**
   * FeePayment upsert
   */
  export type FeePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the FeePayment to update in case it exists.
     */
    where: FeePaymentWhereUniqueInput
    /**
     * In case the FeePayment found by the `where` argument doesn't exist, create a new FeePayment with this data.
     */
    create: XOR<FeePaymentCreateInput, FeePaymentUncheckedCreateInput>
    /**
     * In case the FeePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeePaymentUpdateInput, FeePaymentUncheckedUpdateInput>
  }

  /**
   * FeePayment delete
   */
  export type FeePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
    /**
     * Filter which FeePayment to delete.
     */
    where: FeePaymentWhereUniqueInput
  }

  /**
   * FeePayment deleteMany
   */
  export type FeePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeePayments to delete
     */
    where?: FeePaymentWhereInput
  }

  /**
   * FeePayment without action
   */
  export type FeePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeePayment
     */
    select?: FeePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeePaymentInclude<ExtArgs> | null
  }


  /**
   * Model StoreProduct
   */

  export type AggregateStoreProduct = {
    _count: StoreProductCountAggregateOutputType | null
    _avg: StoreProductAvgAggregateOutputType | null
    _sum: StoreProductSumAggregateOutputType | null
    _min: StoreProductMinAggregateOutputType | null
    _max: StoreProductMaxAggregateOutputType | null
  }

  export type StoreProductAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
  }

  export type StoreProductSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
  }

  export type StoreProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    price: Decimal | null
    imageUrl: string | null
    stock: number | null
  }

  export type StoreProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    price: Decimal | null
    imageUrl: string | null
    stock: number | null
  }

  export type StoreProductCountAggregateOutputType = {
    id: number
    name: number
    category: number
    price: number
    imageUrl: number
    stock: number
    _all: number
  }


  export type StoreProductAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
  }

  export type StoreProductSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
  }

  export type StoreProductMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    imageUrl?: true
    stock?: true
  }

  export type StoreProductMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    imageUrl?: true
    stock?: true
  }

  export type StoreProductCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    imageUrl?: true
    stock?: true
    _all?: true
  }

  export type StoreProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreProduct to aggregate.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreProducts
    **/
    _count?: true | StoreProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreProductMaxAggregateInputType
  }

  export type GetStoreProductAggregateType<T extends StoreProductAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreProduct[P]>
      : GetScalarType<T[P], AggregateStoreProduct[P]>
  }




  export type StoreProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreProductWhereInput
    orderBy?: StoreProductOrderByWithAggregationInput | StoreProductOrderByWithAggregationInput[]
    by: StoreProductScalarFieldEnum[] | StoreProductScalarFieldEnum
    having?: StoreProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreProductCountAggregateInputType | true
    _avg?: StoreProductAvgAggregateInputType
    _sum?: StoreProductSumAggregateInputType
    _min?: StoreProductMinAggregateInputType
    _max?: StoreProductMaxAggregateInputType
  }

  export type StoreProductGroupByOutputType = {
    id: number
    name: string
    category: string
    price: Decimal
    imageUrl: string | null
    stock: number | null
    _count: StoreProductCountAggregateOutputType | null
    _avg: StoreProductAvgAggregateOutputType | null
    _sum: StoreProductSumAggregateOutputType | null
    _min: StoreProductMinAggregateOutputType | null
    _max: StoreProductMaxAggregateOutputType | null
  }

  type GetStoreProductGroupByPayload<T extends StoreProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreProductGroupByOutputType[P]>
            : GetScalarType<T[P], StoreProductGroupByOutputType[P]>
        }
      >
    >


  export type StoreProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    imageUrl?: boolean
    stock?: boolean
  }, ExtArgs["result"]["storeProduct"]>

  export type StoreProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    imageUrl?: boolean
    stock?: boolean
  }, ExtArgs["result"]["storeProduct"]>

  export type StoreProductSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    imageUrl?: boolean
    stock?: boolean
  }


  export type $StoreProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreProduct"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      price: Prisma.Decimal
      imageUrl: string | null
      stock: number | null
    }, ExtArgs["result"]["storeProduct"]>
    composites: {}
  }

  type StoreProductGetPayload<S extends boolean | null | undefined | StoreProductDefaultArgs> = $Result.GetResult<Prisma.$StoreProductPayload, S>

  type StoreProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreProductCountAggregateInputType | true
    }

  export interface StoreProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreProduct'], meta: { name: 'StoreProduct' } }
    /**
     * Find zero or one StoreProduct that matches the filter.
     * @param {StoreProductFindUniqueArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreProductFindUniqueArgs>(args: SelectSubset<T, StoreProductFindUniqueArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreProductFindUniqueOrThrowArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreProductFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindFirstArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreProductFindFirstArgs>(args?: SelectSubset<T, StoreProductFindFirstArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindFirstOrThrowArgs} args - Arguments to find a StoreProduct
     * @example
     * // Get one StoreProduct
     * const storeProduct = await prisma.storeProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreProductFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreProducts
     * const storeProducts = await prisma.storeProduct.findMany()
     * 
     * // Get first 10 StoreProducts
     * const storeProducts = await prisma.storeProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeProductWithIdOnly = await prisma.storeProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreProductFindManyArgs>(args?: SelectSubset<T, StoreProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreProduct.
     * @param {StoreProductCreateArgs} args - Arguments to create a StoreProduct.
     * @example
     * // Create one StoreProduct
     * const StoreProduct = await prisma.storeProduct.create({
     *   data: {
     *     // ... data to create a StoreProduct
     *   }
     * })
     * 
     */
    create<T extends StoreProductCreateArgs>(args: SelectSubset<T, StoreProductCreateArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreProducts.
     * @param {StoreProductCreateManyArgs} args - Arguments to create many StoreProducts.
     * @example
     * // Create many StoreProducts
     * const storeProduct = await prisma.storeProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreProductCreateManyArgs>(args?: SelectSubset<T, StoreProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreProducts and returns the data saved in the database.
     * @param {StoreProductCreateManyAndReturnArgs} args - Arguments to create many StoreProducts.
     * @example
     * // Create many StoreProducts
     * const storeProduct = await prisma.storeProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreProducts and only return the `id`
     * const storeProductWithIdOnly = await prisma.storeProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreProductCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreProduct.
     * @param {StoreProductDeleteArgs} args - Arguments to delete one StoreProduct.
     * @example
     * // Delete one StoreProduct
     * const StoreProduct = await prisma.storeProduct.delete({
     *   where: {
     *     // ... filter to delete one StoreProduct
     *   }
     * })
     * 
     */
    delete<T extends StoreProductDeleteArgs>(args: SelectSubset<T, StoreProductDeleteArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreProduct.
     * @param {StoreProductUpdateArgs} args - Arguments to update one StoreProduct.
     * @example
     * // Update one StoreProduct
     * const storeProduct = await prisma.storeProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreProductUpdateArgs>(args: SelectSubset<T, StoreProductUpdateArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreProducts.
     * @param {StoreProductDeleteManyArgs} args - Arguments to filter StoreProducts to delete.
     * @example
     * // Delete a few StoreProducts
     * const { count } = await prisma.storeProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreProductDeleteManyArgs>(args?: SelectSubset<T, StoreProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreProducts
     * const storeProduct = await prisma.storeProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreProductUpdateManyArgs>(args: SelectSubset<T, StoreProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreProduct.
     * @param {StoreProductUpsertArgs} args - Arguments to update or create a StoreProduct.
     * @example
     * // Update or create a StoreProduct
     * const storeProduct = await prisma.storeProduct.upsert({
     *   create: {
     *     // ... data to create a StoreProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreProduct we want to update
     *   }
     * })
     */
    upsert<T extends StoreProductUpsertArgs>(args: SelectSubset<T, StoreProductUpsertArgs<ExtArgs>>): Prisma__StoreProductClient<$Result.GetResult<Prisma.$StoreProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductCountArgs} args - Arguments to filter StoreProducts to count.
     * @example
     * // Count the number of StoreProducts
     * const count = await prisma.storeProduct.count({
     *   where: {
     *     // ... the filter for the StoreProducts we want to count
     *   }
     * })
    **/
    count<T extends StoreProductCountArgs>(
      args?: Subset<T, StoreProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreProductAggregateArgs>(args: Subset<T, StoreProductAggregateArgs>): Prisma.PrismaPromise<GetStoreProductAggregateType<T>>

    /**
     * Group by StoreProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreProductGroupByArgs['orderBy'] }
        : { orderBy?: StoreProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreProduct model
   */
  readonly fields: StoreProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreProduct model
   */ 
  interface StoreProductFieldRefs {
    readonly id: FieldRef<"StoreProduct", 'Int'>
    readonly name: FieldRef<"StoreProduct", 'String'>
    readonly category: FieldRef<"StoreProduct", 'String'>
    readonly price: FieldRef<"StoreProduct", 'Decimal'>
    readonly imageUrl: FieldRef<"StoreProduct", 'String'>
    readonly stock: FieldRef<"StoreProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StoreProduct findUnique
   */
  export type StoreProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct findUniqueOrThrow
   */
  export type StoreProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct findFirst
   */
  export type StoreProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreProducts.
     */
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct findFirstOrThrow
   */
  export type StoreProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter, which StoreProduct to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreProducts.
     */
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct findMany
   */
  export type StoreProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter, which StoreProducts to fetch.
     */
    where?: StoreProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreProducts to fetch.
     */
    orderBy?: StoreProductOrderByWithRelationInput | StoreProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreProducts.
     */
    cursor?: StoreProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreProducts.
     */
    skip?: number
    distinct?: StoreProductScalarFieldEnum | StoreProductScalarFieldEnum[]
  }

  /**
   * StoreProduct create
   */
  export type StoreProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * The data needed to create a StoreProduct.
     */
    data: XOR<StoreProductCreateInput, StoreProductUncheckedCreateInput>
  }

  /**
   * StoreProduct createMany
   */
  export type StoreProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreProducts.
     */
    data: StoreProductCreateManyInput | StoreProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreProduct createManyAndReturn
   */
  export type StoreProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreProducts.
     */
    data: StoreProductCreateManyInput | StoreProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreProduct update
   */
  export type StoreProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * The data needed to update a StoreProduct.
     */
    data: XOR<StoreProductUpdateInput, StoreProductUncheckedUpdateInput>
    /**
     * Choose, which StoreProduct to update.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct updateMany
   */
  export type StoreProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreProducts.
     */
    data: XOR<StoreProductUpdateManyMutationInput, StoreProductUncheckedUpdateManyInput>
    /**
     * Filter which StoreProducts to update
     */
    where?: StoreProductWhereInput
  }

  /**
   * StoreProduct upsert
   */
  export type StoreProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * The filter to search for the StoreProduct to update in case it exists.
     */
    where: StoreProductWhereUniqueInput
    /**
     * In case the StoreProduct found by the `where` argument doesn't exist, create a new StoreProduct with this data.
     */
    create: XOR<StoreProductCreateInput, StoreProductUncheckedCreateInput>
    /**
     * In case the StoreProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreProductUpdateInput, StoreProductUncheckedUpdateInput>
  }

  /**
   * StoreProduct delete
   */
  export type StoreProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
    /**
     * Filter which StoreProduct to delete.
     */
    where: StoreProductWhereUniqueInput
  }

  /**
   * StoreProduct deleteMany
   */
  export type StoreProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreProducts to delete
     */
    where?: StoreProductWhereInput
  }

  /**
   * StoreProduct without action
   */
  export type StoreProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreProduct
     */
    select?: StoreProductSelect<ExtArgs> | null
  }


  /**
   * Model StoreOrder
   */

  export type AggregateStoreOrder = {
    _count: StoreOrderCountAggregateOutputType | null
    _avg: StoreOrderAvgAggregateOutputType | null
    _sum: StoreOrderSumAggregateOutputType | null
    _min: StoreOrderMinAggregateOutputType | null
    _max: StoreOrderMaxAggregateOutputType | null
  }

  export type StoreOrderAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type StoreOrderSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type StoreOrderMinAggregateOutputType = {
    id: string | null
    customerName: string | null
    totalAmount: Decimal | null
    status: string | null
    orderDate: Date | null
  }

  export type StoreOrderMaxAggregateOutputType = {
    id: string | null
    customerName: string | null
    totalAmount: Decimal | null
    status: string | null
    orderDate: Date | null
  }

  export type StoreOrderCountAggregateOutputType = {
    id: number
    customerName: number
    totalAmount: number
    status: number
    orderDate: number
    items: number
    _all: number
  }


  export type StoreOrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type StoreOrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type StoreOrderMinAggregateInputType = {
    id?: true
    customerName?: true
    totalAmount?: true
    status?: true
    orderDate?: true
  }

  export type StoreOrderMaxAggregateInputType = {
    id?: true
    customerName?: true
    totalAmount?: true
    status?: true
    orderDate?: true
  }

  export type StoreOrderCountAggregateInputType = {
    id?: true
    customerName?: true
    totalAmount?: true
    status?: true
    orderDate?: true
    items?: true
    _all?: true
  }

  export type StoreOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreOrder to aggregate.
     */
    where?: StoreOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreOrders to fetch.
     */
    orderBy?: StoreOrderOrderByWithRelationInput | StoreOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreOrders
    **/
    _count?: true | StoreOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreOrderMaxAggregateInputType
  }

  export type GetStoreOrderAggregateType<T extends StoreOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreOrder[P]>
      : GetScalarType<T[P], AggregateStoreOrder[P]>
  }




  export type StoreOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreOrderWhereInput
    orderBy?: StoreOrderOrderByWithAggregationInput | StoreOrderOrderByWithAggregationInput[]
    by: StoreOrderScalarFieldEnum[] | StoreOrderScalarFieldEnum
    having?: StoreOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreOrderCountAggregateInputType | true
    _avg?: StoreOrderAvgAggregateInputType
    _sum?: StoreOrderSumAggregateInputType
    _min?: StoreOrderMinAggregateInputType
    _max?: StoreOrderMaxAggregateInputType
  }

  export type StoreOrderGroupByOutputType = {
    id: string
    customerName: string
    totalAmount: Decimal
    status: string | null
    orderDate: Date
    items: JsonValue | null
    _count: StoreOrderCountAggregateOutputType | null
    _avg: StoreOrderAvgAggregateOutputType | null
    _sum: StoreOrderSumAggregateOutputType | null
    _min: StoreOrderMinAggregateOutputType | null
    _max: StoreOrderMaxAggregateOutputType | null
  }

  type GetStoreOrderGroupByPayload<T extends StoreOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreOrderGroupByOutputType[P]>
            : GetScalarType<T[P], StoreOrderGroupByOutputType[P]>
        }
      >
    >


  export type StoreOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    totalAmount?: boolean
    status?: boolean
    orderDate?: boolean
    items?: boolean
  }, ExtArgs["result"]["storeOrder"]>

  export type StoreOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerName?: boolean
    totalAmount?: boolean
    status?: boolean
    orderDate?: boolean
    items?: boolean
  }, ExtArgs["result"]["storeOrder"]>

  export type StoreOrderSelectScalar = {
    id?: boolean
    customerName?: boolean
    totalAmount?: boolean
    status?: boolean
    orderDate?: boolean
    items?: boolean
  }


  export type $StoreOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreOrder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerName: string
      totalAmount: Prisma.Decimal
      status: string | null
      orderDate: Date
      items: Prisma.JsonValue | null
    }, ExtArgs["result"]["storeOrder"]>
    composites: {}
  }

  type StoreOrderGetPayload<S extends boolean | null | undefined | StoreOrderDefaultArgs> = $Result.GetResult<Prisma.$StoreOrderPayload, S>

  type StoreOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreOrderCountAggregateInputType | true
    }

  export interface StoreOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreOrder'], meta: { name: 'StoreOrder' } }
    /**
     * Find zero or one StoreOrder that matches the filter.
     * @param {StoreOrderFindUniqueArgs} args - Arguments to find a StoreOrder
     * @example
     * // Get one StoreOrder
     * const storeOrder = await prisma.storeOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreOrderFindUniqueArgs>(args: SelectSubset<T, StoreOrderFindUniqueArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreOrderFindUniqueOrThrowArgs} args - Arguments to find a StoreOrder
     * @example
     * // Get one StoreOrder
     * const storeOrder = await prisma.storeOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderFindFirstArgs} args - Arguments to find a StoreOrder
     * @example
     * // Get one StoreOrder
     * const storeOrder = await prisma.storeOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreOrderFindFirstArgs>(args?: SelectSubset<T, StoreOrderFindFirstArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderFindFirstOrThrowArgs} args - Arguments to find a StoreOrder
     * @example
     * // Get one StoreOrder
     * const storeOrder = await prisma.storeOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreOrders
     * const storeOrders = await prisma.storeOrder.findMany()
     * 
     * // Get first 10 StoreOrders
     * const storeOrders = await prisma.storeOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeOrderWithIdOnly = await prisma.storeOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreOrderFindManyArgs>(args?: SelectSubset<T, StoreOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreOrder.
     * @param {StoreOrderCreateArgs} args - Arguments to create a StoreOrder.
     * @example
     * // Create one StoreOrder
     * const StoreOrder = await prisma.storeOrder.create({
     *   data: {
     *     // ... data to create a StoreOrder
     *   }
     * })
     * 
     */
    create<T extends StoreOrderCreateArgs>(args: SelectSubset<T, StoreOrderCreateArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreOrders.
     * @param {StoreOrderCreateManyArgs} args - Arguments to create many StoreOrders.
     * @example
     * // Create many StoreOrders
     * const storeOrder = await prisma.storeOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreOrderCreateManyArgs>(args?: SelectSubset<T, StoreOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StoreOrders and returns the data saved in the database.
     * @param {StoreOrderCreateManyAndReturnArgs} args - Arguments to create many StoreOrders.
     * @example
     * // Create many StoreOrders
     * const storeOrder = await prisma.storeOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StoreOrders and only return the `id`
     * const storeOrderWithIdOnly = await prisma.storeOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StoreOrder.
     * @param {StoreOrderDeleteArgs} args - Arguments to delete one StoreOrder.
     * @example
     * // Delete one StoreOrder
     * const StoreOrder = await prisma.storeOrder.delete({
     *   where: {
     *     // ... filter to delete one StoreOrder
     *   }
     * })
     * 
     */
    delete<T extends StoreOrderDeleteArgs>(args: SelectSubset<T, StoreOrderDeleteArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreOrder.
     * @param {StoreOrderUpdateArgs} args - Arguments to update one StoreOrder.
     * @example
     * // Update one StoreOrder
     * const storeOrder = await prisma.storeOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreOrderUpdateArgs>(args: SelectSubset<T, StoreOrderUpdateArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreOrders.
     * @param {StoreOrderDeleteManyArgs} args - Arguments to filter StoreOrders to delete.
     * @example
     * // Delete a few StoreOrders
     * const { count } = await prisma.storeOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreOrderDeleteManyArgs>(args?: SelectSubset<T, StoreOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreOrders
     * const storeOrder = await prisma.storeOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreOrderUpdateManyArgs>(args: SelectSubset<T, StoreOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreOrder.
     * @param {StoreOrderUpsertArgs} args - Arguments to update or create a StoreOrder.
     * @example
     * // Update or create a StoreOrder
     * const storeOrder = await prisma.storeOrder.upsert({
     *   create: {
     *     // ... data to create a StoreOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreOrder we want to update
     *   }
     * })
     */
    upsert<T extends StoreOrderUpsertArgs>(args: SelectSubset<T, StoreOrderUpsertArgs<ExtArgs>>): Prisma__StoreOrderClient<$Result.GetResult<Prisma.$StoreOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderCountArgs} args - Arguments to filter StoreOrders to count.
     * @example
     * // Count the number of StoreOrders
     * const count = await prisma.storeOrder.count({
     *   where: {
     *     // ... the filter for the StoreOrders we want to count
     *   }
     * })
    **/
    count<T extends StoreOrderCountArgs>(
      args?: Subset<T, StoreOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreOrderAggregateArgs>(args: Subset<T, StoreOrderAggregateArgs>): Prisma.PrismaPromise<GetStoreOrderAggregateType<T>>

    /**
     * Group by StoreOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreOrderGroupByArgs['orderBy'] }
        : { orderBy?: StoreOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreOrder model
   */
  readonly fields: StoreOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreOrder model
   */ 
  interface StoreOrderFieldRefs {
    readonly id: FieldRef<"StoreOrder", 'String'>
    readonly customerName: FieldRef<"StoreOrder", 'String'>
    readonly totalAmount: FieldRef<"StoreOrder", 'Decimal'>
    readonly status: FieldRef<"StoreOrder", 'String'>
    readonly orderDate: FieldRef<"StoreOrder", 'DateTime'>
    readonly items: FieldRef<"StoreOrder", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StoreOrder findUnique
   */
  export type StoreOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter, which StoreOrder to fetch.
     */
    where: StoreOrderWhereUniqueInput
  }

  /**
   * StoreOrder findUniqueOrThrow
   */
  export type StoreOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter, which StoreOrder to fetch.
     */
    where: StoreOrderWhereUniqueInput
  }

  /**
   * StoreOrder findFirst
   */
  export type StoreOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter, which StoreOrder to fetch.
     */
    where?: StoreOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreOrders to fetch.
     */
    orderBy?: StoreOrderOrderByWithRelationInput | StoreOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreOrders.
     */
    cursor?: StoreOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreOrders.
     */
    distinct?: StoreOrderScalarFieldEnum | StoreOrderScalarFieldEnum[]
  }

  /**
   * StoreOrder findFirstOrThrow
   */
  export type StoreOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter, which StoreOrder to fetch.
     */
    where?: StoreOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreOrders to fetch.
     */
    orderBy?: StoreOrderOrderByWithRelationInput | StoreOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreOrders.
     */
    cursor?: StoreOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreOrders.
     */
    distinct?: StoreOrderScalarFieldEnum | StoreOrderScalarFieldEnum[]
  }

  /**
   * StoreOrder findMany
   */
  export type StoreOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter, which StoreOrders to fetch.
     */
    where?: StoreOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreOrders to fetch.
     */
    orderBy?: StoreOrderOrderByWithRelationInput | StoreOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreOrders.
     */
    cursor?: StoreOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreOrders.
     */
    skip?: number
    distinct?: StoreOrderScalarFieldEnum | StoreOrderScalarFieldEnum[]
  }

  /**
   * StoreOrder create
   */
  export type StoreOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * The data needed to create a StoreOrder.
     */
    data: XOR<StoreOrderCreateInput, StoreOrderUncheckedCreateInput>
  }

  /**
   * StoreOrder createMany
   */
  export type StoreOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreOrders.
     */
    data: StoreOrderCreateManyInput | StoreOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreOrder createManyAndReturn
   */
  export type StoreOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StoreOrders.
     */
    data: StoreOrderCreateManyInput | StoreOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreOrder update
   */
  export type StoreOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * The data needed to update a StoreOrder.
     */
    data: XOR<StoreOrderUpdateInput, StoreOrderUncheckedUpdateInput>
    /**
     * Choose, which StoreOrder to update.
     */
    where: StoreOrderWhereUniqueInput
  }

  /**
   * StoreOrder updateMany
   */
  export type StoreOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreOrders.
     */
    data: XOR<StoreOrderUpdateManyMutationInput, StoreOrderUncheckedUpdateManyInput>
    /**
     * Filter which StoreOrders to update
     */
    where?: StoreOrderWhereInput
  }

  /**
   * StoreOrder upsert
   */
  export type StoreOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * The filter to search for the StoreOrder to update in case it exists.
     */
    where: StoreOrderWhereUniqueInput
    /**
     * In case the StoreOrder found by the `where` argument doesn't exist, create a new StoreOrder with this data.
     */
    create: XOR<StoreOrderCreateInput, StoreOrderUncheckedCreateInput>
    /**
     * In case the StoreOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreOrderUpdateInput, StoreOrderUncheckedUpdateInput>
  }

  /**
   * StoreOrder delete
   */
  export type StoreOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
    /**
     * Filter which StoreOrder to delete.
     */
    where: StoreOrderWhereUniqueInput
  }

  /**
   * StoreOrder deleteMany
   */
  export type StoreOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreOrders to delete
     */
    where?: StoreOrderWhereInput
  }

  /**
   * StoreOrder without action
   */
  export type StoreOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreOrder
     */
    select?: StoreOrderSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    userName: string | null
    userRole: string | null
    action: string | null
    type: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    userName: string | null
    userRole: string | null
    action: string | null
    type: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userName: number
    userRole: number
    action: number
    type: number
    timestamp: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    type?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    type?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userName?: true
    userRole?: true
    action?: true
    type?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    userName: string | null
    userRole: string | null
    action: string
    type: string
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    type?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    type?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userName?: boolean
    userRole?: boolean
    action?: boolean
    type?: boolean
    timestamp?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userName: string | null
      userRole: string | null
      action: string
      type: string
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly userName: FieldRef<"AuditLog", 'String'>
    readonly userRole: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly type: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model HealthLog
   */

  export type AggregateHealthLog = {
    _count: HealthLogCountAggregateOutputType | null
    _avg: HealthLogAvgAggregateOutputType | null
    _sum: HealthLogSumAggregateOutputType | null
    _min: HealthLogMinAggregateOutputType | null
    _max: HealthLogMaxAggregateOutputType | null
  }

  export type HealthLogAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type HealthLogSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type HealthLogMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    date: Date | null
    time: string | null
    reason: string | null
    notes: string | null
    parentNotified: boolean | null
    recordedBy: string | null
  }

  export type HealthLogMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    date: Date | null
    time: string | null
    reason: string | null
    notes: string | null
    parentNotified: boolean | null
    recordedBy: string | null
  }

  export type HealthLogCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    time: number
    reason: number
    notes: number
    parentNotified: number
    medicationAdministered: number
    recordedBy: number
    _all: number
  }


  export type HealthLogAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type HealthLogSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type HealthLogMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    time?: true
    reason?: true
    notes?: true
    parentNotified?: true
    recordedBy?: true
  }

  export type HealthLogMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    time?: true
    reason?: true
    notes?: true
    parentNotified?: true
    recordedBy?: true
  }

  export type HealthLogCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    time?: true
    reason?: true
    notes?: true
    parentNotified?: true
    medicationAdministered?: true
    recordedBy?: true
    _all?: true
  }

  export type HealthLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthLog to aggregate.
     */
    where?: HealthLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthLogs to fetch.
     */
    orderBy?: HealthLogOrderByWithRelationInput | HealthLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthLogs
    **/
    _count?: true | HealthLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthLogMaxAggregateInputType
  }

  export type GetHealthLogAggregateType<T extends HealthLogAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthLog[P]>
      : GetScalarType<T[P], AggregateHealthLog[P]>
  }




  export type HealthLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthLogWhereInput
    orderBy?: HealthLogOrderByWithAggregationInput | HealthLogOrderByWithAggregationInput[]
    by: HealthLogScalarFieldEnum[] | HealthLogScalarFieldEnum
    having?: HealthLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthLogCountAggregateInputType | true
    _avg?: HealthLogAvgAggregateInputType
    _sum?: HealthLogSumAggregateInputType
    _min?: HealthLogMinAggregateInputType
    _max?: HealthLogMaxAggregateInputType
  }

  export type HealthLogGroupByOutputType = {
    id: number
    studentId: number | null
    date: Date
    time: string | null
    reason: string
    notes: string | null
    parentNotified: boolean | null
    medicationAdministered: JsonValue | null
    recordedBy: string | null
    _count: HealthLogCountAggregateOutputType | null
    _avg: HealthLogAvgAggregateOutputType | null
    _sum: HealthLogSumAggregateOutputType | null
    _min: HealthLogMinAggregateOutputType | null
    _max: HealthLogMaxAggregateOutputType | null
  }

  type GetHealthLogGroupByPayload<T extends HealthLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthLogGroupByOutputType[P]>
            : GetScalarType<T[P], HealthLogGroupByOutputType[P]>
        }
      >
    >


  export type HealthLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    notes?: boolean
    parentNotified?: boolean
    medicationAdministered?: boolean
    recordedBy?: boolean
    student?: boolean | HealthLog$studentArgs<ExtArgs>
  }, ExtArgs["result"]["healthLog"]>

  export type HealthLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    notes?: boolean
    parentNotified?: boolean
    medicationAdministered?: boolean
    recordedBy?: boolean
    student?: boolean | HealthLog$studentArgs<ExtArgs>
  }, ExtArgs["result"]["healthLog"]>

  export type HealthLogSelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    notes?: boolean
    parentNotified?: boolean
    medicationAdministered?: boolean
    recordedBy?: boolean
  }

  export type HealthLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | HealthLog$studentArgs<ExtArgs>
  }
  export type HealthLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | HealthLog$studentArgs<ExtArgs>
  }

  export type $HealthLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthLog"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number | null
      date: Date
      time: string | null
      reason: string
      notes: string | null
      parentNotified: boolean | null
      medicationAdministered: Prisma.JsonValue | null
      recordedBy: string | null
    }, ExtArgs["result"]["healthLog"]>
    composites: {}
  }

  type HealthLogGetPayload<S extends boolean | null | undefined | HealthLogDefaultArgs> = $Result.GetResult<Prisma.$HealthLogPayload, S>

  type HealthLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthLogCountAggregateInputType | true
    }

  export interface HealthLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthLog'], meta: { name: 'HealthLog' } }
    /**
     * Find zero or one HealthLog that matches the filter.
     * @param {HealthLogFindUniqueArgs} args - Arguments to find a HealthLog
     * @example
     * // Get one HealthLog
     * const healthLog = await prisma.healthLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthLogFindUniqueArgs>(args: SelectSubset<T, HealthLogFindUniqueArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthLogFindUniqueOrThrowArgs} args - Arguments to find a HealthLog
     * @example
     * // Get one HealthLog
     * const healthLog = await prisma.healthLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthLogFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogFindFirstArgs} args - Arguments to find a HealthLog
     * @example
     * // Get one HealthLog
     * const healthLog = await prisma.healthLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthLogFindFirstArgs>(args?: SelectSubset<T, HealthLogFindFirstArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogFindFirstOrThrowArgs} args - Arguments to find a HealthLog
     * @example
     * // Get one HealthLog
     * const healthLog = await prisma.healthLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthLogFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthLogs
     * const healthLogs = await prisma.healthLog.findMany()
     * 
     * // Get first 10 HealthLogs
     * const healthLogs = await prisma.healthLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthLogWithIdOnly = await prisma.healthLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthLogFindManyArgs>(args?: SelectSubset<T, HealthLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthLog.
     * @param {HealthLogCreateArgs} args - Arguments to create a HealthLog.
     * @example
     * // Create one HealthLog
     * const HealthLog = await prisma.healthLog.create({
     *   data: {
     *     // ... data to create a HealthLog
     *   }
     * })
     * 
     */
    create<T extends HealthLogCreateArgs>(args: SelectSubset<T, HealthLogCreateArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthLogs.
     * @param {HealthLogCreateManyArgs} args - Arguments to create many HealthLogs.
     * @example
     * // Create many HealthLogs
     * const healthLog = await prisma.healthLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthLogCreateManyArgs>(args?: SelectSubset<T, HealthLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthLogs and returns the data saved in the database.
     * @param {HealthLogCreateManyAndReturnArgs} args - Arguments to create many HealthLogs.
     * @example
     * // Create many HealthLogs
     * const healthLog = await prisma.healthLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthLogs and only return the `id`
     * const healthLogWithIdOnly = await prisma.healthLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthLogCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthLog.
     * @param {HealthLogDeleteArgs} args - Arguments to delete one HealthLog.
     * @example
     * // Delete one HealthLog
     * const HealthLog = await prisma.healthLog.delete({
     *   where: {
     *     // ... filter to delete one HealthLog
     *   }
     * })
     * 
     */
    delete<T extends HealthLogDeleteArgs>(args: SelectSubset<T, HealthLogDeleteArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthLog.
     * @param {HealthLogUpdateArgs} args - Arguments to update one HealthLog.
     * @example
     * // Update one HealthLog
     * const healthLog = await prisma.healthLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthLogUpdateArgs>(args: SelectSubset<T, HealthLogUpdateArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthLogs.
     * @param {HealthLogDeleteManyArgs} args - Arguments to filter HealthLogs to delete.
     * @example
     * // Delete a few HealthLogs
     * const { count } = await prisma.healthLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthLogDeleteManyArgs>(args?: SelectSubset<T, HealthLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthLogs
     * const healthLog = await prisma.healthLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthLogUpdateManyArgs>(args: SelectSubset<T, HealthLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthLog.
     * @param {HealthLogUpsertArgs} args - Arguments to update or create a HealthLog.
     * @example
     * // Update or create a HealthLog
     * const healthLog = await prisma.healthLog.upsert({
     *   create: {
     *     // ... data to create a HealthLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthLog we want to update
     *   }
     * })
     */
    upsert<T extends HealthLogUpsertArgs>(args: SelectSubset<T, HealthLogUpsertArgs<ExtArgs>>): Prisma__HealthLogClient<$Result.GetResult<Prisma.$HealthLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogCountArgs} args - Arguments to filter HealthLogs to count.
     * @example
     * // Count the number of HealthLogs
     * const count = await prisma.healthLog.count({
     *   where: {
     *     // ... the filter for the HealthLogs we want to count
     *   }
     * })
    **/
    count<T extends HealthLogCountArgs>(
      args?: Subset<T, HealthLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthLogAggregateArgs>(args: Subset<T, HealthLogAggregateArgs>): Prisma.PrismaPromise<GetHealthLogAggregateType<T>>

    /**
     * Group by HealthLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthLogGroupByArgs['orderBy'] }
        : { orderBy?: HealthLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthLog model
   */
  readonly fields: HealthLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends HealthLog$studentArgs<ExtArgs> = {}>(args?: Subset<T, HealthLog$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthLog model
   */ 
  interface HealthLogFieldRefs {
    readonly id: FieldRef<"HealthLog", 'Int'>
    readonly studentId: FieldRef<"HealthLog", 'Int'>
    readonly date: FieldRef<"HealthLog", 'DateTime'>
    readonly time: FieldRef<"HealthLog", 'String'>
    readonly reason: FieldRef<"HealthLog", 'String'>
    readonly notes: FieldRef<"HealthLog", 'String'>
    readonly parentNotified: FieldRef<"HealthLog", 'Boolean'>
    readonly medicationAdministered: FieldRef<"HealthLog", 'Json'>
    readonly recordedBy: FieldRef<"HealthLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HealthLog findUnique
   */
  export type HealthLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter, which HealthLog to fetch.
     */
    where: HealthLogWhereUniqueInput
  }

  /**
   * HealthLog findUniqueOrThrow
   */
  export type HealthLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter, which HealthLog to fetch.
     */
    where: HealthLogWhereUniqueInput
  }

  /**
   * HealthLog findFirst
   */
  export type HealthLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter, which HealthLog to fetch.
     */
    where?: HealthLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthLogs to fetch.
     */
    orderBy?: HealthLogOrderByWithRelationInput | HealthLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthLogs.
     */
    cursor?: HealthLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthLogs.
     */
    distinct?: HealthLogScalarFieldEnum | HealthLogScalarFieldEnum[]
  }

  /**
   * HealthLog findFirstOrThrow
   */
  export type HealthLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter, which HealthLog to fetch.
     */
    where?: HealthLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthLogs to fetch.
     */
    orderBy?: HealthLogOrderByWithRelationInput | HealthLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthLogs.
     */
    cursor?: HealthLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthLogs.
     */
    distinct?: HealthLogScalarFieldEnum | HealthLogScalarFieldEnum[]
  }

  /**
   * HealthLog findMany
   */
  export type HealthLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter, which HealthLogs to fetch.
     */
    where?: HealthLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthLogs to fetch.
     */
    orderBy?: HealthLogOrderByWithRelationInput | HealthLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthLogs.
     */
    cursor?: HealthLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthLogs.
     */
    skip?: number
    distinct?: HealthLogScalarFieldEnum | HealthLogScalarFieldEnum[]
  }

  /**
   * HealthLog create
   */
  export type HealthLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthLog.
     */
    data: XOR<HealthLogCreateInput, HealthLogUncheckedCreateInput>
  }

  /**
   * HealthLog createMany
   */
  export type HealthLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthLogs.
     */
    data: HealthLogCreateManyInput | HealthLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthLog createManyAndReturn
   */
  export type HealthLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthLogs.
     */
    data: HealthLogCreateManyInput | HealthLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthLog update
   */
  export type HealthLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthLog.
     */
    data: XOR<HealthLogUpdateInput, HealthLogUncheckedUpdateInput>
    /**
     * Choose, which HealthLog to update.
     */
    where: HealthLogWhereUniqueInput
  }

  /**
   * HealthLog updateMany
   */
  export type HealthLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthLogs.
     */
    data: XOR<HealthLogUpdateManyMutationInput, HealthLogUncheckedUpdateManyInput>
    /**
     * Filter which HealthLogs to update
     */
    where?: HealthLogWhereInput
  }

  /**
   * HealthLog upsert
   */
  export type HealthLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthLog to update in case it exists.
     */
    where: HealthLogWhereUniqueInput
    /**
     * In case the HealthLog found by the `where` argument doesn't exist, create a new HealthLog with this data.
     */
    create: XOR<HealthLogCreateInput, HealthLogUncheckedCreateInput>
    /**
     * In case the HealthLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthLogUpdateInput, HealthLogUncheckedUpdateInput>
  }

  /**
   * HealthLog delete
   */
  export type HealthLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
    /**
     * Filter which HealthLog to delete.
     */
    where: HealthLogWhereUniqueInput
  }

  /**
   * HealthLog deleteMany
   */
  export type HealthLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthLogs to delete
     */
    where?: HealthLogWhereInput
  }

  /**
   * HealthLog.student
   */
  export type HealthLog$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * HealthLog without action
   */
  export type HealthLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthLog
     */
    select?: HealthLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthLogInclude<ExtArgs> | null
  }


  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    id: number | null
  }

  export type BookSumAggregateOutputType = {
    id: number | null
  }

  export type BookMinAggregateOutputType = {
    id: number | null
    title: string | null
    author: string | null
    coverUrl: string | null
    category: string | null
    status: string | null
  }

  export type BookMaxAggregateOutputType = {
    id: number | null
    title: string | null
    author: string | null
    coverUrl: string | null
    category: string | null
    status: string | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    title: number
    author: number
    coverUrl: number
    category: number
    status: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    id?: true
  }

  export type BookSumAggregateInputType = {
    id?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    category?: true
    status?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    category?: true
    status?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    coverUrl?: true
    category?: true
    status?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: number
    title: string
    author: string
    coverUrl: string | null
    category: string
    status: string | null
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    category?: boolean
    status?: boolean
  }, ExtArgs["result"]["book"]>

  export type BookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    category?: boolean
    status?: boolean
  }, ExtArgs["result"]["book"]>

  export type BookSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    coverUrl?: boolean
    category?: boolean
    status?: boolean
  }


  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      author: string
      coverUrl: string | null
      category: string
      status: string | null
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */ 
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'Int'>
    readonly title: FieldRef<"Book", 'String'>
    readonly author: FieldRef<"Book", 'String'>
    readonly coverUrl: FieldRef<"Book", 'String'>
    readonly category: FieldRef<"Book", 'String'>
    readonly status: FieldRef<"Book", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book createManyAndReturn
   */
  export type BookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
  }


  /**
   * Model DigitalResource
   */

  export type AggregateDigitalResource = {
    _count: DigitalResourceCountAggregateOutputType | null
    _avg: DigitalResourceAvgAggregateOutputType | null
    _sum: DigitalResourceSumAggregateOutputType | null
    _min: DigitalResourceMinAggregateOutputType | null
    _max: DigitalResourceMaxAggregateOutputType | null
  }

  export type DigitalResourceAvgAggregateOutputType = {
    id: number | null
  }

  export type DigitalResourceSumAggregateOutputType = {
    id: number | null
  }

  export type DigitalResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    subject: string | null
    description: string | null
    url: string | null
    thumbnailUrl: string | null
  }

  export type DigitalResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    subject: string | null
    description: string | null
    url: string | null
    thumbnailUrl: string | null
  }

  export type DigitalResourceCountAggregateOutputType = {
    id: number
    title: number
    type: number
    subject: number
    description: number
    url: number
    thumbnailUrl: number
    _all: number
  }


  export type DigitalResourceAvgAggregateInputType = {
    id?: true
  }

  export type DigitalResourceSumAggregateInputType = {
    id?: true
  }

  export type DigitalResourceMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    subject?: true
    description?: true
    url?: true
    thumbnailUrl?: true
  }

  export type DigitalResourceMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    subject?: true
    description?: true
    url?: true
    thumbnailUrl?: true
  }

  export type DigitalResourceCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    subject?: true
    description?: true
    url?: true
    thumbnailUrl?: true
    _all?: true
  }

  export type DigitalResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalResource to aggregate.
     */
    where?: DigitalResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalResources to fetch.
     */
    orderBy?: DigitalResourceOrderByWithRelationInput | DigitalResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DigitalResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DigitalResources
    **/
    _count?: true | DigitalResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DigitalResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DigitalResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DigitalResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DigitalResourceMaxAggregateInputType
  }

  export type GetDigitalResourceAggregateType<T extends DigitalResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateDigitalResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDigitalResource[P]>
      : GetScalarType<T[P], AggregateDigitalResource[P]>
  }




  export type DigitalResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DigitalResourceWhereInput
    orderBy?: DigitalResourceOrderByWithAggregationInput | DigitalResourceOrderByWithAggregationInput[]
    by: DigitalResourceScalarFieldEnum[] | DigitalResourceScalarFieldEnum
    having?: DigitalResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DigitalResourceCountAggregateInputType | true
    _avg?: DigitalResourceAvgAggregateInputType
    _sum?: DigitalResourceSumAggregateInputType
    _min?: DigitalResourceMinAggregateInputType
    _max?: DigitalResourceMaxAggregateInputType
  }

  export type DigitalResourceGroupByOutputType = {
    id: number
    title: string
    type: string
    subject: string | null
    description: string | null
    url: string
    thumbnailUrl: string | null
    _count: DigitalResourceCountAggregateOutputType | null
    _avg: DigitalResourceAvgAggregateOutputType | null
    _sum: DigitalResourceSumAggregateOutputType | null
    _min: DigitalResourceMinAggregateOutputType | null
    _max: DigitalResourceMaxAggregateOutputType | null
  }

  type GetDigitalResourceGroupByPayload<T extends DigitalResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DigitalResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DigitalResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DigitalResourceGroupByOutputType[P]>
            : GetScalarType<T[P], DigitalResourceGroupByOutputType[P]>
        }
      >
    >


  export type DigitalResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
  }, ExtArgs["result"]["digitalResource"]>

  export type DigitalResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
  }, ExtArgs["result"]["digitalResource"]>

  export type DigitalResourceSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    subject?: boolean
    description?: boolean
    url?: boolean
    thumbnailUrl?: boolean
  }


  export type $DigitalResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DigitalResource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: string
      subject: string | null
      description: string | null
      url: string
      thumbnailUrl: string | null
    }, ExtArgs["result"]["digitalResource"]>
    composites: {}
  }

  type DigitalResourceGetPayload<S extends boolean | null | undefined | DigitalResourceDefaultArgs> = $Result.GetResult<Prisma.$DigitalResourcePayload, S>

  type DigitalResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DigitalResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DigitalResourceCountAggregateInputType | true
    }

  export interface DigitalResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DigitalResource'], meta: { name: 'DigitalResource' } }
    /**
     * Find zero or one DigitalResource that matches the filter.
     * @param {DigitalResourceFindUniqueArgs} args - Arguments to find a DigitalResource
     * @example
     * // Get one DigitalResource
     * const digitalResource = await prisma.digitalResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DigitalResourceFindUniqueArgs>(args: SelectSubset<T, DigitalResourceFindUniqueArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DigitalResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DigitalResourceFindUniqueOrThrowArgs} args - Arguments to find a DigitalResource
     * @example
     * // Get one DigitalResource
     * const digitalResource = await prisma.digitalResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DigitalResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, DigitalResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DigitalResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceFindFirstArgs} args - Arguments to find a DigitalResource
     * @example
     * // Get one DigitalResource
     * const digitalResource = await prisma.digitalResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DigitalResourceFindFirstArgs>(args?: SelectSubset<T, DigitalResourceFindFirstArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DigitalResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceFindFirstOrThrowArgs} args - Arguments to find a DigitalResource
     * @example
     * // Get one DigitalResource
     * const digitalResource = await prisma.digitalResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DigitalResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, DigitalResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DigitalResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DigitalResources
     * const digitalResources = await prisma.digitalResource.findMany()
     * 
     * // Get first 10 DigitalResources
     * const digitalResources = await prisma.digitalResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const digitalResourceWithIdOnly = await prisma.digitalResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DigitalResourceFindManyArgs>(args?: SelectSubset<T, DigitalResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DigitalResource.
     * @param {DigitalResourceCreateArgs} args - Arguments to create a DigitalResource.
     * @example
     * // Create one DigitalResource
     * const DigitalResource = await prisma.digitalResource.create({
     *   data: {
     *     // ... data to create a DigitalResource
     *   }
     * })
     * 
     */
    create<T extends DigitalResourceCreateArgs>(args: SelectSubset<T, DigitalResourceCreateArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DigitalResources.
     * @param {DigitalResourceCreateManyArgs} args - Arguments to create many DigitalResources.
     * @example
     * // Create many DigitalResources
     * const digitalResource = await prisma.digitalResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DigitalResourceCreateManyArgs>(args?: SelectSubset<T, DigitalResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DigitalResources and returns the data saved in the database.
     * @param {DigitalResourceCreateManyAndReturnArgs} args - Arguments to create many DigitalResources.
     * @example
     * // Create many DigitalResources
     * const digitalResource = await prisma.digitalResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DigitalResources and only return the `id`
     * const digitalResourceWithIdOnly = await prisma.digitalResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DigitalResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, DigitalResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DigitalResource.
     * @param {DigitalResourceDeleteArgs} args - Arguments to delete one DigitalResource.
     * @example
     * // Delete one DigitalResource
     * const DigitalResource = await prisma.digitalResource.delete({
     *   where: {
     *     // ... filter to delete one DigitalResource
     *   }
     * })
     * 
     */
    delete<T extends DigitalResourceDeleteArgs>(args: SelectSubset<T, DigitalResourceDeleteArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DigitalResource.
     * @param {DigitalResourceUpdateArgs} args - Arguments to update one DigitalResource.
     * @example
     * // Update one DigitalResource
     * const digitalResource = await prisma.digitalResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DigitalResourceUpdateArgs>(args: SelectSubset<T, DigitalResourceUpdateArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DigitalResources.
     * @param {DigitalResourceDeleteManyArgs} args - Arguments to filter DigitalResources to delete.
     * @example
     * // Delete a few DigitalResources
     * const { count } = await prisma.digitalResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DigitalResourceDeleteManyArgs>(args?: SelectSubset<T, DigitalResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DigitalResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DigitalResources
     * const digitalResource = await prisma.digitalResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DigitalResourceUpdateManyArgs>(args: SelectSubset<T, DigitalResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DigitalResource.
     * @param {DigitalResourceUpsertArgs} args - Arguments to update or create a DigitalResource.
     * @example
     * // Update or create a DigitalResource
     * const digitalResource = await prisma.digitalResource.upsert({
     *   create: {
     *     // ... data to create a DigitalResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DigitalResource we want to update
     *   }
     * })
     */
    upsert<T extends DigitalResourceUpsertArgs>(args: SelectSubset<T, DigitalResourceUpsertArgs<ExtArgs>>): Prisma__DigitalResourceClient<$Result.GetResult<Prisma.$DigitalResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DigitalResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceCountArgs} args - Arguments to filter DigitalResources to count.
     * @example
     * // Count the number of DigitalResources
     * const count = await prisma.digitalResource.count({
     *   where: {
     *     // ... the filter for the DigitalResources we want to count
     *   }
     * })
    **/
    count<T extends DigitalResourceCountArgs>(
      args?: Subset<T, DigitalResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DigitalResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DigitalResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DigitalResourceAggregateArgs>(args: Subset<T, DigitalResourceAggregateArgs>): Prisma.PrismaPromise<GetDigitalResourceAggregateType<T>>

    /**
     * Group by DigitalResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DigitalResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DigitalResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DigitalResourceGroupByArgs['orderBy'] }
        : { orderBy?: DigitalResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DigitalResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDigitalResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DigitalResource model
   */
  readonly fields: DigitalResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DigitalResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DigitalResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DigitalResource model
   */ 
  interface DigitalResourceFieldRefs {
    readonly id: FieldRef<"DigitalResource", 'Int'>
    readonly title: FieldRef<"DigitalResource", 'String'>
    readonly type: FieldRef<"DigitalResource", 'String'>
    readonly subject: FieldRef<"DigitalResource", 'String'>
    readonly description: FieldRef<"DigitalResource", 'String'>
    readonly url: FieldRef<"DigitalResource", 'String'>
    readonly thumbnailUrl: FieldRef<"DigitalResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DigitalResource findUnique
   */
  export type DigitalResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter, which DigitalResource to fetch.
     */
    where: DigitalResourceWhereUniqueInput
  }

  /**
   * DigitalResource findUniqueOrThrow
   */
  export type DigitalResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter, which DigitalResource to fetch.
     */
    where: DigitalResourceWhereUniqueInput
  }

  /**
   * DigitalResource findFirst
   */
  export type DigitalResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter, which DigitalResource to fetch.
     */
    where?: DigitalResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalResources to fetch.
     */
    orderBy?: DigitalResourceOrderByWithRelationInput | DigitalResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalResources.
     */
    cursor?: DigitalResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalResources.
     */
    distinct?: DigitalResourceScalarFieldEnum | DigitalResourceScalarFieldEnum[]
  }

  /**
   * DigitalResource findFirstOrThrow
   */
  export type DigitalResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter, which DigitalResource to fetch.
     */
    where?: DigitalResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalResources to fetch.
     */
    orderBy?: DigitalResourceOrderByWithRelationInput | DigitalResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DigitalResources.
     */
    cursor?: DigitalResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DigitalResources.
     */
    distinct?: DigitalResourceScalarFieldEnum | DigitalResourceScalarFieldEnum[]
  }

  /**
   * DigitalResource findMany
   */
  export type DigitalResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter, which DigitalResources to fetch.
     */
    where?: DigitalResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DigitalResources to fetch.
     */
    orderBy?: DigitalResourceOrderByWithRelationInput | DigitalResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DigitalResources.
     */
    cursor?: DigitalResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DigitalResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DigitalResources.
     */
    skip?: number
    distinct?: DigitalResourceScalarFieldEnum | DigitalResourceScalarFieldEnum[]
  }

  /**
   * DigitalResource create
   */
  export type DigitalResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * The data needed to create a DigitalResource.
     */
    data: XOR<DigitalResourceCreateInput, DigitalResourceUncheckedCreateInput>
  }

  /**
   * DigitalResource createMany
   */
  export type DigitalResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DigitalResources.
     */
    data: DigitalResourceCreateManyInput | DigitalResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalResource createManyAndReturn
   */
  export type DigitalResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DigitalResources.
     */
    data: DigitalResourceCreateManyInput | DigitalResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DigitalResource update
   */
  export type DigitalResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * The data needed to update a DigitalResource.
     */
    data: XOR<DigitalResourceUpdateInput, DigitalResourceUncheckedUpdateInput>
    /**
     * Choose, which DigitalResource to update.
     */
    where: DigitalResourceWhereUniqueInput
  }

  /**
   * DigitalResource updateMany
   */
  export type DigitalResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DigitalResources.
     */
    data: XOR<DigitalResourceUpdateManyMutationInput, DigitalResourceUncheckedUpdateManyInput>
    /**
     * Filter which DigitalResources to update
     */
    where?: DigitalResourceWhereInput
  }

  /**
   * DigitalResource upsert
   */
  export type DigitalResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * The filter to search for the DigitalResource to update in case it exists.
     */
    where: DigitalResourceWhereUniqueInput
    /**
     * In case the DigitalResource found by the `where` argument doesn't exist, create a new DigitalResource with this data.
     */
    create: XOR<DigitalResourceCreateInput, DigitalResourceUncheckedCreateInput>
    /**
     * In case the DigitalResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DigitalResourceUpdateInput, DigitalResourceUncheckedUpdateInput>
  }

  /**
   * DigitalResource delete
   */
  export type DigitalResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
    /**
     * Filter which DigitalResource to delete.
     */
    where: DigitalResourceWhereUniqueInput
  }

  /**
   * DigitalResource deleteMany
   */
  export type DigitalResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DigitalResources to delete
     */
    where?: DigitalResourceWhereInput
  }

  /**
   * DigitalResource without action
   */
  export type DigitalResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DigitalResource
     */
    select?: DigitalResourceSelect<ExtArgs> | null
  }


  /**
   * Model CbtTest
   */

  export type AggregateCbtTest = {
    _count: CbtTestCountAggregateOutputType | null
    _avg: CbtTestAvgAggregateOutputType | null
    _sum: CbtTestSumAggregateOutputType | null
    _min: CbtTestMinAggregateOutputType | null
    _max: CbtTestMaxAggregateOutputType | null
  }

  export type CbtTestAvgAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
  }

  export type CbtTestSumAggregateOutputType = {
    id: number | null
    durationMinutes: number | null
  }

  export type CbtTestMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    className: string | null
    subject: string | null
    durationMinutes: number | null
    isPublished: boolean | null
    createdAt: Date | null
  }

  export type CbtTestMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    className: string | null
    subject: string | null
    durationMinutes: number | null
    isPublished: boolean | null
    createdAt: Date | null
  }

  export type CbtTestCountAggregateOutputType = {
    id: number
    title: number
    type: number
    className: number
    subject: number
    durationMinutes: number
    isPublished: number
    createdAt: number
    _all: number
  }


  export type CbtTestAvgAggregateInputType = {
    id?: true
    durationMinutes?: true
  }

  export type CbtTestSumAggregateInputType = {
    id?: true
    durationMinutes?: true
  }

  export type CbtTestMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    className?: true
    subject?: true
    durationMinutes?: true
    isPublished?: true
    createdAt?: true
  }

  export type CbtTestMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    className?: true
    subject?: true
    durationMinutes?: true
    isPublished?: true
    createdAt?: true
  }

  export type CbtTestCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    className?: true
    subject?: true
    durationMinutes?: true
    isPublished?: true
    createdAt?: true
    _all?: true
  }

  export type CbtTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtTest to aggregate.
     */
    where?: CbtTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtTests to fetch.
     */
    orderBy?: CbtTestOrderByWithRelationInput | CbtTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CbtTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CbtTests
    **/
    _count?: true | CbtTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CbtTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CbtTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CbtTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CbtTestMaxAggregateInputType
  }

  export type GetCbtTestAggregateType<T extends CbtTestAggregateArgs> = {
        [P in keyof T & keyof AggregateCbtTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCbtTest[P]>
      : GetScalarType<T[P], AggregateCbtTest[P]>
  }




  export type CbtTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtTestWhereInput
    orderBy?: CbtTestOrderByWithAggregationInput | CbtTestOrderByWithAggregationInput[]
    by: CbtTestScalarFieldEnum[] | CbtTestScalarFieldEnum
    having?: CbtTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CbtTestCountAggregateInputType | true
    _avg?: CbtTestAvgAggregateInputType
    _sum?: CbtTestSumAggregateInputType
    _min?: CbtTestMinAggregateInputType
    _max?: CbtTestMaxAggregateInputType
  }

  export type CbtTestGroupByOutputType = {
    id: number
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished: boolean | null
    createdAt: Date
    _count: CbtTestCountAggregateOutputType | null
    _avg: CbtTestAvgAggregateOutputType | null
    _sum: CbtTestSumAggregateOutputType | null
    _min: CbtTestMinAggregateOutputType | null
    _max: CbtTestMaxAggregateOutputType | null
  }

  type GetCbtTestGroupByPayload<T extends CbtTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CbtTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CbtTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CbtTestGroupByOutputType[P]>
            : GetScalarType<T[P], CbtTestGroupByOutputType[P]>
        }
      >
    >


  export type CbtTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    className?: boolean
    subject?: boolean
    durationMinutes?: boolean
    isPublished?: boolean
    createdAt?: boolean
    questions?: boolean | CbtTest$questionsArgs<ExtArgs>
    results?: boolean | CbtTest$resultsArgs<ExtArgs>
    _count?: boolean | CbtTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cbtTest"]>

  export type CbtTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    className?: boolean
    subject?: boolean
    durationMinutes?: boolean
    isPublished?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["cbtTest"]>

  export type CbtTestSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    className?: boolean
    subject?: boolean
    durationMinutes?: boolean
    isPublished?: boolean
    createdAt?: boolean
  }

  export type CbtTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CbtTest$questionsArgs<ExtArgs>
    results?: boolean | CbtTest$resultsArgs<ExtArgs>
    _count?: boolean | CbtTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CbtTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CbtTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CbtTest"
    objects: {
      questions: Prisma.$CbtQuestionPayload<ExtArgs>[]
      results: Prisma.$CbtResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: string
      className: string
      subject: string
      durationMinutes: number
      isPublished: boolean | null
      createdAt: Date
    }, ExtArgs["result"]["cbtTest"]>
    composites: {}
  }

  type CbtTestGetPayload<S extends boolean | null | undefined | CbtTestDefaultArgs> = $Result.GetResult<Prisma.$CbtTestPayload, S>

  type CbtTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CbtTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CbtTestCountAggregateInputType | true
    }

  export interface CbtTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CbtTest'], meta: { name: 'CbtTest' } }
    /**
     * Find zero or one CbtTest that matches the filter.
     * @param {CbtTestFindUniqueArgs} args - Arguments to find a CbtTest
     * @example
     * // Get one CbtTest
     * const cbtTest = await prisma.cbtTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CbtTestFindUniqueArgs>(args: SelectSubset<T, CbtTestFindUniqueArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CbtTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CbtTestFindUniqueOrThrowArgs} args - Arguments to find a CbtTest
     * @example
     * // Get one CbtTest
     * const cbtTest = await prisma.cbtTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CbtTestFindUniqueOrThrowArgs>(args: SelectSubset<T, CbtTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CbtTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestFindFirstArgs} args - Arguments to find a CbtTest
     * @example
     * // Get one CbtTest
     * const cbtTest = await prisma.cbtTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CbtTestFindFirstArgs>(args?: SelectSubset<T, CbtTestFindFirstArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CbtTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestFindFirstOrThrowArgs} args - Arguments to find a CbtTest
     * @example
     * // Get one CbtTest
     * const cbtTest = await prisma.cbtTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CbtTestFindFirstOrThrowArgs>(args?: SelectSubset<T, CbtTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CbtTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CbtTests
     * const cbtTests = await prisma.cbtTest.findMany()
     * 
     * // Get first 10 CbtTests
     * const cbtTests = await prisma.cbtTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cbtTestWithIdOnly = await prisma.cbtTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CbtTestFindManyArgs>(args?: SelectSubset<T, CbtTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CbtTest.
     * @param {CbtTestCreateArgs} args - Arguments to create a CbtTest.
     * @example
     * // Create one CbtTest
     * const CbtTest = await prisma.cbtTest.create({
     *   data: {
     *     // ... data to create a CbtTest
     *   }
     * })
     * 
     */
    create<T extends CbtTestCreateArgs>(args: SelectSubset<T, CbtTestCreateArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CbtTests.
     * @param {CbtTestCreateManyArgs} args - Arguments to create many CbtTests.
     * @example
     * // Create many CbtTests
     * const cbtTest = await prisma.cbtTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CbtTestCreateManyArgs>(args?: SelectSubset<T, CbtTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CbtTests and returns the data saved in the database.
     * @param {CbtTestCreateManyAndReturnArgs} args - Arguments to create many CbtTests.
     * @example
     * // Create many CbtTests
     * const cbtTest = await prisma.cbtTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CbtTests and only return the `id`
     * const cbtTestWithIdOnly = await prisma.cbtTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CbtTestCreateManyAndReturnArgs>(args?: SelectSubset<T, CbtTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CbtTest.
     * @param {CbtTestDeleteArgs} args - Arguments to delete one CbtTest.
     * @example
     * // Delete one CbtTest
     * const CbtTest = await prisma.cbtTest.delete({
     *   where: {
     *     // ... filter to delete one CbtTest
     *   }
     * })
     * 
     */
    delete<T extends CbtTestDeleteArgs>(args: SelectSubset<T, CbtTestDeleteArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CbtTest.
     * @param {CbtTestUpdateArgs} args - Arguments to update one CbtTest.
     * @example
     * // Update one CbtTest
     * const cbtTest = await prisma.cbtTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CbtTestUpdateArgs>(args: SelectSubset<T, CbtTestUpdateArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CbtTests.
     * @param {CbtTestDeleteManyArgs} args - Arguments to filter CbtTests to delete.
     * @example
     * // Delete a few CbtTests
     * const { count } = await prisma.cbtTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CbtTestDeleteManyArgs>(args?: SelectSubset<T, CbtTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CbtTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CbtTests
     * const cbtTest = await prisma.cbtTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CbtTestUpdateManyArgs>(args: SelectSubset<T, CbtTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CbtTest.
     * @param {CbtTestUpsertArgs} args - Arguments to update or create a CbtTest.
     * @example
     * // Update or create a CbtTest
     * const cbtTest = await prisma.cbtTest.upsert({
     *   create: {
     *     // ... data to create a CbtTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CbtTest we want to update
     *   }
     * })
     */
    upsert<T extends CbtTestUpsertArgs>(args: SelectSubset<T, CbtTestUpsertArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CbtTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestCountArgs} args - Arguments to filter CbtTests to count.
     * @example
     * // Count the number of CbtTests
     * const count = await prisma.cbtTest.count({
     *   where: {
     *     // ... the filter for the CbtTests we want to count
     *   }
     * })
    **/
    count<T extends CbtTestCountArgs>(
      args?: Subset<T, CbtTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CbtTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CbtTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CbtTestAggregateArgs>(args: Subset<T, CbtTestAggregateArgs>): Prisma.PrismaPromise<GetCbtTestAggregateType<T>>

    /**
     * Group by CbtTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CbtTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CbtTestGroupByArgs['orderBy'] }
        : { orderBy?: CbtTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CbtTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCbtTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CbtTest model
   */
  readonly fields: CbtTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CbtTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CbtTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends CbtTest$questionsArgs<ExtArgs> = {}>(args?: Subset<T, CbtTest$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findMany"> | Null>
    results<T extends CbtTest$resultsArgs<ExtArgs> = {}>(args?: Subset<T, CbtTest$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CbtTest model
   */ 
  interface CbtTestFieldRefs {
    readonly id: FieldRef<"CbtTest", 'Int'>
    readonly title: FieldRef<"CbtTest", 'String'>
    readonly type: FieldRef<"CbtTest", 'String'>
    readonly className: FieldRef<"CbtTest", 'String'>
    readonly subject: FieldRef<"CbtTest", 'String'>
    readonly durationMinutes: FieldRef<"CbtTest", 'Int'>
    readonly isPublished: FieldRef<"CbtTest", 'Boolean'>
    readonly createdAt: FieldRef<"CbtTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CbtTest findUnique
   */
  export type CbtTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter, which CbtTest to fetch.
     */
    where: CbtTestWhereUniqueInput
  }

  /**
   * CbtTest findUniqueOrThrow
   */
  export type CbtTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter, which CbtTest to fetch.
     */
    where: CbtTestWhereUniqueInput
  }

  /**
   * CbtTest findFirst
   */
  export type CbtTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter, which CbtTest to fetch.
     */
    where?: CbtTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtTests to fetch.
     */
    orderBy?: CbtTestOrderByWithRelationInput | CbtTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtTests.
     */
    cursor?: CbtTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtTests.
     */
    distinct?: CbtTestScalarFieldEnum | CbtTestScalarFieldEnum[]
  }

  /**
   * CbtTest findFirstOrThrow
   */
  export type CbtTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter, which CbtTest to fetch.
     */
    where?: CbtTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtTests to fetch.
     */
    orderBy?: CbtTestOrderByWithRelationInput | CbtTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtTests.
     */
    cursor?: CbtTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtTests.
     */
    distinct?: CbtTestScalarFieldEnum | CbtTestScalarFieldEnum[]
  }

  /**
   * CbtTest findMany
   */
  export type CbtTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter, which CbtTests to fetch.
     */
    where?: CbtTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtTests to fetch.
     */
    orderBy?: CbtTestOrderByWithRelationInput | CbtTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CbtTests.
     */
    cursor?: CbtTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtTests.
     */
    skip?: number
    distinct?: CbtTestScalarFieldEnum | CbtTestScalarFieldEnum[]
  }

  /**
   * CbtTest create
   */
  export type CbtTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * The data needed to create a CbtTest.
     */
    data: XOR<CbtTestCreateInput, CbtTestUncheckedCreateInput>
  }

  /**
   * CbtTest createMany
   */
  export type CbtTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CbtTests.
     */
    data: CbtTestCreateManyInput | CbtTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CbtTest createManyAndReturn
   */
  export type CbtTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CbtTests.
     */
    data: CbtTestCreateManyInput | CbtTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CbtTest update
   */
  export type CbtTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * The data needed to update a CbtTest.
     */
    data: XOR<CbtTestUpdateInput, CbtTestUncheckedUpdateInput>
    /**
     * Choose, which CbtTest to update.
     */
    where: CbtTestWhereUniqueInput
  }

  /**
   * CbtTest updateMany
   */
  export type CbtTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CbtTests.
     */
    data: XOR<CbtTestUpdateManyMutationInput, CbtTestUncheckedUpdateManyInput>
    /**
     * Filter which CbtTests to update
     */
    where?: CbtTestWhereInput
  }

  /**
   * CbtTest upsert
   */
  export type CbtTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * The filter to search for the CbtTest to update in case it exists.
     */
    where: CbtTestWhereUniqueInput
    /**
     * In case the CbtTest found by the `where` argument doesn't exist, create a new CbtTest with this data.
     */
    create: XOR<CbtTestCreateInput, CbtTestUncheckedCreateInput>
    /**
     * In case the CbtTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CbtTestUpdateInput, CbtTestUncheckedUpdateInput>
  }

  /**
   * CbtTest delete
   */
  export type CbtTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
    /**
     * Filter which CbtTest to delete.
     */
    where: CbtTestWhereUniqueInput
  }

  /**
   * CbtTest deleteMany
   */
  export type CbtTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtTests to delete
     */
    where?: CbtTestWhereInput
  }

  /**
   * CbtTest.questions
   */
  export type CbtTest$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    where?: CbtQuestionWhereInput
    orderBy?: CbtQuestionOrderByWithRelationInput | CbtQuestionOrderByWithRelationInput[]
    cursor?: CbtQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CbtQuestionScalarFieldEnum | CbtQuestionScalarFieldEnum[]
  }

  /**
   * CbtTest.results
   */
  export type CbtTest$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    where?: CbtResultWhereInput
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    cursor?: CbtResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CbtResultScalarFieldEnum | CbtResultScalarFieldEnum[]
  }

  /**
   * CbtTest without action
   */
  export type CbtTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtTest
     */
    select?: CbtTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtTestInclude<ExtArgs> | null
  }


  /**
   * Model CbtQuestion
   */

  export type AggregateCbtQuestion = {
    _count: CbtQuestionCountAggregateOutputType | null
    _avg: CbtQuestionAvgAggregateOutputType | null
    _sum: CbtQuestionSumAggregateOutputType | null
    _min: CbtQuestionMinAggregateOutputType | null
    _max: CbtQuestionMaxAggregateOutputType | null
  }

  export type CbtQuestionAvgAggregateOutputType = {
    id: number | null
    testId: number | null
  }

  export type CbtQuestionSumAggregateOutputType = {
    id: number | null
    testId: number | null
  }

  export type CbtQuestionMinAggregateOutputType = {
    id: number | null
    testId: number | null
    questionText: string | null
    correctAnswer: string | null
  }

  export type CbtQuestionMaxAggregateOutputType = {
    id: number | null
    testId: number | null
    questionText: string | null
    correctAnswer: string | null
  }

  export type CbtQuestionCountAggregateOutputType = {
    id: number
    testId: number
    questionText: number
    options: number
    correctAnswer: number
    _all: number
  }


  export type CbtQuestionAvgAggregateInputType = {
    id?: true
    testId?: true
  }

  export type CbtQuestionSumAggregateInputType = {
    id?: true
    testId?: true
  }

  export type CbtQuestionMinAggregateInputType = {
    id?: true
    testId?: true
    questionText?: true
    correctAnswer?: true
  }

  export type CbtQuestionMaxAggregateInputType = {
    id?: true
    testId?: true
    questionText?: true
    correctAnswer?: true
  }

  export type CbtQuestionCountAggregateInputType = {
    id?: true
    testId?: true
    questionText?: true
    options?: true
    correctAnswer?: true
    _all?: true
  }

  export type CbtQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtQuestion to aggregate.
     */
    where?: CbtQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtQuestions to fetch.
     */
    orderBy?: CbtQuestionOrderByWithRelationInput | CbtQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CbtQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CbtQuestions
    **/
    _count?: true | CbtQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CbtQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CbtQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CbtQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CbtQuestionMaxAggregateInputType
  }

  export type GetCbtQuestionAggregateType<T extends CbtQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateCbtQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCbtQuestion[P]>
      : GetScalarType<T[P], AggregateCbtQuestion[P]>
  }




  export type CbtQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtQuestionWhereInput
    orderBy?: CbtQuestionOrderByWithAggregationInput | CbtQuestionOrderByWithAggregationInput[]
    by: CbtQuestionScalarFieldEnum[] | CbtQuestionScalarFieldEnum
    having?: CbtQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CbtQuestionCountAggregateInputType | true
    _avg?: CbtQuestionAvgAggregateInputType
    _sum?: CbtQuestionSumAggregateInputType
    _min?: CbtQuestionMinAggregateInputType
    _max?: CbtQuestionMaxAggregateInputType
  }

  export type CbtQuestionGroupByOutputType = {
    id: number
    testId: number
    questionText: string
    options: JsonValue
    correctAnswer: string
    _count: CbtQuestionCountAggregateOutputType | null
    _avg: CbtQuestionAvgAggregateOutputType | null
    _sum: CbtQuestionSumAggregateOutputType | null
    _min: CbtQuestionMinAggregateOutputType | null
    _max: CbtQuestionMaxAggregateOutputType | null
  }

  type GetCbtQuestionGroupByPayload<T extends CbtQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CbtQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CbtQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CbtQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], CbtQuestionGroupByOutputType[P]>
        }
      >
    >


  export type CbtQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cbtQuestion"]>

  export type CbtQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cbtQuestion"]>

  export type CbtQuestionSelectScalar = {
    id?: boolean
    testId?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
  }

  export type CbtQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
  }
  export type CbtQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
  }

  export type $CbtQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CbtQuestion"
    objects: {
      test: Prisma.$CbtTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      testId: number
      questionText: string
      options: Prisma.JsonValue
      correctAnswer: string
    }, ExtArgs["result"]["cbtQuestion"]>
    composites: {}
  }

  type CbtQuestionGetPayload<S extends boolean | null | undefined | CbtQuestionDefaultArgs> = $Result.GetResult<Prisma.$CbtQuestionPayload, S>

  type CbtQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CbtQuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CbtQuestionCountAggregateInputType | true
    }

  export interface CbtQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CbtQuestion'], meta: { name: 'CbtQuestion' } }
    /**
     * Find zero or one CbtQuestion that matches the filter.
     * @param {CbtQuestionFindUniqueArgs} args - Arguments to find a CbtQuestion
     * @example
     * // Get one CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CbtQuestionFindUniqueArgs>(args: SelectSubset<T, CbtQuestionFindUniqueArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CbtQuestion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CbtQuestionFindUniqueOrThrowArgs} args - Arguments to find a CbtQuestion
     * @example
     * // Get one CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CbtQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, CbtQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CbtQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionFindFirstArgs} args - Arguments to find a CbtQuestion
     * @example
     * // Get one CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CbtQuestionFindFirstArgs>(args?: SelectSubset<T, CbtQuestionFindFirstArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CbtQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionFindFirstOrThrowArgs} args - Arguments to find a CbtQuestion
     * @example
     * // Get one CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CbtQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, CbtQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CbtQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CbtQuestions
     * const cbtQuestions = await prisma.cbtQuestion.findMany()
     * 
     * // Get first 10 CbtQuestions
     * const cbtQuestions = await prisma.cbtQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cbtQuestionWithIdOnly = await prisma.cbtQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CbtQuestionFindManyArgs>(args?: SelectSubset<T, CbtQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CbtQuestion.
     * @param {CbtQuestionCreateArgs} args - Arguments to create a CbtQuestion.
     * @example
     * // Create one CbtQuestion
     * const CbtQuestion = await prisma.cbtQuestion.create({
     *   data: {
     *     // ... data to create a CbtQuestion
     *   }
     * })
     * 
     */
    create<T extends CbtQuestionCreateArgs>(args: SelectSubset<T, CbtQuestionCreateArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CbtQuestions.
     * @param {CbtQuestionCreateManyArgs} args - Arguments to create many CbtQuestions.
     * @example
     * // Create many CbtQuestions
     * const cbtQuestion = await prisma.cbtQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CbtQuestionCreateManyArgs>(args?: SelectSubset<T, CbtQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CbtQuestions and returns the data saved in the database.
     * @param {CbtQuestionCreateManyAndReturnArgs} args - Arguments to create many CbtQuestions.
     * @example
     * // Create many CbtQuestions
     * const cbtQuestion = await prisma.cbtQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CbtQuestions and only return the `id`
     * const cbtQuestionWithIdOnly = await prisma.cbtQuestion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CbtQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, CbtQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CbtQuestion.
     * @param {CbtQuestionDeleteArgs} args - Arguments to delete one CbtQuestion.
     * @example
     * // Delete one CbtQuestion
     * const CbtQuestion = await prisma.cbtQuestion.delete({
     *   where: {
     *     // ... filter to delete one CbtQuestion
     *   }
     * })
     * 
     */
    delete<T extends CbtQuestionDeleteArgs>(args: SelectSubset<T, CbtQuestionDeleteArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CbtQuestion.
     * @param {CbtQuestionUpdateArgs} args - Arguments to update one CbtQuestion.
     * @example
     * // Update one CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CbtQuestionUpdateArgs>(args: SelectSubset<T, CbtQuestionUpdateArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CbtQuestions.
     * @param {CbtQuestionDeleteManyArgs} args - Arguments to filter CbtQuestions to delete.
     * @example
     * // Delete a few CbtQuestions
     * const { count } = await prisma.cbtQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CbtQuestionDeleteManyArgs>(args?: SelectSubset<T, CbtQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CbtQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CbtQuestions
     * const cbtQuestion = await prisma.cbtQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CbtQuestionUpdateManyArgs>(args: SelectSubset<T, CbtQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CbtQuestion.
     * @param {CbtQuestionUpsertArgs} args - Arguments to update or create a CbtQuestion.
     * @example
     * // Update or create a CbtQuestion
     * const cbtQuestion = await prisma.cbtQuestion.upsert({
     *   create: {
     *     // ... data to create a CbtQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CbtQuestion we want to update
     *   }
     * })
     */
    upsert<T extends CbtQuestionUpsertArgs>(args: SelectSubset<T, CbtQuestionUpsertArgs<ExtArgs>>): Prisma__CbtQuestionClient<$Result.GetResult<Prisma.$CbtQuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CbtQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionCountArgs} args - Arguments to filter CbtQuestions to count.
     * @example
     * // Count the number of CbtQuestions
     * const count = await prisma.cbtQuestion.count({
     *   where: {
     *     // ... the filter for the CbtQuestions we want to count
     *   }
     * })
    **/
    count<T extends CbtQuestionCountArgs>(
      args?: Subset<T, CbtQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CbtQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CbtQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CbtQuestionAggregateArgs>(args: Subset<T, CbtQuestionAggregateArgs>): Prisma.PrismaPromise<GetCbtQuestionAggregateType<T>>

    /**
     * Group by CbtQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CbtQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CbtQuestionGroupByArgs['orderBy'] }
        : { orderBy?: CbtQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CbtQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCbtQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CbtQuestion model
   */
  readonly fields: CbtQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CbtQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CbtQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends CbtTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CbtTestDefaultArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CbtQuestion model
   */ 
  interface CbtQuestionFieldRefs {
    readonly id: FieldRef<"CbtQuestion", 'Int'>
    readonly testId: FieldRef<"CbtQuestion", 'Int'>
    readonly questionText: FieldRef<"CbtQuestion", 'String'>
    readonly options: FieldRef<"CbtQuestion", 'Json'>
    readonly correctAnswer: FieldRef<"CbtQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CbtQuestion findUnique
   */
  export type CbtQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CbtQuestion to fetch.
     */
    where: CbtQuestionWhereUniqueInput
  }

  /**
   * CbtQuestion findUniqueOrThrow
   */
  export type CbtQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CbtQuestion to fetch.
     */
    where: CbtQuestionWhereUniqueInput
  }

  /**
   * CbtQuestion findFirst
   */
  export type CbtQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CbtQuestion to fetch.
     */
    where?: CbtQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtQuestions to fetch.
     */
    orderBy?: CbtQuestionOrderByWithRelationInput | CbtQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtQuestions.
     */
    cursor?: CbtQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtQuestions.
     */
    distinct?: CbtQuestionScalarFieldEnum | CbtQuestionScalarFieldEnum[]
  }

  /**
   * CbtQuestion findFirstOrThrow
   */
  export type CbtQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CbtQuestion to fetch.
     */
    where?: CbtQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtQuestions to fetch.
     */
    orderBy?: CbtQuestionOrderByWithRelationInput | CbtQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtQuestions.
     */
    cursor?: CbtQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtQuestions.
     */
    distinct?: CbtQuestionScalarFieldEnum | CbtQuestionScalarFieldEnum[]
  }

  /**
   * CbtQuestion findMany
   */
  export type CbtQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter, which CbtQuestions to fetch.
     */
    where?: CbtQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtQuestions to fetch.
     */
    orderBy?: CbtQuestionOrderByWithRelationInput | CbtQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CbtQuestions.
     */
    cursor?: CbtQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtQuestions.
     */
    skip?: number
    distinct?: CbtQuestionScalarFieldEnum | CbtQuestionScalarFieldEnum[]
  }

  /**
   * CbtQuestion create
   */
  export type CbtQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a CbtQuestion.
     */
    data: XOR<CbtQuestionCreateInput, CbtQuestionUncheckedCreateInput>
  }

  /**
   * CbtQuestion createMany
   */
  export type CbtQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CbtQuestions.
     */
    data: CbtQuestionCreateManyInput | CbtQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CbtQuestion createManyAndReturn
   */
  export type CbtQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CbtQuestions.
     */
    data: CbtQuestionCreateManyInput | CbtQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CbtQuestion update
   */
  export type CbtQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a CbtQuestion.
     */
    data: XOR<CbtQuestionUpdateInput, CbtQuestionUncheckedUpdateInput>
    /**
     * Choose, which CbtQuestion to update.
     */
    where: CbtQuestionWhereUniqueInput
  }

  /**
   * CbtQuestion updateMany
   */
  export type CbtQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CbtQuestions.
     */
    data: XOR<CbtQuestionUpdateManyMutationInput, CbtQuestionUncheckedUpdateManyInput>
    /**
     * Filter which CbtQuestions to update
     */
    where?: CbtQuestionWhereInput
  }

  /**
   * CbtQuestion upsert
   */
  export type CbtQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the CbtQuestion to update in case it exists.
     */
    where: CbtQuestionWhereUniqueInput
    /**
     * In case the CbtQuestion found by the `where` argument doesn't exist, create a new CbtQuestion with this data.
     */
    create: XOR<CbtQuestionCreateInput, CbtQuestionUncheckedCreateInput>
    /**
     * In case the CbtQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CbtQuestionUpdateInput, CbtQuestionUncheckedUpdateInput>
  }

  /**
   * CbtQuestion delete
   */
  export type CbtQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
    /**
     * Filter which CbtQuestion to delete.
     */
    where: CbtQuestionWhereUniqueInput
  }

  /**
   * CbtQuestion deleteMany
   */
  export type CbtQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtQuestions to delete
     */
    where?: CbtQuestionWhereInput
  }

  /**
   * CbtQuestion without action
   */
  export type CbtQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtQuestion
     */
    select?: CbtQuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtQuestionInclude<ExtArgs> | null
  }


  /**
   * Model CbtResult
   */

  export type AggregateCbtResult = {
    _count: CbtResultCountAggregateOutputType | null
    _avg: CbtResultAvgAggregateOutputType | null
    _sum: CbtResultSumAggregateOutputType | null
    _min: CbtResultMinAggregateOutputType | null
    _max: CbtResultMaxAggregateOutputType | null
  }

  export type CbtResultAvgAggregateOutputType = {
    id: number | null
    testId: number | null
    studentId: number | null
    score: number | null
    totalQuestions: number | null
  }

  export type CbtResultSumAggregateOutputType = {
    id: number | null
    testId: number | null
    studentId: number | null
    score: number | null
    totalQuestions: number | null
  }

  export type CbtResultMinAggregateOutputType = {
    id: number | null
    testId: number | null
    studentId: number | null
    score: number | null
    totalQuestions: number | null
    submittedAt: Date | null
  }

  export type CbtResultMaxAggregateOutputType = {
    id: number | null
    testId: number | null
    studentId: number | null
    score: number | null
    totalQuestions: number | null
    submittedAt: Date | null
  }

  export type CbtResultCountAggregateOutputType = {
    id: number
    testId: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt: number
    _all: number
  }


  export type CbtResultAvgAggregateInputType = {
    id?: true
    testId?: true
    studentId?: true
    score?: true
    totalQuestions?: true
  }

  export type CbtResultSumAggregateInputType = {
    id?: true
    testId?: true
    studentId?: true
    score?: true
    totalQuestions?: true
  }

  export type CbtResultMinAggregateInputType = {
    id?: true
    testId?: true
    studentId?: true
    score?: true
    totalQuestions?: true
    submittedAt?: true
  }

  export type CbtResultMaxAggregateInputType = {
    id?: true
    testId?: true
    studentId?: true
    score?: true
    totalQuestions?: true
    submittedAt?: true
  }

  export type CbtResultCountAggregateInputType = {
    id?: true
    testId?: true
    studentId?: true
    score?: true
    totalQuestions?: true
    submittedAt?: true
    _all?: true
  }

  export type CbtResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtResult to aggregate.
     */
    where?: CbtResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtResults to fetch.
     */
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CbtResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CbtResults
    **/
    _count?: true | CbtResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CbtResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CbtResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CbtResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CbtResultMaxAggregateInputType
  }

  export type GetCbtResultAggregateType<T extends CbtResultAggregateArgs> = {
        [P in keyof T & keyof AggregateCbtResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCbtResult[P]>
      : GetScalarType<T[P], AggregateCbtResult[P]>
  }




  export type CbtResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CbtResultWhereInput
    orderBy?: CbtResultOrderByWithAggregationInput | CbtResultOrderByWithAggregationInput[]
    by: CbtResultScalarFieldEnum[] | CbtResultScalarFieldEnum
    having?: CbtResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CbtResultCountAggregateInputType | true
    _avg?: CbtResultAvgAggregateInputType
    _sum?: CbtResultSumAggregateInputType
    _min?: CbtResultMinAggregateInputType
    _max?: CbtResultMaxAggregateInputType
  }

  export type CbtResultGroupByOutputType = {
    id: number
    testId: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt: Date
    _count: CbtResultCountAggregateOutputType | null
    _avg: CbtResultAvgAggregateOutputType | null
    _sum: CbtResultSumAggregateOutputType | null
    _min: CbtResultMinAggregateOutputType | null
    _max: CbtResultMaxAggregateOutputType | null
  }

  type GetCbtResultGroupByPayload<T extends CbtResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CbtResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CbtResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CbtResultGroupByOutputType[P]>
            : GetScalarType<T[P], CbtResultGroupByOutputType[P]>
        }
      >
    >


  export type CbtResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    studentId?: boolean
    score?: boolean
    totalQuestions?: boolean
    submittedAt?: boolean
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cbtResult"]>

  export type CbtResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testId?: boolean
    studentId?: boolean
    score?: boolean
    totalQuestions?: boolean
    submittedAt?: boolean
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cbtResult"]>

  export type CbtResultSelectScalar = {
    id?: boolean
    testId?: boolean
    studentId?: boolean
    score?: boolean
    totalQuestions?: boolean
    submittedAt?: boolean
  }

  export type CbtResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type CbtResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    test?: boolean | CbtTestDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $CbtResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CbtResult"
    objects: {
      test: Prisma.$CbtTestPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      testId: number
      studentId: number
      score: number
      totalQuestions: number
      submittedAt: Date
    }, ExtArgs["result"]["cbtResult"]>
    composites: {}
  }

  type CbtResultGetPayload<S extends boolean | null | undefined | CbtResultDefaultArgs> = $Result.GetResult<Prisma.$CbtResultPayload, S>

  type CbtResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CbtResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CbtResultCountAggregateInputType | true
    }

  export interface CbtResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CbtResult'], meta: { name: 'CbtResult' } }
    /**
     * Find zero or one CbtResult that matches the filter.
     * @param {CbtResultFindUniqueArgs} args - Arguments to find a CbtResult
     * @example
     * // Get one CbtResult
     * const cbtResult = await prisma.cbtResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CbtResultFindUniqueArgs>(args: SelectSubset<T, CbtResultFindUniqueArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CbtResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CbtResultFindUniqueOrThrowArgs} args - Arguments to find a CbtResult
     * @example
     * // Get one CbtResult
     * const cbtResult = await prisma.cbtResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CbtResultFindUniqueOrThrowArgs>(args: SelectSubset<T, CbtResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CbtResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultFindFirstArgs} args - Arguments to find a CbtResult
     * @example
     * // Get one CbtResult
     * const cbtResult = await prisma.cbtResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CbtResultFindFirstArgs>(args?: SelectSubset<T, CbtResultFindFirstArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CbtResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultFindFirstOrThrowArgs} args - Arguments to find a CbtResult
     * @example
     * // Get one CbtResult
     * const cbtResult = await prisma.cbtResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CbtResultFindFirstOrThrowArgs>(args?: SelectSubset<T, CbtResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CbtResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CbtResults
     * const cbtResults = await prisma.cbtResult.findMany()
     * 
     * // Get first 10 CbtResults
     * const cbtResults = await prisma.cbtResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cbtResultWithIdOnly = await prisma.cbtResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CbtResultFindManyArgs>(args?: SelectSubset<T, CbtResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CbtResult.
     * @param {CbtResultCreateArgs} args - Arguments to create a CbtResult.
     * @example
     * // Create one CbtResult
     * const CbtResult = await prisma.cbtResult.create({
     *   data: {
     *     // ... data to create a CbtResult
     *   }
     * })
     * 
     */
    create<T extends CbtResultCreateArgs>(args: SelectSubset<T, CbtResultCreateArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CbtResults.
     * @param {CbtResultCreateManyArgs} args - Arguments to create many CbtResults.
     * @example
     * // Create many CbtResults
     * const cbtResult = await prisma.cbtResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CbtResultCreateManyArgs>(args?: SelectSubset<T, CbtResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CbtResults and returns the data saved in the database.
     * @param {CbtResultCreateManyAndReturnArgs} args - Arguments to create many CbtResults.
     * @example
     * // Create many CbtResults
     * const cbtResult = await prisma.cbtResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CbtResults and only return the `id`
     * const cbtResultWithIdOnly = await prisma.cbtResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CbtResultCreateManyAndReturnArgs>(args?: SelectSubset<T, CbtResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CbtResult.
     * @param {CbtResultDeleteArgs} args - Arguments to delete one CbtResult.
     * @example
     * // Delete one CbtResult
     * const CbtResult = await prisma.cbtResult.delete({
     *   where: {
     *     // ... filter to delete one CbtResult
     *   }
     * })
     * 
     */
    delete<T extends CbtResultDeleteArgs>(args: SelectSubset<T, CbtResultDeleteArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CbtResult.
     * @param {CbtResultUpdateArgs} args - Arguments to update one CbtResult.
     * @example
     * // Update one CbtResult
     * const cbtResult = await prisma.cbtResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CbtResultUpdateArgs>(args: SelectSubset<T, CbtResultUpdateArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CbtResults.
     * @param {CbtResultDeleteManyArgs} args - Arguments to filter CbtResults to delete.
     * @example
     * // Delete a few CbtResults
     * const { count } = await prisma.cbtResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CbtResultDeleteManyArgs>(args?: SelectSubset<T, CbtResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CbtResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CbtResults
     * const cbtResult = await prisma.cbtResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CbtResultUpdateManyArgs>(args: SelectSubset<T, CbtResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CbtResult.
     * @param {CbtResultUpsertArgs} args - Arguments to update or create a CbtResult.
     * @example
     * // Update or create a CbtResult
     * const cbtResult = await prisma.cbtResult.upsert({
     *   create: {
     *     // ... data to create a CbtResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CbtResult we want to update
     *   }
     * })
     */
    upsert<T extends CbtResultUpsertArgs>(args: SelectSubset<T, CbtResultUpsertArgs<ExtArgs>>): Prisma__CbtResultClient<$Result.GetResult<Prisma.$CbtResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CbtResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultCountArgs} args - Arguments to filter CbtResults to count.
     * @example
     * // Count the number of CbtResults
     * const count = await prisma.cbtResult.count({
     *   where: {
     *     // ... the filter for the CbtResults we want to count
     *   }
     * })
    **/
    count<T extends CbtResultCountArgs>(
      args?: Subset<T, CbtResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CbtResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CbtResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CbtResultAggregateArgs>(args: Subset<T, CbtResultAggregateArgs>): Prisma.PrismaPromise<GetCbtResultAggregateType<T>>

    /**
     * Group by CbtResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CbtResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CbtResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CbtResultGroupByArgs['orderBy'] }
        : { orderBy?: CbtResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CbtResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCbtResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CbtResult model
   */
  readonly fields: CbtResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CbtResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CbtResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    test<T extends CbtTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CbtTestDefaultArgs<ExtArgs>>): Prisma__CbtTestClient<$Result.GetResult<Prisma.$CbtTestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CbtResult model
   */ 
  interface CbtResultFieldRefs {
    readonly id: FieldRef<"CbtResult", 'Int'>
    readonly testId: FieldRef<"CbtResult", 'Int'>
    readonly studentId: FieldRef<"CbtResult", 'Int'>
    readonly score: FieldRef<"CbtResult", 'Int'>
    readonly totalQuestions: FieldRef<"CbtResult", 'Int'>
    readonly submittedAt: FieldRef<"CbtResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CbtResult findUnique
   */
  export type CbtResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter, which CbtResult to fetch.
     */
    where: CbtResultWhereUniqueInput
  }

  /**
   * CbtResult findUniqueOrThrow
   */
  export type CbtResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter, which CbtResult to fetch.
     */
    where: CbtResultWhereUniqueInput
  }

  /**
   * CbtResult findFirst
   */
  export type CbtResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter, which CbtResult to fetch.
     */
    where?: CbtResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtResults to fetch.
     */
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtResults.
     */
    cursor?: CbtResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtResults.
     */
    distinct?: CbtResultScalarFieldEnum | CbtResultScalarFieldEnum[]
  }

  /**
   * CbtResult findFirstOrThrow
   */
  export type CbtResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter, which CbtResult to fetch.
     */
    where?: CbtResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtResults to fetch.
     */
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CbtResults.
     */
    cursor?: CbtResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CbtResults.
     */
    distinct?: CbtResultScalarFieldEnum | CbtResultScalarFieldEnum[]
  }

  /**
   * CbtResult findMany
   */
  export type CbtResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter, which CbtResults to fetch.
     */
    where?: CbtResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CbtResults to fetch.
     */
    orderBy?: CbtResultOrderByWithRelationInput | CbtResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CbtResults.
     */
    cursor?: CbtResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CbtResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CbtResults.
     */
    skip?: number
    distinct?: CbtResultScalarFieldEnum | CbtResultScalarFieldEnum[]
  }

  /**
   * CbtResult create
   */
  export type CbtResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * The data needed to create a CbtResult.
     */
    data: XOR<CbtResultCreateInput, CbtResultUncheckedCreateInput>
  }

  /**
   * CbtResult createMany
   */
  export type CbtResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CbtResults.
     */
    data: CbtResultCreateManyInput | CbtResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CbtResult createManyAndReturn
   */
  export type CbtResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CbtResults.
     */
    data: CbtResultCreateManyInput | CbtResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CbtResult update
   */
  export type CbtResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * The data needed to update a CbtResult.
     */
    data: XOR<CbtResultUpdateInput, CbtResultUncheckedUpdateInput>
    /**
     * Choose, which CbtResult to update.
     */
    where: CbtResultWhereUniqueInput
  }

  /**
   * CbtResult updateMany
   */
  export type CbtResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CbtResults.
     */
    data: XOR<CbtResultUpdateManyMutationInput, CbtResultUncheckedUpdateManyInput>
    /**
     * Filter which CbtResults to update
     */
    where?: CbtResultWhereInput
  }

  /**
   * CbtResult upsert
   */
  export type CbtResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * The filter to search for the CbtResult to update in case it exists.
     */
    where: CbtResultWhereUniqueInput
    /**
     * In case the CbtResult found by the `where` argument doesn't exist, create a new CbtResult with this data.
     */
    create: XOR<CbtResultCreateInput, CbtResultUncheckedCreateInput>
    /**
     * In case the CbtResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CbtResultUpdateInput, CbtResultUncheckedUpdateInput>
  }

  /**
   * CbtResult delete
   */
  export type CbtResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
    /**
     * Filter which CbtResult to delete.
     */
    where: CbtResultWhereUniqueInput
  }

  /**
   * CbtResult deleteMany
   */
  export type CbtResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CbtResults to delete
     */
    where?: CbtResultWhereInput
  }

  /**
   * CbtResult without action
   */
  export type CbtResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CbtResult
     */
    select?: CbtResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CbtResultInclude<ExtArgs> | null
  }


  /**
   * Model CalendarEvent
   */

  export type AggregateCalendarEvent = {
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  export type CalendarEventAvgAggregateOutputType = {
    id: number | null
  }

  export type CalendarEventSumAggregateOutputType = {
    id: number | null
  }

  export type CalendarEventMinAggregateOutputType = {
    id: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    type: string | null
    description: string | null
  }

  export type CalendarEventMaxAggregateOutputType = {
    id: number | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    type: string | null
    description: string | null
  }

  export type CalendarEventCountAggregateOutputType = {
    id: number
    title: number
    startDate: number
    endDate: number
    type: number
    description: number
    _all: number
  }


  export type CalendarEventAvgAggregateInputType = {
    id?: true
  }

  export type CalendarEventSumAggregateInputType = {
    id?: true
  }

  export type CalendarEventMinAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    type?: true
    description?: true
  }

  export type CalendarEventMaxAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    type?: true
    description?: true
  }

  export type CalendarEventCountAggregateInputType = {
    id?: true
    title?: true
    startDate?: true
    endDate?: true
    type?: true
    description?: true
    _all?: true
  }

  export type CalendarEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvent to aggregate.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarEvents
    **/
    _count?: true | CalendarEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarEventMaxAggregateInputType
  }

  export type GetCalendarEventAggregateType<T extends CalendarEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarEvent[P]>
      : GetScalarType<T[P], AggregateCalendarEvent[P]>
  }




  export type CalendarEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarEventWhereInput
    orderBy?: CalendarEventOrderByWithAggregationInput | CalendarEventOrderByWithAggregationInput[]
    by: CalendarEventScalarFieldEnum[] | CalendarEventScalarFieldEnum
    having?: CalendarEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarEventCountAggregateInputType | true
    _avg?: CalendarEventAvgAggregateInputType
    _sum?: CalendarEventSumAggregateInputType
    _min?: CalendarEventMinAggregateInputType
    _max?: CalendarEventMaxAggregateInputType
  }

  export type CalendarEventGroupByOutputType = {
    id: number
    title: string
    startDate: Date
    endDate: Date | null
    type: string | null
    description: string | null
    _count: CalendarEventCountAggregateOutputType | null
    _avg: CalendarEventAvgAggregateOutputType | null
    _sum: CalendarEventSumAggregateOutputType | null
    _min: CalendarEventMinAggregateOutputType | null
    _max: CalendarEventMaxAggregateOutputType | null
  }

  type GetCalendarEventGroupByPayload<T extends CalendarEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarEventGroupByOutputType[P]>
        }
      >
    >


  export type CalendarEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    description?: boolean
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    description?: boolean
  }, ExtArgs["result"]["calendarEvent"]>

  export type CalendarEventSelectScalar = {
    id?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    type?: boolean
    description?: boolean
  }


  export type $CalendarEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      startDate: Date
      endDate: Date | null
      type: string | null
      description: string | null
    }, ExtArgs["result"]["calendarEvent"]>
    composites: {}
  }

  type CalendarEventGetPayload<S extends boolean | null | undefined | CalendarEventDefaultArgs> = $Result.GetResult<Prisma.$CalendarEventPayload, S>

  type CalendarEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CalendarEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CalendarEventCountAggregateInputType | true
    }

  export interface CalendarEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarEvent'], meta: { name: 'CalendarEvent' } }
    /**
     * Find zero or one CalendarEvent that matches the filter.
     * @param {CalendarEventFindUniqueArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarEventFindUniqueArgs>(args: SelectSubset<T, CalendarEventFindUniqueArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CalendarEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CalendarEventFindUniqueOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarEventFindFirstArgs>(args?: SelectSubset<T, CalendarEventFindFirstArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CalendarEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindFirstOrThrowArgs} args - Arguments to find a CalendarEvent
     * @example
     * // Get one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CalendarEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany()
     * 
     * // Get first 10 CalendarEvents
     * const calendarEvents = await prisma.calendarEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarEventFindManyArgs>(args?: SelectSubset<T, CalendarEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CalendarEvent.
     * @param {CalendarEventCreateArgs} args - Arguments to create a CalendarEvent.
     * @example
     * // Create one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.create({
     *   data: {
     *     // ... data to create a CalendarEvent
     *   }
     * })
     * 
     */
    create<T extends CalendarEventCreateArgs>(args: SelectSubset<T, CalendarEventCreateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CalendarEvents.
     * @param {CalendarEventCreateManyArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarEventCreateManyArgs>(args?: SelectSubset<T, CalendarEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CalendarEvents and returns the data saved in the database.
     * @param {CalendarEventCreateManyAndReturnArgs} args - Arguments to create many CalendarEvents.
     * @example
     * // Create many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CalendarEvents and only return the `id`
     * const calendarEventWithIdOnly = await prisma.calendarEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CalendarEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CalendarEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CalendarEvent.
     * @param {CalendarEventDeleteArgs} args - Arguments to delete one CalendarEvent.
     * @example
     * // Delete one CalendarEvent
     * const CalendarEvent = await prisma.calendarEvent.delete({
     *   where: {
     *     // ... filter to delete one CalendarEvent
     *   }
     * })
     * 
     */
    delete<T extends CalendarEventDeleteArgs>(args: SelectSubset<T, CalendarEventDeleteArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CalendarEvent.
     * @param {CalendarEventUpdateArgs} args - Arguments to update one CalendarEvent.
     * @example
     * // Update one CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarEventUpdateArgs>(args: SelectSubset<T, CalendarEventUpdateArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CalendarEvents.
     * @param {CalendarEventDeleteManyArgs} args - Arguments to filter CalendarEvents to delete.
     * @example
     * // Delete a few CalendarEvents
     * const { count } = await prisma.calendarEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarEventDeleteManyArgs>(args?: SelectSubset<T, CalendarEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarEvents
     * const calendarEvent = await prisma.calendarEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarEventUpdateManyArgs>(args: SelectSubset<T, CalendarEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarEvent.
     * @param {CalendarEventUpsertArgs} args - Arguments to update or create a CalendarEvent.
     * @example
     * // Update or create a CalendarEvent
     * const calendarEvent = await prisma.calendarEvent.upsert({
     *   create: {
     *     // ... data to create a CalendarEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarEvent we want to update
     *   }
     * })
     */
    upsert<T extends CalendarEventUpsertArgs>(args: SelectSubset<T, CalendarEventUpsertArgs<ExtArgs>>): Prisma__CalendarEventClient<$Result.GetResult<Prisma.$CalendarEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CalendarEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventCountArgs} args - Arguments to filter CalendarEvents to count.
     * @example
     * // Count the number of CalendarEvents
     * const count = await prisma.calendarEvent.count({
     *   where: {
     *     // ... the filter for the CalendarEvents we want to count
     *   }
     * })
    **/
    count<T extends CalendarEventCountArgs>(
      args?: Subset<T, CalendarEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarEventAggregateArgs>(args: Subset<T, CalendarEventAggregateArgs>): Prisma.PrismaPromise<GetCalendarEventAggregateType<T>>

    /**
     * Group by CalendarEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarEventGroupByArgs['orderBy'] }
        : { orderBy?: CalendarEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarEvent model
   */
  readonly fields: CalendarEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarEvent model
   */ 
  interface CalendarEventFieldRefs {
    readonly id: FieldRef<"CalendarEvent", 'Int'>
    readonly title: FieldRef<"CalendarEvent", 'String'>
    readonly startDate: FieldRef<"CalendarEvent", 'DateTime'>
    readonly endDate: FieldRef<"CalendarEvent", 'DateTime'>
    readonly type: FieldRef<"CalendarEvent", 'String'>
    readonly description: FieldRef<"CalendarEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CalendarEvent findUnique
   */
  export type CalendarEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findUniqueOrThrow
   */
  export type CalendarEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent findFirst
   */
  export type CalendarEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findFirstOrThrow
   */
  export type CalendarEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter, which CalendarEvent to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarEvents.
     */
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent findMany
   */
  export type CalendarEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter, which CalendarEvents to fetch.
     */
    where?: CalendarEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarEvents to fetch.
     */
    orderBy?: CalendarEventOrderByWithRelationInput | CalendarEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarEvents.
     */
    cursor?: CalendarEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarEvents.
     */
    skip?: number
    distinct?: CalendarEventScalarFieldEnum | CalendarEventScalarFieldEnum[]
  }

  /**
   * CalendarEvent create
   */
  export type CalendarEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * The data needed to create a CalendarEvent.
     */
    data: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
  }

  /**
   * CalendarEvent createMany
   */
  export type CalendarEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent createManyAndReturn
   */
  export type CalendarEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CalendarEvents.
     */
    data: CalendarEventCreateManyInput | CalendarEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarEvent update
   */
  export type CalendarEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * The data needed to update a CalendarEvent.
     */
    data: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
    /**
     * Choose, which CalendarEvent to update.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent updateMany
   */
  export type CalendarEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarEvents.
     */
    data: XOR<CalendarEventUpdateManyMutationInput, CalendarEventUncheckedUpdateManyInput>
    /**
     * Filter which CalendarEvents to update
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent upsert
   */
  export type CalendarEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * The filter to search for the CalendarEvent to update in case it exists.
     */
    where: CalendarEventWhereUniqueInput
    /**
     * In case the CalendarEvent found by the `where` argument doesn't exist, create a new CalendarEvent with this data.
     */
    create: XOR<CalendarEventCreateInput, CalendarEventUncheckedCreateInput>
    /**
     * In case the CalendarEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarEventUpdateInput, CalendarEventUncheckedUpdateInput>
  }

  /**
   * CalendarEvent delete
   */
  export type CalendarEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
    /**
     * Filter which CalendarEvent to delete.
     */
    where: CalendarEventWhereUniqueInput
  }

  /**
   * CalendarEvent deleteMany
   */
  export type CalendarEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarEvents to delete
     */
    where?: CalendarEventWhereInput
  }

  /**
   * CalendarEvent without action
   */
  export type CalendarEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarEvent
     */
    select?: CalendarEventSelect<ExtArgs> | null
  }


  /**
   * Model ExtracurricularActivity
   */

  export type AggregateExtracurricularActivity = {
    _count: ExtracurricularActivityCountAggregateOutputType | null
    _avg: ExtracurricularActivityAvgAggregateOutputType | null
    _sum: ExtracurricularActivitySumAggregateOutputType | null
    _min: ExtracurricularActivityMinAggregateOutputType | null
    _max: ExtracurricularActivityMaxAggregateOutputType | null
  }

  export type ExtracurricularActivityAvgAggregateOutputType = {
    id: number | null
  }

  export type ExtracurricularActivitySumAggregateOutputType = {
    id: number | null
  }

  export type ExtracurricularActivityMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    schedule: string | null
  }

  export type ExtracurricularActivityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    schedule: string | null
  }

  export type ExtracurricularActivityCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    schedule: number
    _all: number
  }


  export type ExtracurricularActivityAvgAggregateInputType = {
    id?: true
  }

  export type ExtracurricularActivitySumAggregateInputType = {
    id?: true
  }

  export type ExtracurricularActivityMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    schedule?: true
  }

  export type ExtracurricularActivityMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    schedule?: true
  }

  export type ExtracurricularActivityCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    schedule?: true
    _all?: true
  }

  export type ExtracurricularActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtracurricularActivity to aggregate.
     */
    where?: ExtracurricularActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtracurricularActivities to fetch.
     */
    orderBy?: ExtracurricularActivityOrderByWithRelationInput | ExtracurricularActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtracurricularActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtracurricularActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtracurricularActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtracurricularActivities
    **/
    _count?: true | ExtracurricularActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtracurricularActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtracurricularActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtracurricularActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtracurricularActivityMaxAggregateInputType
  }

  export type GetExtracurricularActivityAggregateType<T extends ExtracurricularActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateExtracurricularActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtracurricularActivity[P]>
      : GetScalarType<T[P], AggregateExtracurricularActivity[P]>
  }




  export type ExtracurricularActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtracurricularActivityWhereInput
    orderBy?: ExtracurricularActivityOrderByWithAggregationInput | ExtracurricularActivityOrderByWithAggregationInput[]
    by: ExtracurricularActivityScalarFieldEnum[] | ExtracurricularActivityScalarFieldEnum
    having?: ExtracurricularActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtracurricularActivityCountAggregateInputType | true
    _avg?: ExtracurricularActivityAvgAggregateInputType
    _sum?: ExtracurricularActivitySumAggregateInputType
    _min?: ExtracurricularActivityMinAggregateInputType
    _max?: ExtracurricularActivityMaxAggregateInputType
  }

  export type ExtracurricularActivityGroupByOutputType = {
    id: number
    name: string
    category: string
    description: string | null
    schedule: string | null
    _count: ExtracurricularActivityCountAggregateOutputType | null
    _avg: ExtracurricularActivityAvgAggregateOutputType | null
    _sum: ExtracurricularActivitySumAggregateOutputType | null
    _min: ExtracurricularActivityMinAggregateOutputType | null
    _max: ExtracurricularActivityMaxAggregateOutputType | null
  }

  type GetExtracurricularActivityGroupByPayload<T extends ExtracurricularActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtracurricularActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtracurricularActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtracurricularActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ExtracurricularActivityGroupByOutputType[P]>
        }
      >
    >


  export type ExtracurricularActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    schedule?: boolean
  }, ExtArgs["result"]["extracurricularActivity"]>

  export type ExtracurricularActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    schedule?: boolean
  }, ExtArgs["result"]["extracurricularActivity"]>

  export type ExtracurricularActivitySelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    schedule?: boolean
  }


  export type $ExtracurricularActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtracurricularActivity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      description: string | null
      schedule: string | null
    }, ExtArgs["result"]["extracurricularActivity"]>
    composites: {}
  }

  type ExtracurricularActivityGetPayload<S extends boolean | null | undefined | ExtracurricularActivityDefaultArgs> = $Result.GetResult<Prisma.$ExtracurricularActivityPayload, S>

  type ExtracurricularActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExtracurricularActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExtracurricularActivityCountAggregateInputType | true
    }

  export interface ExtracurricularActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtracurricularActivity'], meta: { name: 'ExtracurricularActivity' } }
    /**
     * Find zero or one ExtracurricularActivity that matches the filter.
     * @param {ExtracurricularActivityFindUniqueArgs} args - Arguments to find a ExtracurricularActivity
     * @example
     * // Get one ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtracurricularActivityFindUniqueArgs>(args: SelectSubset<T, ExtracurricularActivityFindUniqueArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExtracurricularActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExtracurricularActivityFindUniqueOrThrowArgs} args - Arguments to find a ExtracurricularActivity
     * @example
     * // Get one ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtracurricularActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtracurricularActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExtracurricularActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityFindFirstArgs} args - Arguments to find a ExtracurricularActivity
     * @example
     * // Get one ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtracurricularActivityFindFirstArgs>(args?: SelectSubset<T, ExtracurricularActivityFindFirstArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExtracurricularActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityFindFirstOrThrowArgs} args - Arguments to find a ExtracurricularActivity
     * @example
     * // Get one ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtracurricularActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtracurricularActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExtracurricularActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtracurricularActivities
     * const extracurricularActivities = await prisma.extracurricularActivity.findMany()
     * 
     * // Get first 10 ExtracurricularActivities
     * const extracurricularActivities = await prisma.extracurricularActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extracurricularActivityWithIdOnly = await prisma.extracurricularActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtracurricularActivityFindManyArgs>(args?: SelectSubset<T, ExtracurricularActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExtracurricularActivity.
     * @param {ExtracurricularActivityCreateArgs} args - Arguments to create a ExtracurricularActivity.
     * @example
     * // Create one ExtracurricularActivity
     * const ExtracurricularActivity = await prisma.extracurricularActivity.create({
     *   data: {
     *     // ... data to create a ExtracurricularActivity
     *   }
     * })
     * 
     */
    create<T extends ExtracurricularActivityCreateArgs>(args: SelectSubset<T, ExtracurricularActivityCreateArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExtracurricularActivities.
     * @param {ExtracurricularActivityCreateManyArgs} args - Arguments to create many ExtracurricularActivities.
     * @example
     * // Create many ExtracurricularActivities
     * const extracurricularActivity = await prisma.extracurricularActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtracurricularActivityCreateManyArgs>(args?: SelectSubset<T, ExtracurricularActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtracurricularActivities and returns the data saved in the database.
     * @param {ExtracurricularActivityCreateManyAndReturnArgs} args - Arguments to create many ExtracurricularActivities.
     * @example
     * // Create many ExtracurricularActivities
     * const extracurricularActivity = await prisma.extracurricularActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtracurricularActivities and only return the `id`
     * const extracurricularActivityWithIdOnly = await prisma.extracurricularActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtracurricularActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtracurricularActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExtracurricularActivity.
     * @param {ExtracurricularActivityDeleteArgs} args - Arguments to delete one ExtracurricularActivity.
     * @example
     * // Delete one ExtracurricularActivity
     * const ExtracurricularActivity = await prisma.extracurricularActivity.delete({
     *   where: {
     *     // ... filter to delete one ExtracurricularActivity
     *   }
     * })
     * 
     */
    delete<T extends ExtracurricularActivityDeleteArgs>(args: SelectSubset<T, ExtracurricularActivityDeleteArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExtracurricularActivity.
     * @param {ExtracurricularActivityUpdateArgs} args - Arguments to update one ExtracurricularActivity.
     * @example
     * // Update one ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtracurricularActivityUpdateArgs>(args: SelectSubset<T, ExtracurricularActivityUpdateArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExtracurricularActivities.
     * @param {ExtracurricularActivityDeleteManyArgs} args - Arguments to filter ExtracurricularActivities to delete.
     * @example
     * // Delete a few ExtracurricularActivities
     * const { count } = await prisma.extracurricularActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtracurricularActivityDeleteManyArgs>(args?: SelectSubset<T, ExtracurricularActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtracurricularActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtracurricularActivities
     * const extracurricularActivity = await prisma.extracurricularActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtracurricularActivityUpdateManyArgs>(args: SelectSubset<T, ExtracurricularActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExtracurricularActivity.
     * @param {ExtracurricularActivityUpsertArgs} args - Arguments to update or create a ExtracurricularActivity.
     * @example
     * // Update or create a ExtracurricularActivity
     * const extracurricularActivity = await prisma.extracurricularActivity.upsert({
     *   create: {
     *     // ... data to create a ExtracurricularActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtracurricularActivity we want to update
     *   }
     * })
     */
    upsert<T extends ExtracurricularActivityUpsertArgs>(args: SelectSubset<T, ExtracurricularActivityUpsertArgs<ExtArgs>>): Prisma__ExtracurricularActivityClient<$Result.GetResult<Prisma.$ExtracurricularActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExtracurricularActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityCountArgs} args - Arguments to filter ExtracurricularActivities to count.
     * @example
     * // Count the number of ExtracurricularActivities
     * const count = await prisma.extracurricularActivity.count({
     *   where: {
     *     // ... the filter for the ExtracurricularActivities we want to count
     *   }
     * })
    **/
    count<T extends ExtracurricularActivityCountArgs>(
      args?: Subset<T, ExtracurricularActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtracurricularActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtracurricularActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtracurricularActivityAggregateArgs>(args: Subset<T, ExtracurricularActivityAggregateArgs>): Prisma.PrismaPromise<GetExtracurricularActivityAggregateType<T>>

    /**
     * Group by ExtracurricularActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtracurricularActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtracurricularActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtracurricularActivityGroupByArgs['orderBy'] }
        : { orderBy?: ExtracurricularActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtracurricularActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtracurricularActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtracurricularActivity model
   */
  readonly fields: ExtracurricularActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtracurricularActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtracurricularActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExtracurricularActivity model
   */ 
  interface ExtracurricularActivityFieldRefs {
    readonly id: FieldRef<"ExtracurricularActivity", 'Int'>
    readonly name: FieldRef<"ExtracurricularActivity", 'String'>
    readonly category: FieldRef<"ExtracurricularActivity", 'String'>
    readonly description: FieldRef<"ExtracurricularActivity", 'String'>
    readonly schedule: FieldRef<"ExtracurricularActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExtracurricularActivity findUnique
   */
  export type ExtracurricularActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter, which ExtracurricularActivity to fetch.
     */
    where: ExtracurricularActivityWhereUniqueInput
  }

  /**
   * ExtracurricularActivity findUniqueOrThrow
   */
  export type ExtracurricularActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter, which ExtracurricularActivity to fetch.
     */
    where: ExtracurricularActivityWhereUniqueInput
  }

  /**
   * ExtracurricularActivity findFirst
   */
  export type ExtracurricularActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter, which ExtracurricularActivity to fetch.
     */
    where?: ExtracurricularActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtracurricularActivities to fetch.
     */
    orderBy?: ExtracurricularActivityOrderByWithRelationInput | ExtracurricularActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtracurricularActivities.
     */
    cursor?: ExtracurricularActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtracurricularActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtracurricularActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtracurricularActivities.
     */
    distinct?: ExtracurricularActivityScalarFieldEnum | ExtracurricularActivityScalarFieldEnum[]
  }

  /**
   * ExtracurricularActivity findFirstOrThrow
   */
  export type ExtracurricularActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter, which ExtracurricularActivity to fetch.
     */
    where?: ExtracurricularActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtracurricularActivities to fetch.
     */
    orderBy?: ExtracurricularActivityOrderByWithRelationInput | ExtracurricularActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtracurricularActivities.
     */
    cursor?: ExtracurricularActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtracurricularActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtracurricularActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtracurricularActivities.
     */
    distinct?: ExtracurricularActivityScalarFieldEnum | ExtracurricularActivityScalarFieldEnum[]
  }

  /**
   * ExtracurricularActivity findMany
   */
  export type ExtracurricularActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter, which ExtracurricularActivities to fetch.
     */
    where?: ExtracurricularActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtracurricularActivities to fetch.
     */
    orderBy?: ExtracurricularActivityOrderByWithRelationInput | ExtracurricularActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtracurricularActivities.
     */
    cursor?: ExtracurricularActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtracurricularActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtracurricularActivities.
     */
    skip?: number
    distinct?: ExtracurricularActivityScalarFieldEnum | ExtracurricularActivityScalarFieldEnum[]
  }

  /**
   * ExtracurricularActivity create
   */
  export type ExtracurricularActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * The data needed to create a ExtracurricularActivity.
     */
    data: XOR<ExtracurricularActivityCreateInput, ExtracurricularActivityUncheckedCreateInput>
  }

  /**
   * ExtracurricularActivity createMany
   */
  export type ExtracurricularActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtracurricularActivities.
     */
    data: ExtracurricularActivityCreateManyInput | ExtracurricularActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtracurricularActivity createManyAndReturn
   */
  export type ExtracurricularActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExtracurricularActivities.
     */
    data: ExtracurricularActivityCreateManyInput | ExtracurricularActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtracurricularActivity update
   */
  export type ExtracurricularActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * The data needed to update a ExtracurricularActivity.
     */
    data: XOR<ExtracurricularActivityUpdateInput, ExtracurricularActivityUncheckedUpdateInput>
    /**
     * Choose, which ExtracurricularActivity to update.
     */
    where: ExtracurricularActivityWhereUniqueInput
  }

  /**
   * ExtracurricularActivity updateMany
   */
  export type ExtracurricularActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtracurricularActivities.
     */
    data: XOR<ExtracurricularActivityUpdateManyMutationInput, ExtracurricularActivityUncheckedUpdateManyInput>
    /**
     * Filter which ExtracurricularActivities to update
     */
    where?: ExtracurricularActivityWhereInput
  }

  /**
   * ExtracurricularActivity upsert
   */
  export type ExtracurricularActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * The filter to search for the ExtracurricularActivity to update in case it exists.
     */
    where: ExtracurricularActivityWhereUniqueInput
    /**
     * In case the ExtracurricularActivity found by the `where` argument doesn't exist, create a new ExtracurricularActivity with this data.
     */
    create: XOR<ExtracurricularActivityCreateInput, ExtracurricularActivityUncheckedCreateInput>
    /**
     * In case the ExtracurricularActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtracurricularActivityUpdateInput, ExtracurricularActivityUncheckedUpdateInput>
  }

  /**
   * ExtracurricularActivity delete
   */
  export type ExtracurricularActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
    /**
     * Filter which ExtracurricularActivity to delete.
     */
    where: ExtracurricularActivityWhereUniqueInput
  }

  /**
   * ExtracurricularActivity deleteMany
   */
  export type ExtracurricularActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtracurricularActivities to delete
     */
    where?: ExtracurricularActivityWhereInput
  }

  /**
   * ExtracurricularActivity without action
   */
  export type ExtracurricularActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtracurricularActivity
     */
    select?: ExtracurricularActivitySelect<ExtArgs> | null
  }


  /**
   * Model PtaMeeting
   */

  export type AggregatePtaMeeting = {
    _count: PtaMeetingCountAggregateOutputType | null
    _avg: PtaMeetingAvgAggregateOutputType | null
    _sum: PtaMeetingSumAggregateOutputType | null
    _min: PtaMeetingMinAggregateOutputType | null
    _max: PtaMeetingMaxAggregateOutputType | null
  }

  export type PtaMeetingAvgAggregateOutputType = {
    id: number | null
  }

  export type PtaMeetingSumAggregateOutputType = {
    id: number | null
  }

  export type PtaMeetingMinAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
  }

  export type PtaMeetingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    date: Date | null
  }

  export type PtaMeetingCountAggregateOutputType = {
    id: number
    title: number
    date: number
    agenda: number
    _all: number
  }


  export type PtaMeetingAvgAggregateInputType = {
    id?: true
  }

  export type PtaMeetingSumAggregateInputType = {
    id?: true
  }

  export type PtaMeetingMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
  }

  export type PtaMeetingMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
  }

  export type PtaMeetingCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    agenda?: true
    _all?: true
  }

  export type PtaMeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PtaMeeting to aggregate.
     */
    where?: PtaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PtaMeetings to fetch.
     */
    orderBy?: PtaMeetingOrderByWithRelationInput | PtaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PtaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PtaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PtaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PtaMeetings
    **/
    _count?: true | PtaMeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PtaMeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PtaMeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PtaMeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PtaMeetingMaxAggregateInputType
  }

  export type GetPtaMeetingAggregateType<T extends PtaMeetingAggregateArgs> = {
        [P in keyof T & keyof AggregatePtaMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePtaMeeting[P]>
      : GetScalarType<T[P], AggregatePtaMeeting[P]>
  }




  export type PtaMeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PtaMeetingWhereInput
    orderBy?: PtaMeetingOrderByWithAggregationInput | PtaMeetingOrderByWithAggregationInput[]
    by: PtaMeetingScalarFieldEnum[] | PtaMeetingScalarFieldEnum
    having?: PtaMeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PtaMeetingCountAggregateInputType | true
    _avg?: PtaMeetingAvgAggregateInputType
    _sum?: PtaMeetingSumAggregateInputType
    _min?: PtaMeetingMinAggregateInputType
    _max?: PtaMeetingMaxAggregateInputType
  }

  export type PtaMeetingGroupByOutputType = {
    id: number
    title: string
    date: Date
    agenda: JsonValue | null
    _count: PtaMeetingCountAggregateOutputType | null
    _avg: PtaMeetingAvgAggregateOutputType | null
    _sum: PtaMeetingSumAggregateOutputType | null
    _min: PtaMeetingMinAggregateOutputType | null
    _max: PtaMeetingMaxAggregateOutputType | null
  }

  type GetPtaMeetingGroupByPayload<T extends PtaMeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PtaMeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PtaMeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PtaMeetingGroupByOutputType[P]>
            : GetScalarType<T[P], PtaMeetingGroupByOutputType[P]>
        }
      >
    >


  export type PtaMeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    agenda?: boolean
  }, ExtArgs["result"]["ptaMeeting"]>

  export type PtaMeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    agenda?: boolean
  }, ExtArgs["result"]["ptaMeeting"]>

  export type PtaMeetingSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    agenda?: boolean
  }


  export type $PtaMeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PtaMeeting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      date: Date
      agenda: Prisma.JsonValue | null
    }, ExtArgs["result"]["ptaMeeting"]>
    composites: {}
  }

  type PtaMeetingGetPayload<S extends boolean | null | undefined | PtaMeetingDefaultArgs> = $Result.GetResult<Prisma.$PtaMeetingPayload, S>

  type PtaMeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PtaMeetingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PtaMeetingCountAggregateInputType | true
    }

  export interface PtaMeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PtaMeeting'], meta: { name: 'PtaMeeting' } }
    /**
     * Find zero or one PtaMeeting that matches the filter.
     * @param {PtaMeetingFindUniqueArgs} args - Arguments to find a PtaMeeting
     * @example
     * // Get one PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PtaMeetingFindUniqueArgs>(args: SelectSubset<T, PtaMeetingFindUniqueArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PtaMeeting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PtaMeetingFindUniqueOrThrowArgs} args - Arguments to find a PtaMeeting
     * @example
     * // Get one PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PtaMeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, PtaMeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PtaMeeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingFindFirstArgs} args - Arguments to find a PtaMeeting
     * @example
     * // Get one PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PtaMeetingFindFirstArgs>(args?: SelectSubset<T, PtaMeetingFindFirstArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PtaMeeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingFindFirstOrThrowArgs} args - Arguments to find a PtaMeeting
     * @example
     * // Get one PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PtaMeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, PtaMeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PtaMeetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PtaMeetings
     * const ptaMeetings = await prisma.ptaMeeting.findMany()
     * 
     * // Get first 10 PtaMeetings
     * const ptaMeetings = await prisma.ptaMeeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ptaMeetingWithIdOnly = await prisma.ptaMeeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PtaMeetingFindManyArgs>(args?: SelectSubset<T, PtaMeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PtaMeeting.
     * @param {PtaMeetingCreateArgs} args - Arguments to create a PtaMeeting.
     * @example
     * // Create one PtaMeeting
     * const PtaMeeting = await prisma.ptaMeeting.create({
     *   data: {
     *     // ... data to create a PtaMeeting
     *   }
     * })
     * 
     */
    create<T extends PtaMeetingCreateArgs>(args: SelectSubset<T, PtaMeetingCreateArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PtaMeetings.
     * @param {PtaMeetingCreateManyArgs} args - Arguments to create many PtaMeetings.
     * @example
     * // Create many PtaMeetings
     * const ptaMeeting = await prisma.ptaMeeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PtaMeetingCreateManyArgs>(args?: SelectSubset<T, PtaMeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PtaMeetings and returns the data saved in the database.
     * @param {PtaMeetingCreateManyAndReturnArgs} args - Arguments to create many PtaMeetings.
     * @example
     * // Create many PtaMeetings
     * const ptaMeeting = await prisma.ptaMeeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PtaMeetings and only return the `id`
     * const ptaMeetingWithIdOnly = await prisma.ptaMeeting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PtaMeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, PtaMeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PtaMeeting.
     * @param {PtaMeetingDeleteArgs} args - Arguments to delete one PtaMeeting.
     * @example
     * // Delete one PtaMeeting
     * const PtaMeeting = await prisma.ptaMeeting.delete({
     *   where: {
     *     // ... filter to delete one PtaMeeting
     *   }
     * })
     * 
     */
    delete<T extends PtaMeetingDeleteArgs>(args: SelectSubset<T, PtaMeetingDeleteArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PtaMeeting.
     * @param {PtaMeetingUpdateArgs} args - Arguments to update one PtaMeeting.
     * @example
     * // Update one PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PtaMeetingUpdateArgs>(args: SelectSubset<T, PtaMeetingUpdateArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PtaMeetings.
     * @param {PtaMeetingDeleteManyArgs} args - Arguments to filter PtaMeetings to delete.
     * @example
     * // Delete a few PtaMeetings
     * const { count } = await prisma.ptaMeeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PtaMeetingDeleteManyArgs>(args?: SelectSubset<T, PtaMeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PtaMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PtaMeetings
     * const ptaMeeting = await prisma.ptaMeeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PtaMeetingUpdateManyArgs>(args: SelectSubset<T, PtaMeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PtaMeeting.
     * @param {PtaMeetingUpsertArgs} args - Arguments to update or create a PtaMeeting.
     * @example
     * // Update or create a PtaMeeting
     * const ptaMeeting = await prisma.ptaMeeting.upsert({
     *   create: {
     *     // ... data to create a PtaMeeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PtaMeeting we want to update
     *   }
     * })
     */
    upsert<T extends PtaMeetingUpsertArgs>(args: SelectSubset<T, PtaMeetingUpsertArgs<ExtArgs>>): Prisma__PtaMeetingClient<$Result.GetResult<Prisma.$PtaMeetingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PtaMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingCountArgs} args - Arguments to filter PtaMeetings to count.
     * @example
     * // Count the number of PtaMeetings
     * const count = await prisma.ptaMeeting.count({
     *   where: {
     *     // ... the filter for the PtaMeetings we want to count
     *   }
     * })
    **/
    count<T extends PtaMeetingCountArgs>(
      args?: Subset<T, PtaMeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PtaMeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PtaMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PtaMeetingAggregateArgs>(args: Subset<T, PtaMeetingAggregateArgs>): Prisma.PrismaPromise<GetPtaMeetingAggregateType<T>>

    /**
     * Group by PtaMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PtaMeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PtaMeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PtaMeetingGroupByArgs['orderBy'] }
        : { orderBy?: PtaMeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PtaMeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPtaMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PtaMeeting model
   */
  readonly fields: PtaMeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PtaMeeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PtaMeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PtaMeeting model
   */ 
  interface PtaMeetingFieldRefs {
    readonly id: FieldRef<"PtaMeeting", 'Int'>
    readonly title: FieldRef<"PtaMeeting", 'String'>
    readonly date: FieldRef<"PtaMeeting", 'DateTime'>
    readonly agenda: FieldRef<"PtaMeeting", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PtaMeeting findUnique
   */
  export type PtaMeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter, which PtaMeeting to fetch.
     */
    where: PtaMeetingWhereUniqueInput
  }

  /**
   * PtaMeeting findUniqueOrThrow
   */
  export type PtaMeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter, which PtaMeeting to fetch.
     */
    where: PtaMeetingWhereUniqueInput
  }

  /**
   * PtaMeeting findFirst
   */
  export type PtaMeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter, which PtaMeeting to fetch.
     */
    where?: PtaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PtaMeetings to fetch.
     */
    orderBy?: PtaMeetingOrderByWithRelationInput | PtaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PtaMeetings.
     */
    cursor?: PtaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PtaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PtaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PtaMeetings.
     */
    distinct?: PtaMeetingScalarFieldEnum | PtaMeetingScalarFieldEnum[]
  }

  /**
   * PtaMeeting findFirstOrThrow
   */
  export type PtaMeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter, which PtaMeeting to fetch.
     */
    where?: PtaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PtaMeetings to fetch.
     */
    orderBy?: PtaMeetingOrderByWithRelationInput | PtaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PtaMeetings.
     */
    cursor?: PtaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PtaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PtaMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PtaMeetings.
     */
    distinct?: PtaMeetingScalarFieldEnum | PtaMeetingScalarFieldEnum[]
  }

  /**
   * PtaMeeting findMany
   */
  export type PtaMeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter, which PtaMeetings to fetch.
     */
    where?: PtaMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PtaMeetings to fetch.
     */
    orderBy?: PtaMeetingOrderByWithRelationInput | PtaMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PtaMeetings.
     */
    cursor?: PtaMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PtaMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PtaMeetings.
     */
    skip?: number
    distinct?: PtaMeetingScalarFieldEnum | PtaMeetingScalarFieldEnum[]
  }

  /**
   * PtaMeeting create
   */
  export type PtaMeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * The data needed to create a PtaMeeting.
     */
    data: XOR<PtaMeetingCreateInput, PtaMeetingUncheckedCreateInput>
  }

  /**
   * PtaMeeting createMany
   */
  export type PtaMeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PtaMeetings.
     */
    data: PtaMeetingCreateManyInput | PtaMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PtaMeeting createManyAndReturn
   */
  export type PtaMeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PtaMeetings.
     */
    data: PtaMeetingCreateManyInput | PtaMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PtaMeeting update
   */
  export type PtaMeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * The data needed to update a PtaMeeting.
     */
    data: XOR<PtaMeetingUpdateInput, PtaMeetingUncheckedUpdateInput>
    /**
     * Choose, which PtaMeeting to update.
     */
    where: PtaMeetingWhereUniqueInput
  }

  /**
   * PtaMeeting updateMany
   */
  export type PtaMeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PtaMeetings.
     */
    data: XOR<PtaMeetingUpdateManyMutationInput, PtaMeetingUncheckedUpdateManyInput>
    /**
     * Filter which PtaMeetings to update
     */
    where?: PtaMeetingWhereInput
  }

  /**
   * PtaMeeting upsert
   */
  export type PtaMeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * The filter to search for the PtaMeeting to update in case it exists.
     */
    where: PtaMeetingWhereUniqueInput
    /**
     * In case the PtaMeeting found by the `where` argument doesn't exist, create a new PtaMeeting with this data.
     */
    create: XOR<PtaMeetingCreateInput, PtaMeetingUncheckedCreateInput>
    /**
     * In case the PtaMeeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PtaMeetingUpdateInput, PtaMeetingUncheckedUpdateInput>
  }

  /**
   * PtaMeeting delete
   */
  export type PtaMeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
    /**
     * Filter which PtaMeeting to delete.
     */
    where: PtaMeetingWhereUniqueInput
  }

  /**
   * PtaMeeting deleteMany
   */
  export type PtaMeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PtaMeetings to delete
     */
    where?: PtaMeetingWhereInput
  }

  /**
   * PtaMeeting without action
   */
  export type PtaMeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PtaMeeting
     */
    select?: PtaMeetingSelect<ExtArgs> | null
  }


  /**
   * Model SchoolPolicy
   */

  export type AggregateSchoolPolicy = {
    _count: SchoolPolicyCountAggregateOutputType | null
    _avg: SchoolPolicyAvgAggregateOutputType | null
    _sum: SchoolPolicySumAggregateOutputType | null
    _min: SchoolPolicyMinAggregateOutputType | null
    _max: SchoolPolicyMaxAggregateOutputType | null
  }

  export type SchoolPolicyAvgAggregateOutputType = {
    id: number | null
  }

  export type SchoolPolicySumAggregateOutputType = {
    id: number | null
  }

  export type SchoolPolicyMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    url: string | null
  }

  export type SchoolPolicyMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    url: string | null
  }

  export type SchoolPolicyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    _all: number
  }


  export type SchoolPolicyAvgAggregateInputType = {
    id?: true
  }

  export type SchoolPolicySumAggregateInputType = {
    id?: true
  }

  export type SchoolPolicyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
  }

  export type SchoolPolicyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
  }

  export type SchoolPolicyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    _all?: true
  }

  export type SchoolPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolPolicy to aggregate.
     */
    where?: SchoolPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPolicies to fetch.
     */
    orderBy?: SchoolPolicyOrderByWithRelationInput | SchoolPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolPolicies
    **/
    _count?: true | SchoolPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolPolicyMaxAggregateInputType
  }

  export type GetSchoolPolicyAggregateType<T extends SchoolPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolPolicy[P]>
      : GetScalarType<T[P], AggregateSchoolPolicy[P]>
  }




  export type SchoolPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolPolicyWhereInput
    orderBy?: SchoolPolicyOrderByWithAggregationInput | SchoolPolicyOrderByWithAggregationInput[]
    by: SchoolPolicyScalarFieldEnum[] | SchoolPolicyScalarFieldEnum
    having?: SchoolPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolPolicyCountAggregateInputType | true
    _avg?: SchoolPolicyAvgAggregateInputType
    _sum?: SchoolPolicySumAggregateInputType
    _min?: SchoolPolicyMinAggregateInputType
    _max?: SchoolPolicyMaxAggregateInputType
  }

  export type SchoolPolicyGroupByOutputType = {
    id: number
    title: string
    description: string | null
    url: string | null
    _count: SchoolPolicyCountAggregateOutputType | null
    _avg: SchoolPolicyAvgAggregateOutputType | null
    _sum: SchoolPolicySumAggregateOutputType | null
    _min: SchoolPolicyMinAggregateOutputType | null
    _max: SchoolPolicyMaxAggregateOutputType | null
  }

  type GetSchoolPolicyGroupByPayload<T extends SchoolPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolPolicyGroupByOutputType[P]>
        }
      >
    >


  export type SchoolPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
  }, ExtArgs["result"]["schoolPolicy"]>

  export type SchoolPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
  }, ExtArgs["result"]["schoolPolicy"]>

  export type SchoolPolicySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
  }


  export type $SchoolPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      url: string | null
    }, ExtArgs["result"]["schoolPolicy"]>
    composites: {}
  }

  type SchoolPolicyGetPayload<S extends boolean | null | undefined | SchoolPolicyDefaultArgs> = $Result.GetResult<Prisma.$SchoolPolicyPayload, S>

  type SchoolPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SchoolPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SchoolPolicyCountAggregateInputType | true
    }

  export interface SchoolPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolPolicy'], meta: { name: 'SchoolPolicy' } }
    /**
     * Find zero or one SchoolPolicy that matches the filter.
     * @param {SchoolPolicyFindUniqueArgs} args - Arguments to find a SchoolPolicy
     * @example
     * // Get one SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolPolicyFindUniqueArgs>(args: SelectSubset<T, SchoolPolicyFindUniqueArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SchoolPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SchoolPolicyFindUniqueOrThrowArgs} args - Arguments to find a SchoolPolicy
     * @example
     * // Get one SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SchoolPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyFindFirstArgs} args - Arguments to find a SchoolPolicy
     * @example
     * // Get one SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolPolicyFindFirstArgs>(args?: SelectSubset<T, SchoolPolicyFindFirstArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SchoolPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyFindFirstOrThrowArgs} args - Arguments to find a SchoolPolicy
     * @example
     * // Get one SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SchoolPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolPolicies
     * const schoolPolicies = await prisma.schoolPolicy.findMany()
     * 
     * // Get first 10 SchoolPolicies
     * const schoolPolicies = await prisma.schoolPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolPolicyWithIdOnly = await prisma.schoolPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolPolicyFindManyArgs>(args?: SelectSubset<T, SchoolPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SchoolPolicy.
     * @param {SchoolPolicyCreateArgs} args - Arguments to create a SchoolPolicy.
     * @example
     * // Create one SchoolPolicy
     * const SchoolPolicy = await prisma.schoolPolicy.create({
     *   data: {
     *     // ... data to create a SchoolPolicy
     *   }
     * })
     * 
     */
    create<T extends SchoolPolicyCreateArgs>(args: SelectSubset<T, SchoolPolicyCreateArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SchoolPolicies.
     * @param {SchoolPolicyCreateManyArgs} args - Arguments to create many SchoolPolicies.
     * @example
     * // Create many SchoolPolicies
     * const schoolPolicy = await prisma.schoolPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolPolicyCreateManyArgs>(args?: SelectSubset<T, SchoolPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolPolicies and returns the data saved in the database.
     * @param {SchoolPolicyCreateManyAndReturnArgs} args - Arguments to create many SchoolPolicies.
     * @example
     * // Create many SchoolPolicies
     * const schoolPolicy = await prisma.schoolPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolPolicies and only return the `id`
     * const schoolPolicyWithIdOnly = await prisma.schoolPolicy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SchoolPolicy.
     * @param {SchoolPolicyDeleteArgs} args - Arguments to delete one SchoolPolicy.
     * @example
     * // Delete one SchoolPolicy
     * const SchoolPolicy = await prisma.schoolPolicy.delete({
     *   where: {
     *     // ... filter to delete one SchoolPolicy
     *   }
     * })
     * 
     */
    delete<T extends SchoolPolicyDeleteArgs>(args: SelectSubset<T, SchoolPolicyDeleteArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SchoolPolicy.
     * @param {SchoolPolicyUpdateArgs} args - Arguments to update one SchoolPolicy.
     * @example
     * // Update one SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolPolicyUpdateArgs>(args: SelectSubset<T, SchoolPolicyUpdateArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SchoolPolicies.
     * @param {SchoolPolicyDeleteManyArgs} args - Arguments to filter SchoolPolicies to delete.
     * @example
     * // Delete a few SchoolPolicies
     * const { count } = await prisma.schoolPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolPolicyDeleteManyArgs>(args?: SelectSubset<T, SchoolPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolPolicies
     * const schoolPolicy = await prisma.schoolPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolPolicyUpdateManyArgs>(args: SelectSubset<T, SchoolPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolPolicy.
     * @param {SchoolPolicyUpsertArgs} args - Arguments to update or create a SchoolPolicy.
     * @example
     * // Update or create a SchoolPolicy
     * const schoolPolicy = await prisma.schoolPolicy.upsert({
     *   create: {
     *     // ... data to create a SchoolPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolPolicy we want to update
     *   }
     * })
     */
    upsert<T extends SchoolPolicyUpsertArgs>(args: SelectSubset<T, SchoolPolicyUpsertArgs<ExtArgs>>): Prisma__SchoolPolicyClient<$Result.GetResult<Prisma.$SchoolPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SchoolPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyCountArgs} args - Arguments to filter SchoolPolicies to count.
     * @example
     * // Count the number of SchoolPolicies
     * const count = await prisma.schoolPolicy.count({
     *   where: {
     *     // ... the filter for the SchoolPolicies we want to count
     *   }
     * })
    **/
    count<T extends SchoolPolicyCountArgs>(
      args?: Subset<T, SchoolPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolPolicyAggregateArgs>(args: Subset<T, SchoolPolicyAggregateArgs>): Prisma.PrismaPromise<GetSchoolPolicyAggregateType<T>>

    /**
     * Group by SchoolPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolPolicyGroupByArgs['orderBy'] }
        : { orderBy?: SchoolPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolPolicy model
   */
  readonly fields: SchoolPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolPolicy model
   */ 
  interface SchoolPolicyFieldRefs {
    readonly id: FieldRef<"SchoolPolicy", 'Int'>
    readonly title: FieldRef<"SchoolPolicy", 'String'>
    readonly description: FieldRef<"SchoolPolicy", 'String'>
    readonly url: FieldRef<"SchoolPolicy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolPolicy findUnique
   */
  export type SchoolPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter, which SchoolPolicy to fetch.
     */
    where: SchoolPolicyWhereUniqueInput
  }

  /**
   * SchoolPolicy findUniqueOrThrow
   */
  export type SchoolPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter, which SchoolPolicy to fetch.
     */
    where: SchoolPolicyWhereUniqueInput
  }

  /**
   * SchoolPolicy findFirst
   */
  export type SchoolPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter, which SchoolPolicy to fetch.
     */
    where?: SchoolPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPolicies to fetch.
     */
    orderBy?: SchoolPolicyOrderByWithRelationInput | SchoolPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPolicies.
     */
    cursor?: SchoolPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPolicies.
     */
    distinct?: SchoolPolicyScalarFieldEnum | SchoolPolicyScalarFieldEnum[]
  }

  /**
   * SchoolPolicy findFirstOrThrow
   */
  export type SchoolPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter, which SchoolPolicy to fetch.
     */
    where?: SchoolPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPolicies to fetch.
     */
    orderBy?: SchoolPolicyOrderByWithRelationInput | SchoolPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPolicies.
     */
    cursor?: SchoolPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPolicies.
     */
    distinct?: SchoolPolicyScalarFieldEnum | SchoolPolicyScalarFieldEnum[]
  }

  /**
   * SchoolPolicy findMany
   */
  export type SchoolPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter, which SchoolPolicies to fetch.
     */
    where?: SchoolPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPolicies to fetch.
     */
    orderBy?: SchoolPolicyOrderByWithRelationInput | SchoolPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolPolicies.
     */
    cursor?: SchoolPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPolicies.
     */
    skip?: number
    distinct?: SchoolPolicyScalarFieldEnum | SchoolPolicyScalarFieldEnum[]
  }

  /**
   * SchoolPolicy create
   */
  export type SchoolPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * The data needed to create a SchoolPolicy.
     */
    data: XOR<SchoolPolicyCreateInput, SchoolPolicyUncheckedCreateInput>
  }

  /**
   * SchoolPolicy createMany
   */
  export type SchoolPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolPolicies.
     */
    data: SchoolPolicyCreateManyInput | SchoolPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolPolicy createManyAndReturn
   */
  export type SchoolPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SchoolPolicies.
     */
    data: SchoolPolicyCreateManyInput | SchoolPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolPolicy update
   */
  export type SchoolPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * The data needed to update a SchoolPolicy.
     */
    data: XOR<SchoolPolicyUpdateInput, SchoolPolicyUncheckedUpdateInput>
    /**
     * Choose, which SchoolPolicy to update.
     */
    where: SchoolPolicyWhereUniqueInput
  }

  /**
   * SchoolPolicy updateMany
   */
  export type SchoolPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolPolicies.
     */
    data: XOR<SchoolPolicyUpdateManyMutationInput, SchoolPolicyUncheckedUpdateManyInput>
    /**
     * Filter which SchoolPolicies to update
     */
    where?: SchoolPolicyWhereInput
  }

  /**
   * SchoolPolicy upsert
   */
  export type SchoolPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * The filter to search for the SchoolPolicy to update in case it exists.
     */
    where: SchoolPolicyWhereUniqueInput
    /**
     * In case the SchoolPolicy found by the `where` argument doesn't exist, create a new SchoolPolicy with this data.
     */
    create: XOR<SchoolPolicyCreateInput, SchoolPolicyUncheckedCreateInput>
    /**
     * In case the SchoolPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolPolicyUpdateInput, SchoolPolicyUncheckedUpdateInput>
  }

  /**
   * SchoolPolicy delete
   */
  export type SchoolPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
    /**
     * Filter which SchoolPolicy to delete.
     */
    where: SchoolPolicyWhereUniqueInput
  }

  /**
   * SchoolPolicy deleteMany
   */
  export type SchoolPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolPolicies to delete
     */
    where?: SchoolPolicyWhereInput
  }

  /**
   * SchoolPolicy without action
   */
  export type SchoolPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPolicy
     */
    select?: SchoolPolicySelect<ExtArgs> | null
  }


  /**
   * Model VolunteeringOpportunity
   */

  export type AggregateVolunteeringOpportunity = {
    _count: VolunteeringOpportunityCountAggregateOutputType | null
    _avg: VolunteeringOpportunityAvgAggregateOutputType | null
    _sum: VolunteeringOpportunitySumAggregateOutputType | null
    _min: VolunteeringOpportunityMinAggregateOutputType | null
    _max: VolunteeringOpportunityMaxAggregateOutputType | null
  }

  export type VolunteeringOpportunityAvgAggregateOutputType = {
    id: number | null
    spotsTotal: number | null
    spotsFilled: number | null
  }

  export type VolunteeringOpportunitySumAggregateOutputType = {
    id: number | null
    spotsTotal: number | null
    spotsFilled: number | null
  }

  export type VolunteeringOpportunityMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    spotsTotal: number | null
    spotsFilled: number | null
  }

  export type VolunteeringOpportunityMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    spotsTotal: number | null
    spotsFilled: number | null
  }

  export type VolunteeringOpportunityCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    spotsTotal: number
    spotsFilled: number
    _all: number
  }


  export type VolunteeringOpportunityAvgAggregateInputType = {
    id?: true
    spotsTotal?: true
    spotsFilled?: true
  }

  export type VolunteeringOpportunitySumAggregateInputType = {
    id?: true
    spotsTotal?: true
    spotsFilled?: true
  }

  export type VolunteeringOpportunityMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    spotsTotal?: true
    spotsFilled?: true
  }

  export type VolunteeringOpportunityMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    spotsTotal?: true
    spotsFilled?: true
  }

  export type VolunteeringOpportunityCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    spotsTotal?: true
    spotsFilled?: true
    _all?: true
  }

  export type VolunteeringOpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteeringOpportunity to aggregate.
     */
    where?: VolunteeringOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteeringOpportunities to fetch.
     */
    orderBy?: VolunteeringOpportunityOrderByWithRelationInput | VolunteeringOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolunteeringOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteeringOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteeringOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolunteeringOpportunities
    **/
    _count?: true | VolunteeringOpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolunteeringOpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolunteeringOpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolunteeringOpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolunteeringOpportunityMaxAggregateInputType
  }

  export type GetVolunteeringOpportunityAggregateType<T extends VolunteeringOpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateVolunteeringOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolunteeringOpportunity[P]>
      : GetScalarType<T[P], AggregateVolunteeringOpportunity[P]>
  }




  export type VolunteeringOpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolunteeringOpportunityWhereInput
    orderBy?: VolunteeringOpportunityOrderByWithAggregationInput | VolunteeringOpportunityOrderByWithAggregationInput[]
    by: VolunteeringOpportunityScalarFieldEnum[] | VolunteeringOpportunityScalarFieldEnum
    having?: VolunteeringOpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolunteeringOpportunityCountAggregateInputType | true
    _avg?: VolunteeringOpportunityAvgAggregateInputType
    _sum?: VolunteeringOpportunitySumAggregateInputType
    _min?: VolunteeringOpportunityMinAggregateInputType
    _max?: VolunteeringOpportunityMaxAggregateInputType
  }

  export type VolunteeringOpportunityGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: Date | null
    spotsTotal: number | null
    spotsFilled: number | null
    _count: VolunteeringOpportunityCountAggregateOutputType | null
    _avg: VolunteeringOpportunityAvgAggregateOutputType | null
    _sum: VolunteeringOpportunitySumAggregateOutputType | null
    _min: VolunteeringOpportunityMinAggregateOutputType | null
    _max: VolunteeringOpportunityMaxAggregateOutputType | null
  }

  type GetVolunteeringOpportunityGroupByPayload<T extends VolunteeringOpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolunteeringOpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolunteeringOpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolunteeringOpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], VolunteeringOpportunityGroupByOutputType[P]>
        }
      >
    >


  export type VolunteeringOpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    spotsTotal?: boolean
    spotsFilled?: boolean
  }, ExtArgs["result"]["volunteeringOpportunity"]>

  export type VolunteeringOpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    spotsTotal?: boolean
    spotsFilled?: boolean
  }, ExtArgs["result"]["volunteeringOpportunity"]>

  export type VolunteeringOpportunitySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    spotsTotal?: boolean
    spotsFilled?: boolean
  }


  export type $VolunteeringOpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolunteeringOpportunity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: Date | null
      spotsTotal: number | null
      spotsFilled: number | null
    }, ExtArgs["result"]["volunteeringOpportunity"]>
    composites: {}
  }

  type VolunteeringOpportunityGetPayload<S extends boolean | null | undefined | VolunteeringOpportunityDefaultArgs> = $Result.GetResult<Prisma.$VolunteeringOpportunityPayload, S>

  type VolunteeringOpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VolunteeringOpportunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VolunteeringOpportunityCountAggregateInputType | true
    }

  export interface VolunteeringOpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolunteeringOpportunity'], meta: { name: 'VolunteeringOpportunity' } }
    /**
     * Find zero or one VolunteeringOpportunity that matches the filter.
     * @param {VolunteeringOpportunityFindUniqueArgs} args - Arguments to find a VolunteeringOpportunity
     * @example
     * // Get one VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolunteeringOpportunityFindUniqueArgs>(args: SelectSubset<T, VolunteeringOpportunityFindUniqueArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VolunteeringOpportunity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VolunteeringOpportunityFindUniqueOrThrowArgs} args - Arguments to find a VolunteeringOpportunity
     * @example
     * // Get one VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolunteeringOpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, VolunteeringOpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VolunteeringOpportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityFindFirstArgs} args - Arguments to find a VolunteeringOpportunity
     * @example
     * // Get one VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolunteeringOpportunityFindFirstArgs>(args?: SelectSubset<T, VolunteeringOpportunityFindFirstArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VolunteeringOpportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityFindFirstOrThrowArgs} args - Arguments to find a VolunteeringOpportunity
     * @example
     * // Get one VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolunteeringOpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, VolunteeringOpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VolunteeringOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolunteeringOpportunities
     * const volunteeringOpportunities = await prisma.volunteeringOpportunity.findMany()
     * 
     * // Get first 10 VolunteeringOpportunities
     * const volunteeringOpportunities = await prisma.volunteeringOpportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volunteeringOpportunityWithIdOnly = await prisma.volunteeringOpportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolunteeringOpportunityFindManyArgs>(args?: SelectSubset<T, VolunteeringOpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VolunteeringOpportunity.
     * @param {VolunteeringOpportunityCreateArgs} args - Arguments to create a VolunteeringOpportunity.
     * @example
     * // Create one VolunteeringOpportunity
     * const VolunteeringOpportunity = await prisma.volunteeringOpportunity.create({
     *   data: {
     *     // ... data to create a VolunteeringOpportunity
     *   }
     * })
     * 
     */
    create<T extends VolunteeringOpportunityCreateArgs>(args: SelectSubset<T, VolunteeringOpportunityCreateArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VolunteeringOpportunities.
     * @param {VolunteeringOpportunityCreateManyArgs} args - Arguments to create many VolunteeringOpportunities.
     * @example
     * // Create many VolunteeringOpportunities
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolunteeringOpportunityCreateManyArgs>(args?: SelectSubset<T, VolunteeringOpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolunteeringOpportunities and returns the data saved in the database.
     * @param {VolunteeringOpportunityCreateManyAndReturnArgs} args - Arguments to create many VolunteeringOpportunities.
     * @example
     * // Create many VolunteeringOpportunities
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolunteeringOpportunities and only return the `id`
     * const volunteeringOpportunityWithIdOnly = await prisma.volunteeringOpportunity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolunteeringOpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, VolunteeringOpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VolunteeringOpportunity.
     * @param {VolunteeringOpportunityDeleteArgs} args - Arguments to delete one VolunteeringOpportunity.
     * @example
     * // Delete one VolunteeringOpportunity
     * const VolunteeringOpportunity = await prisma.volunteeringOpportunity.delete({
     *   where: {
     *     // ... filter to delete one VolunteeringOpportunity
     *   }
     * })
     * 
     */
    delete<T extends VolunteeringOpportunityDeleteArgs>(args: SelectSubset<T, VolunteeringOpportunityDeleteArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VolunteeringOpportunity.
     * @param {VolunteeringOpportunityUpdateArgs} args - Arguments to update one VolunteeringOpportunity.
     * @example
     * // Update one VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolunteeringOpportunityUpdateArgs>(args: SelectSubset<T, VolunteeringOpportunityUpdateArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VolunteeringOpportunities.
     * @param {VolunteeringOpportunityDeleteManyArgs} args - Arguments to filter VolunteeringOpportunities to delete.
     * @example
     * // Delete a few VolunteeringOpportunities
     * const { count } = await prisma.volunteeringOpportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolunteeringOpportunityDeleteManyArgs>(args?: SelectSubset<T, VolunteeringOpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolunteeringOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolunteeringOpportunities
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolunteeringOpportunityUpdateManyArgs>(args: SelectSubset<T, VolunteeringOpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VolunteeringOpportunity.
     * @param {VolunteeringOpportunityUpsertArgs} args - Arguments to update or create a VolunteeringOpportunity.
     * @example
     * // Update or create a VolunteeringOpportunity
     * const volunteeringOpportunity = await prisma.volunteeringOpportunity.upsert({
     *   create: {
     *     // ... data to create a VolunteeringOpportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolunteeringOpportunity we want to update
     *   }
     * })
     */
    upsert<T extends VolunteeringOpportunityUpsertArgs>(args: SelectSubset<T, VolunteeringOpportunityUpsertArgs<ExtArgs>>): Prisma__VolunteeringOpportunityClient<$Result.GetResult<Prisma.$VolunteeringOpportunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VolunteeringOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityCountArgs} args - Arguments to filter VolunteeringOpportunities to count.
     * @example
     * // Count the number of VolunteeringOpportunities
     * const count = await prisma.volunteeringOpportunity.count({
     *   where: {
     *     // ... the filter for the VolunteeringOpportunities we want to count
     *   }
     * })
    **/
    count<T extends VolunteeringOpportunityCountArgs>(
      args?: Subset<T, VolunteeringOpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolunteeringOpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolunteeringOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolunteeringOpportunityAggregateArgs>(args: Subset<T, VolunteeringOpportunityAggregateArgs>): Prisma.PrismaPromise<GetVolunteeringOpportunityAggregateType<T>>

    /**
     * Group by VolunteeringOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolunteeringOpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolunteeringOpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolunteeringOpportunityGroupByArgs['orderBy'] }
        : { orderBy?: VolunteeringOpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolunteeringOpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolunteeringOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolunteeringOpportunity model
   */
  readonly fields: VolunteeringOpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolunteeringOpportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolunteeringOpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolunteeringOpportunity model
   */ 
  interface VolunteeringOpportunityFieldRefs {
    readonly id: FieldRef<"VolunteeringOpportunity", 'Int'>
    readonly title: FieldRef<"VolunteeringOpportunity", 'String'>
    readonly description: FieldRef<"VolunteeringOpportunity", 'String'>
    readonly date: FieldRef<"VolunteeringOpportunity", 'DateTime'>
    readonly spotsTotal: FieldRef<"VolunteeringOpportunity", 'Int'>
    readonly spotsFilled: FieldRef<"VolunteeringOpportunity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VolunteeringOpportunity findUnique
   */
  export type VolunteeringOpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter, which VolunteeringOpportunity to fetch.
     */
    where: VolunteeringOpportunityWhereUniqueInput
  }

  /**
   * VolunteeringOpportunity findUniqueOrThrow
   */
  export type VolunteeringOpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter, which VolunteeringOpportunity to fetch.
     */
    where: VolunteeringOpportunityWhereUniqueInput
  }

  /**
   * VolunteeringOpportunity findFirst
   */
  export type VolunteeringOpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter, which VolunteeringOpportunity to fetch.
     */
    where?: VolunteeringOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteeringOpportunities to fetch.
     */
    orderBy?: VolunteeringOpportunityOrderByWithRelationInput | VolunteeringOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteeringOpportunities.
     */
    cursor?: VolunteeringOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteeringOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteeringOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteeringOpportunities.
     */
    distinct?: VolunteeringOpportunityScalarFieldEnum | VolunteeringOpportunityScalarFieldEnum[]
  }

  /**
   * VolunteeringOpportunity findFirstOrThrow
   */
  export type VolunteeringOpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter, which VolunteeringOpportunity to fetch.
     */
    where?: VolunteeringOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteeringOpportunities to fetch.
     */
    orderBy?: VolunteeringOpportunityOrderByWithRelationInput | VolunteeringOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolunteeringOpportunities.
     */
    cursor?: VolunteeringOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteeringOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteeringOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolunteeringOpportunities.
     */
    distinct?: VolunteeringOpportunityScalarFieldEnum | VolunteeringOpportunityScalarFieldEnum[]
  }

  /**
   * VolunteeringOpportunity findMany
   */
  export type VolunteeringOpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter, which VolunteeringOpportunities to fetch.
     */
    where?: VolunteeringOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolunteeringOpportunities to fetch.
     */
    orderBy?: VolunteeringOpportunityOrderByWithRelationInput | VolunteeringOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolunteeringOpportunities.
     */
    cursor?: VolunteeringOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolunteeringOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolunteeringOpportunities.
     */
    skip?: number
    distinct?: VolunteeringOpportunityScalarFieldEnum | VolunteeringOpportunityScalarFieldEnum[]
  }

  /**
   * VolunteeringOpportunity create
   */
  export type VolunteeringOpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * The data needed to create a VolunteeringOpportunity.
     */
    data: XOR<VolunteeringOpportunityCreateInput, VolunteeringOpportunityUncheckedCreateInput>
  }

  /**
   * VolunteeringOpportunity createMany
   */
  export type VolunteeringOpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolunteeringOpportunities.
     */
    data: VolunteeringOpportunityCreateManyInput | VolunteeringOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VolunteeringOpportunity createManyAndReturn
   */
  export type VolunteeringOpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VolunteeringOpportunities.
     */
    data: VolunteeringOpportunityCreateManyInput | VolunteeringOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VolunteeringOpportunity update
   */
  export type VolunteeringOpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * The data needed to update a VolunteeringOpportunity.
     */
    data: XOR<VolunteeringOpportunityUpdateInput, VolunteeringOpportunityUncheckedUpdateInput>
    /**
     * Choose, which VolunteeringOpportunity to update.
     */
    where: VolunteeringOpportunityWhereUniqueInput
  }

  /**
   * VolunteeringOpportunity updateMany
   */
  export type VolunteeringOpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolunteeringOpportunities.
     */
    data: XOR<VolunteeringOpportunityUpdateManyMutationInput, VolunteeringOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which VolunteeringOpportunities to update
     */
    where?: VolunteeringOpportunityWhereInput
  }

  /**
   * VolunteeringOpportunity upsert
   */
  export type VolunteeringOpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * The filter to search for the VolunteeringOpportunity to update in case it exists.
     */
    where: VolunteeringOpportunityWhereUniqueInput
    /**
     * In case the VolunteeringOpportunity found by the `where` argument doesn't exist, create a new VolunteeringOpportunity with this data.
     */
    create: XOR<VolunteeringOpportunityCreateInput, VolunteeringOpportunityUncheckedCreateInput>
    /**
     * In case the VolunteeringOpportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolunteeringOpportunityUpdateInput, VolunteeringOpportunityUncheckedUpdateInput>
  }

  /**
   * VolunteeringOpportunity delete
   */
  export type VolunteeringOpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
    /**
     * Filter which VolunteeringOpportunity to delete.
     */
    where: VolunteeringOpportunityWhereUniqueInput
  }

  /**
   * VolunteeringOpportunity deleteMany
   */
  export type VolunteeringOpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolunteeringOpportunities to delete
     */
    where?: VolunteeringOpportunityWhereInput
  }

  /**
   * VolunteeringOpportunity without action
   */
  export type VolunteeringOpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolunteeringOpportunity
     */
    select?: VolunteeringOpportunitySelect<ExtArgs> | null
  }


  /**
   * Model PermissionSlip
   */

  export type AggregatePermissionSlip = {
    _count: PermissionSlipCountAggregateOutputType | null
    _avg: PermissionSlipAvgAggregateOutputType | null
    _sum: PermissionSlipSumAggregateOutputType | null
    _min: PermissionSlipMinAggregateOutputType | null
    _max: PermissionSlipMaxAggregateOutputType | null
  }

  export type PermissionSlipAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type PermissionSlipSumAggregateOutputType = {
    id: number | null
    studentId: number | null
  }

  export type PermissionSlipMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    title: string | null
    description: string | null
    location: string | null
    date: Date | null
    status: string | null
  }

  export type PermissionSlipMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    title: string | null
    description: string | null
    location: string | null
    date: Date | null
    status: string | null
  }

  export type PermissionSlipCountAggregateOutputType = {
    id: number
    studentId: number
    title: number
    description: number
    location: number
    date: number
    status: number
    _all: number
  }


  export type PermissionSlipAvgAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type PermissionSlipSumAggregateInputType = {
    id?: true
    studentId?: true
  }

  export type PermissionSlipMinAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    location?: true
    date?: true
    status?: true
  }

  export type PermissionSlipMaxAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    location?: true
    date?: true
    status?: true
  }

  export type PermissionSlipCountAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    location?: true
    date?: true
    status?: true
    _all?: true
  }

  export type PermissionSlipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionSlip to aggregate.
     */
    where?: PermissionSlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionSlips to fetch.
     */
    orderBy?: PermissionSlipOrderByWithRelationInput | PermissionSlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionSlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionSlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionSlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermissionSlips
    **/
    _count?: true | PermissionSlipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionSlipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSlipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionSlipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionSlipMaxAggregateInputType
  }

  export type GetPermissionSlipAggregateType<T extends PermissionSlipAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionSlip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionSlip[P]>
      : GetScalarType<T[P], AggregatePermissionSlip[P]>
  }




  export type PermissionSlipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionSlipWhereInput
    orderBy?: PermissionSlipOrderByWithAggregationInput | PermissionSlipOrderByWithAggregationInput[]
    by: PermissionSlipScalarFieldEnum[] | PermissionSlipScalarFieldEnum
    having?: PermissionSlipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionSlipCountAggregateInputType | true
    _avg?: PermissionSlipAvgAggregateInputType
    _sum?: PermissionSlipSumAggregateInputType
    _min?: PermissionSlipMinAggregateInputType
    _max?: PermissionSlipMaxAggregateInputType
  }

  export type PermissionSlipGroupByOutputType = {
    id: number
    studentId: number | null
    title: string
    description: string | null
    location: string | null
    date: Date | null
    status: string | null
    _count: PermissionSlipCountAggregateOutputType | null
    _avg: PermissionSlipAvgAggregateOutputType | null
    _sum: PermissionSlipSumAggregateOutputType | null
    _min: PermissionSlipMinAggregateOutputType | null
    _max: PermissionSlipMaxAggregateOutputType | null
  }

  type GetPermissionSlipGroupByPayload<T extends PermissionSlipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionSlipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionSlipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionSlipGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionSlipGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSlipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    status?: boolean
    student?: boolean | PermissionSlip$studentArgs<ExtArgs>
  }, ExtArgs["result"]["permissionSlip"]>

  export type PermissionSlipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    status?: boolean
    student?: boolean | PermissionSlip$studentArgs<ExtArgs>
  }, ExtArgs["result"]["permissionSlip"]>

  export type PermissionSlipSelectScalar = {
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    date?: boolean
    status?: boolean
  }

  export type PermissionSlipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | PermissionSlip$studentArgs<ExtArgs>
  }
  export type PermissionSlipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | PermissionSlip$studentArgs<ExtArgs>
  }

  export type $PermissionSlipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermissionSlip"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number | null
      title: string
      description: string | null
      location: string | null
      date: Date | null
      status: string | null
    }, ExtArgs["result"]["permissionSlip"]>
    composites: {}
  }

  type PermissionSlipGetPayload<S extends boolean | null | undefined | PermissionSlipDefaultArgs> = $Result.GetResult<Prisma.$PermissionSlipPayload, S>

  type PermissionSlipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionSlipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionSlipCountAggregateInputType | true
    }

  export interface PermissionSlipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermissionSlip'], meta: { name: 'PermissionSlip' } }
    /**
     * Find zero or one PermissionSlip that matches the filter.
     * @param {PermissionSlipFindUniqueArgs} args - Arguments to find a PermissionSlip
     * @example
     * // Get one PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionSlipFindUniqueArgs>(args: SelectSubset<T, PermissionSlipFindUniqueArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PermissionSlip that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionSlipFindUniqueOrThrowArgs} args - Arguments to find a PermissionSlip
     * @example
     * // Get one PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionSlipFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionSlipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PermissionSlip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipFindFirstArgs} args - Arguments to find a PermissionSlip
     * @example
     * // Get one PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionSlipFindFirstArgs>(args?: SelectSubset<T, PermissionSlipFindFirstArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PermissionSlip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipFindFirstOrThrowArgs} args - Arguments to find a PermissionSlip
     * @example
     * // Get one PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionSlipFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionSlipFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PermissionSlips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissionSlips
     * const permissionSlips = await prisma.permissionSlip.findMany()
     * 
     * // Get first 10 PermissionSlips
     * const permissionSlips = await prisma.permissionSlip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionSlipWithIdOnly = await prisma.permissionSlip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionSlipFindManyArgs>(args?: SelectSubset<T, PermissionSlipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PermissionSlip.
     * @param {PermissionSlipCreateArgs} args - Arguments to create a PermissionSlip.
     * @example
     * // Create one PermissionSlip
     * const PermissionSlip = await prisma.permissionSlip.create({
     *   data: {
     *     // ... data to create a PermissionSlip
     *   }
     * })
     * 
     */
    create<T extends PermissionSlipCreateArgs>(args: SelectSubset<T, PermissionSlipCreateArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PermissionSlips.
     * @param {PermissionSlipCreateManyArgs} args - Arguments to create many PermissionSlips.
     * @example
     * // Create many PermissionSlips
     * const permissionSlip = await prisma.permissionSlip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionSlipCreateManyArgs>(args?: SelectSubset<T, PermissionSlipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermissionSlips and returns the data saved in the database.
     * @param {PermissionSlipCreateManyAndReturnArgs} args - Arguments to create many PermissionSlips.
     * @example
     * // Create many PermissionSlips
     * const permissionSlip = await prisma.permissionSlip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermissionSlips and only return the `id`
     * const permissionSlipWithIdOnly = await prisma.permissionSlip.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionSlipCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionSlipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PermissionSlip.
     * @param {PermissionSlipDeleteArgs} args - Arguments to delete one PermissionSlip.
     * @example
     * // Delete one PermissionSlip
     * const PermissionSlip = await prisma.permissionSlip.delete({
     *   where: {
     *     // ... filter to delete one PermissionSlip
     *   }
     * })
     * 
     */
    delete<T extends PermissionSlipDeleteArgs>(args: SelectSubset<T, PermissionSlipDeleteArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PermissionSlip.
     * @param {PermissionSlipUpdateArgs} args - Arguments to update one PermissionSlip.
     * @example
     * // Update one PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionSlipUpdateArgs>(args: SelectSubset<T, PermissionSlipUpdateArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PermissionSlips.
     * @param {PermissionSlipDeleteManyArgs} args - Arguments to filter PermissionSlips to delete.
     * @example
     * // Delete a few PermissionSlips
     * const { count } = await prisma.permissionSlip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionSlipDeleteManyArgs>(args?: SelectSubset<T, PermissionSlipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissionSlips
     * const permissionSlip = await prisma.permissionSlip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionSlipUpdateManyArgs>(args: SelectSubset<T, PermissionSlipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PermissionSlip.
     * @param {PermissionSlipUpsertArgs} args - Arguments to update or create a PermissionSlip.
     * @example
     * // Update or create a PermissionSlip
     * const permissionSlip = await prisma.permissionSlip.upsert({
     *   create: {
     *     // ... data to create a PermissionSlip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissionSlip we want to update
     *   }
     * })
     */
    upsert<T extends PermissionSlipUpsertArgs>(args: SelectSubset<T, PermissionSlipUpsertArgs<ExtArgs>>): Prisma__PermissionSlipClient<$Result.GetResult<Prisma.$PermissionSlipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PermissionSlips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipCountArgs} args - Arguments to filter PermissionSlips to count.
     * @example
     * // Count the number of PermissionSlips
     * const count = await prisma.permissionSlip.count({
     *   where: {
     *     // ... the filter for the PermissionSlips we want to count
     *   }
     * })
    **/
    count<T extends PermissionSlipCountArgs>(
      args?: Subset<T, PermissionSlipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionSlipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissionSlip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionSlipAggregateArgs>(args: Subset<T, PermissionSlipAggregateArgs>): Prisma.PrismaPromise<GetPermissionSlipAggregateType<T>>

    /**
     * Group by PermissionSlip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionSlipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionSlipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionSlipGroupByArgs['orderBy'] }
        : { orderBy?: PermissionSlipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionSlipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionSlipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermissionSlip model
   */
  readonly fields: PermissionSlipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermissionSlip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionSlipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends PermissionSlip$studentArgs<ExtArgs> = {}>(args?: Subset<T, PermissionSlip$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermissionSlip model
   */ 
  interface PermissionSlipFieldRefs {
    readonly id: FieldRef<"PermissionSlip", 'Int'>
    readonly studentId: FieldRef<"PermissionSlip", 'Int'>
    readonly title: FieldRef<"PermissionSlip", 'String'>
    readonly description: FieldRef<"PermissionSlip", 'String'>
    readonly location: FieldRef<"PermissionSlip", 'String'>
    readonly date: FieldRef<"PermissionSlip", 'DateTime'>
    readonly status: FieldRef<"PermissionSlip", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PermissionSlip findUnique
   */
  export type PermissionSlipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter, which PermissionSlip to fetch.
     */
    where: PermissionSlipWhereUniqueInput
  }

  /**
   * PermissionSlip findUniqueOrThrow
   */
  export type PermissionSlipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter, which PermissionSlip to fetch.
     */
    where: PermissionSlipWhereUniqueInput
  }

  /**
   * PermissionSlip findFirst
   */
  export type PermissionSlipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter, which PermissionSlip to fetch.
     */
    where?: PermissionSlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionSlips to fetch.
     */
    orderBy?: PermissionSlipOrderByWithRelationInput | PermissionSlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionSlips.
     */
    cursor?: PermissionSlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionSlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionSlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionSlips.
     */
    distinct?: PermissionSlipScalarFieldEnum | PermissionSlipScalarFieldEnum[]
  }

  /**
   * PermissionSlip findFirstOrThrow
   */
  export type PermissionSlipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter, which PermissionSlip to fetch.
     */
    where?: PermissionSlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionSlips to fetch.
     */
    orderBy?: PermissionSlipOrderByWithRelationInput | PermissionSlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionSlips.
     */
    cursor?: PermissionSlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionSlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionSlips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionSlips.
     */
    distinct?: PermissionSlipScalarFieldEnum | PermissionSlipScalarFieldEnum[]
  }

  /**
   * PermissionSlip findMany
   */
  export type PermissionSlipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter, which PermissionSlips to fetch.
     */
    where?: PermissionSlipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionSlips to fetch.
     */
    orderBy?: PermissionSlipOrderByWithRelationInput | PermissionSlipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermissionSlips.
     */
    cursor?: PermissionSlipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionSlips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionSlips.
     */
    skip?: number
    distinct?: PermissionSlipScalarFieldEnum | PermissionSlipScalarFieldEnum[]
  }

  /**
   * PermissionSlip create
   */
  export type PermissionSlipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * The data needed to create a PermissionSlip.
     */
    data: XOR<PermissionSlipCreateInput, PermissionSlipUncheckedCreateInput>
  }

  /**
   * PermissionSlip createMany
   */
  export type PermissionSlipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermissionSlips.
     */
    data: PermissionSlipCreateManyInput | PermissionSlipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermissionSlip createManyAndReturn
   */
  export type PermissionSlipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PermissionSlips.
     */
    data: PermissionSlipCreateManyInput | PermissionSlipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionSlip update
   */
  export type PermissionSlipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * The data needed to update a PermissionSlip.
     */
    data: XOR<PermissionSlipUpdateInput, PermissionSlipUncheckedUpdateInput>
    /**
     * Choose, which PermissionSlip to update.
     */
    where: PermissionSlipWhereUniqueInput
  }

  /**
   * PermissionSlip updateMany
   */
  export type PermissionSlipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermissionSlips.
     */
    data: XOR<PermissionSlipUpdateManyMutationInput, PermissionSlipUncheckedUpdateManyInput>
    /**
     * Filter which PermissionSlips to update
     */
    where?: PermissionSlipWhereInput
  }

  /**
   * PermissionSlip upsert
   */
  export type PermissionSlipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * The filter to search for the PermissionSlip to update in case it exists.
     */
    where: PermissionSlipWhereUniqueInput
    /**
     * In case the PermissionSlip found by the `where` argument doesn't exist, create a new PermissionSlip with this data.
     */
    create: XOR<PermissionSlipCreateInput, PermissionSlipUncheckedCreateInput>
    /**
     * In case the PermissionSlip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionSlipUpdateInput, PermissionSlipUncheckedUpdateInput>
  }

  /**
   * PermissionSlip delete
   */
  export type PermissionSlipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
    /**
     * Filter which PermissionSlip to delete.
     */
    where: PermissionSlipWhereUniqueInput
  }

  /**
   * PermissionSlip deleteMany
   */
  export type PermissionSlipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionSlips to delete
     */
    where?: PermissionSlipWhereInput
  }

  /**
   * PermissionSlip.student
   */
  export type PermissionSlip$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * PermissionSlip without action
   */
  export type PermissionSlipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionSlip
     */
    select?: PermissionSlipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionSlipInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
    parentId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
    parentId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    parentId: number | null
    date: Date | null
    time: string | null
    reason: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    parentId: number | null
    date: Date | null
    time: string | null
    reason: string | null
    status: string | null
    createdAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    teacherId: number
    parentId: number
    date: number
    time: number
    reason: number
    status: number
    createdAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    teacherId?: true
    parentId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    teacherId?: true
    parentId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    teacherId?: true
    parentId?: true
    date?: true
    time?: true
    reason?: true
    status?: true
    createdAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    teacherId?: true
    parentId?: true
    date?: true
    time?: true
    reason?: true
    status?: true
    createdAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    teacherId?: true
    parentId?: true
    date?: true
    time?: true
    reason?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    teacherId: number | null
    parentId: number | null
    date: Date
    time: string
    reason: string | null
    status: string | null
    createdAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    parentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    teacher?: boolean | Appointment$teacherArgs<ExtArgs>
    parent?: boolean | Appointment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    parentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    teacher?: boolean | Appointment$teacherArgs<ExtArgs>
    parent?: boolean | Appointment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    teacherId?: boolean
    parentId?: boolean
    date?: boolean
    time?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Appointment$teacherArgs<ExtArgs>
    parent?: boolean | Appointment$parentArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Appointment$teacherArgs<ExtArgs>
    parent?: boolean | Appointment$parentArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number | null
      parentId: number | null
      date: Date
      time: string
      reason: string | null
      status: string | null
      createdAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends Appointment$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parent<T extends Appointment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly teacherId: FieldRef<"Appointment", 'Int'>
    readonly parentId: FieldRef<"Appointment", 'Int'>
    readonly date: FieldRef<"Appointment", 'DateTime'>
    readonly time: FieldRef<"Appointment", 'String'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.teacher
   */
  export type Appointment$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * Appointment.parent
   */
  export type Appointment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model PdResource
   */

  export type AggregatePdResource = {
    _count: PdResourceCountAggregateOutputType | null
    _avg: PdResourceAvgAggregateOutputType | null
    _sum: PdResourceSumAggregateOutputType | null
    _min: PdResourceMinAggregateOutputType | null
    _max: PdResourceMaxAggregateOutputType | null
  }

  export type PdResourceAvgAggregateOutputType = {
    id: number | null
  }

  export type PdResourceSumAggregateOutputType = {
    id: number | null
  }

  export type PdResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    source: string | null
    summary: string | null
    url: string | null
  }

  export type PdResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    type: string | null
    source: string | null
    summary: string | null
    url: string | null
  }

  export type PdResourceCountAggregateOutputType = {
    id: number
    title: number
    type: number
    source: number
    summary: number
    url: number
    _all: number
  }


  export type PdResourceAvgAggregateInputType = {
    id?: true
  }

  export type PdResourceSumAggregateInputType = {
    id?: true
  }

  export type PdResourceMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    source?: true
    summary?: true
    url?: true
  }

  export type PdResourceMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    source?: true
    summary?: true
    url?: true
  }

  export type PdResourceCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    source?: true
    summary?: true
    url?: true
    _all?: true
  }

  export type PdResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdResource to aggregate.
     */
    where?: PdResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdResources to fetch.
     */
    orderBy?: PdResourceOrderByWithRelationInput | PdResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PdResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PdResources
    **/
    _count?: true | PdResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PdResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PdResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PdResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PdResourceMaxAggregateInputType
  }

  export type GetPdResourceAggregateType<T extends PdResourceAggregateArgs> = {
        [P in keyof T & keyof AggregatePdResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePdResource[P]>
      : GetScalarType<T[P], AggregatePdResource[P]>
  }




  export type PdResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdResourceWhereInput
    orderBy?: PdResourceOrderByWithAggregationInput | PdResourceOrderByWithAggregationInput[]
    by: PdResourceScalarFieldEnum[] | PdResourceScalarFieldEnum
    having?: PdResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PdResourceCountAggregateInputType | true
    _avg?: PdResourceAvgAggregateInputType
    _sum?: PdResourceSumAggregateInputType
    _min?: PdResourceMinAggregateInputType
    _max?: PdResourceMaxAggregateInputType
  }

  export type PdResourceGroupByOutputType = {
    id: number
    title: string
    type: string
    source: string | null
    summary: string | null
    url: string | null
    _count: PdResourceCountAggregateOutputType | null
    _avg: PdResourceAvgAggregateOutputType | null
    _sum: PdResourceSumAggregateOutputType | null
    _min: PdResourceMinAggregateOutputType | null
    _max: PdResourceMaxAggregateOutputType | null
  }

  type GetPdResourceGroupByPayload<T extends PdResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PdResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PdResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PdResourceGroupByOutputType[P]>
            : GetScalarType<T[P], PdResourceGroupByOutputType[P]>
        }
      >
    >


  export type PdResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    source?: boolean
    summary?: boolean
    url?: boolean
  }, ExtArgs["result"]["pdResource"]>

  export type PdResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    source?: boolean
    summary?: boolean
    url?: boolean
  }, ExtArgs["result"]["pdResource"]>

  export type PdResourceSelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    source?: boolean
    summary?: boolean
    url?: boolean
  }


  export type $PdResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PdResource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      type: string
      source: string | null
      summary: string | null
      url: string | null
    }, ExtArgs["result"]["pdResource"]>
    composites: {}
  }

  type PdResourceGetPayload<S extends boolean | null | undefined | PdResourceDefaultArgs> = $Result.GetResult<Prisma.$PdResourcePayload, S>

  type PdResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PdResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PdResourceCountAggregateInputType | true
    }

  export interface PdResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PdResource'], meta: { name: 'PdResource' } }
    /**
     * Find zero or one PdResource that matches the filter.
     * @param {PdResourceFindUniqueArgs} args - Arguments to find a PdResource
     * @example
     * // Get one PdResource
     * const pdResource = await prisma.pdResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PdResourceFindUniqueArgs>(args: SelectSubset<T, PdResourceFindUniqueArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PdResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PdResourceFindUniqueOrThrowArgs} args - Arguments to find a PdResource
     * @example
     * // Get one PdResource
     * const pdResource = await prisma.pdResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PdResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, PdResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PdResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceFindFirstArgs} args - Arguments to find a PdResource
     * @example
     * // Get one PdResource
     * const pdResource = await prisma.pdResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PdResourceFindFirstArgs>(args?: SelectSubset<T, PdResourceFindFirstArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PdResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceFindFirstOrThrowArgs} args - Arguments to find a PdResource
     * @example
     * // Get one PdResource
     * const pdResource = await prisma.pdResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PdResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, PdResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PdResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PdResources
     * const pdResources = await prisma.pdResource.findMany()
     * 
     * // Get first 10 PdResources
     * const pdResources = await prisma.pdResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pdResourceWithIdOnly = await prisma.pdResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PdResourceFindManyArgs>(args?: SelectSubset<T, PdResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PdResource.
     * @param {PdResourceCreateArgs} args - Arguments to create a PdResource.
     * @example
     * // Create one PdResource
     * const PdResource = await prisma.pdResource.create({
     *   data: {
     *     // ... data to create a PdResource
     *   }
     * })
     * 
     */
    create<T extends PdResourceCreateArgs>(args: SelectSubset<T, PdResourceCreateArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PdResources.
     * @param {PdResourceCreateManyArgs} args - Arguments to create many PdResources.
     * @example
     * // Create many PdResources
     * const pdResource = await prisma.pdResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PdResourceCreateManyArgs>(args?: SelectSubset<T, PdResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PdResources and returns the data saved in the database.
     * @param {PdResourceCreateManyAndReturnArgs} args - Arguments to create many PdResources.
     * @example
     * // Create many PdResources
     * const pdResource = await prisma.pdResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PdResources and only return the `id`
     * const pdResourceWithIdOnly = await prisma.pdResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PdResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, PdResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PdResource.
     * @param {PdResourceDeleteArgs} args - Arguments to delete one PdResource.
     * @example
     * // Delete one PdResource
     * const PdResource = await prisma.pdResource.delete({
     *   where: {
     *     // ... filter to delete one PdResource
     *   }
     * })
     * 
     */
    delete<T extends PdResourceDeleteArgs>(args: SelectSubset<T, PdResourceDeleteArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PdResource.
     * @param {PdResourceUpdateArgs} args - Arguments to update one PdResource.
     * @example
     * // Update one PdResource
     * const pdResource = await prisma.pdResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PdResourceUpdateArgs>(args: SelectSubset<T, PdResourceUpdateArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PdResources.
     * @param {PdResourceDeleteManyArgs} args - Arguments to filter PdResources to delete.
     * @example
     * // Delete a few PdResources
     * const { count } = await prisma.pdResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PdResourceDeleteManyArgs>(args?: SelectSubset<T, PdResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PdResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PdResources
     * const pdResource = await prisma.pdResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PdResourceUpdateManyArgs>(args: SelectSubset<T, PdResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PdResource.
     * @param {PdResourceUpsertArgs} args - Arguments to update or create a PdResource.
     * @example
     * // Update or create a PdResource
     * const pdResource = await prisma.pdResource.upsert({
     *   create: {
     *     // ... data to create a PdResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PdResource we want to update
     *   }
     * })
     */
    upsert<T extends PdResourceUpsertArgs>(args: SelectSubset<T, PdResourceUpsertArgs<ExtArgs>>): Prisma__PdResourceClient<$Result.GetResult<Prisma.$PdResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PdResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceCountArgs} args - Arguments to filter PdResources to count.
     * @example
     * // Count the number of PdResources
     * const count = await prisma.pdResource.count({
     *   where: {
     *     // ... the filter for the PdResources we want to count
     *   }
     * })
    **/
    count<T extends PdResourceCountArgs>(
      args?: Subset<T, PdResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PdResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PdResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PdResourceAggregateArgs>(args: Subset<T, PdResourceAggregateArgs>): Prisma.PrismaPromise<GetPdResourceAggregateType<T>>

    /**
     * Group by PdResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PdResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PdResourceGroupByArgs['orderBy'] }
        : { orderBy?: PdResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PdResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPdResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PdResource model
   */
  readonly fields: PdResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PdResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PdResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PdResource model
   */ 
  interface PdResourceFieldRefs {
    readonly id: FieldRef<"PdResource", 'Int'>
    readonly title: FieldRef<"PdResource", 'String'>
    readonly type: FieldRef<"PdResource", 'String'>
    readonly source: FieldRef<"PdResource", 'String'>
    readonly summary: FieldRef<"PdResource", 'String'>
    readonly url: FieldRef<"PdResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PdResource findUnique
   */
  export type PdResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter, which PdResource to fetch.
     */
    where: PdResourceWhereUniqueInput
  }

  /**
   * PdResource findUniqueOrThrow
   */
  export type PdResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter, which PdResource to fetch.
     */
    where: PdResourceWhereUniqueInput
  }

  /**
   * PdResource findFirst
   */
  export type PdResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter, which PdResource to fetch.
     */
    where?: PdResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdResources to fetch.
     */
    orderBy?: PdResourceOrderByWithRelationInput | PdResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdResources.
     */
    cursor?: PdResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdResources.
     */
    distinct?: PdResourceScalarFieldEnum | PdResourceScalarFieldEnum[]
  }

  /**
   * PdResource findFirstOrThrow
   */
  export type PdResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter, which PdResource to fetch.
     */
    where?: PdResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdResources to fetch.
     */
    orderBy?: PdResourceOrderByWithRelationInput | PdResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdResources.
     */
    cursor?: PdResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdResources.
     */
    distinct?: PdResourceScalarFieldEnum | PdResourceScalarFieldEnum[]
  }

  /**
   * PdResource findMany
   */
  export type PdResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter, which PdResources to fetch.
     */
    where?: PdResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdResources to fetch.
     */
    orderBy?: PdResourceOrderByWithRelationInput | PdResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PdResources.
     */
    cursor?: PdResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdResources.
     */
    skip?: number
    distinct?: PdResourceScalarFieldEnum | PdResourceScalarFieldEnum[]
  }

  /**
   * PdResource create
   */
  export type PdResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * The data needed to create a PdResource.
     */
    data: XOR<PdResourceCreateInput, PdResourceUncheckedCreateInput>
  }

  /**
   * PdResource createMany
   */
  export type PdResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PdResources.
     */
    data: PdResourceCreateManyInput | PdResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdResource createManyAndReturn
   */
  export type PdResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PdResources.
     */
    data: PdResourceCreateManyInput | PdResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdResource update
   */
  export type PdResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * The data needed to update a PdResource.
     */
    data: XOR<PdResourceUpdateInput, PdResourceUncheckedUpdateInput>
    /**
     * Choose, which PdResource to update.
     */
    where: PdResourceWhereUniqueInput
  }

  /**
   * PdResource updateMany
   */
  export type PdResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PdResources.
     */
    data: XOR<PdResourceUpdateManyMutationInput, PdResourceUncheckedUpdateManyInput>
    /**
     * Filter which PdResources to update
     */
    where?: PdResourceWhereInput
  }

  /**
   * PdResource upsert
   */
  export type PdResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * The filter to search for the PdResource to update in case it exists.
     */
    where: PdResourceWhereUniqueInput
    /**
     * In case the PdResource found by the `where` argument doesn't exist, create a new PdResource with this data.
     */
    create: XOR<PdResourceCreateInput, PdResourceUncheckedCreateInput>
    /**
     * In case the PdResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PdResourceUpdateInput, PdResourceUncheckedUpdateInput>
  }

  /**
   * PdResource delete
   */
  export type PdResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
    /**
     * Filter which PdResource to delete.
     */
    where: PdResourceWhereUniqueInput
  }

  /**
   * PdResource deleteMany
   */
  export type PdResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdResources to delete
     */
    where?: PdResourceWhereInput
  }

  /**
   * PdResource without action
   */
  export type PdResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdResource
     */
    select?: PdResourceSelect<ExtArgs> | null
  }


  /**
   * Model AiGame
   */

  export type AggregateAiGame = {
    _count: AiGameCountAggregateOutputType | null
    _avg: AiGameAvgAggregateOutputType | null
    _sum: AiGameSumAggregateOutputType | null
    _min: AiGameMinAggregateOutputType | null
    _max: AiGameMaxAggregateOutputType | null
  }

  export type AiGameAvgAggregateOutputType = {
    creatorId: number | null
  }

  export type AiGameSumAggregateOutputType = {
    creatorId: number | null
  }

  export type AiGameMinAggregateOutputType = {
    id: string | null
    creatorId: number | null
    title: string | null
    subject: string | null
    difficultyLevel: string | null
    status: string | null
  }

  export type AiGameMaxAggregateOutputType = {
    id: string | null
    creatorId: number | null
    title: string | null
    subject: string | null
    difficultyLevel: string | null
    status: string | null
  }

  export type AiGameCountAggregateOutputType = {
    id: number
    creatorId: number
    title: number
    subject: number
    difficultyLevel: number
    status: number
    questions: number
    _all: number
  }


  export type AiGameAvgAggregateInputType = {
    creatorId?: true
  }

  export type AiGameSumAggregateInputType = {
    creatorId?: true
  }

  export type AiGameMinAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    subject?: true
    difficultyLevel?: true
    status?: true
  }

  export type AiGameMaxAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    subject?: true
    difficultyLevel?: true
    status?: true
  }

  export type AiGameCountAggregateInputType = {
    id?: true
    creatorId?: true
    title?: true
    subject?: true
    difficultyLevel?: true
    status?: true
    questions?: true
    _all?: true
  }

  export type AiGameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGame to aggregate.
     */
    where?: AiGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGames to fetch.
     */
    orderBy?: AiGameOrderByWithRelationInput | AiGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiGames
    **/
    _count?: true | AiGameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AiGameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AiGameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiGameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiGameMaxAggregateInputType
  }

  export type GetAiGameAggregateType<T extends AiGameAggregateArgs> = {
        [P in keyof T & keyof AggregateAiGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiGame[P]>
      : GetScalarType<T[P], AggregateAiGame[P]>
  }




  export type AiGameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiGameWhereInput
    orderBy?: AiGameOrderByWithAggregationInput | AiGameOrderByWithAggregationInput[]
    by: AiGameScalarFieldEnum[] | AiGameScalarFieldEnum
    having?: AiGameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiGameCountAggregateInputType | true
    _avg?: AiGameAvgAggregateInputType
    _sum?: AiGameSumAggregateInputType
    _min?: AiGameMinAggregateInputType
    _max?: AiGameMaxAggregateInputType
  }

  export type AiGameGroupByOutputType = {
    id: string
    creatorId: number | null
    title: string
    subject: string | null
    difficultyLevel: string | null
    status: string | null
    questions: JsonValue | null
    _count: AiGameCountAggregateOutputType | null
    _avg: AiGameAvgAggregateOutputType | null
    _sum: AiGameSumAggregateOutputType | null
    _min: AiGameMinAggregateOutputType | null
    _max: AiGameMaxAggregateOutputType | null
  }

  type GetAiGameGroupByPayload<T extends AiGameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiGameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiGameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiGameGroupByOutputType[P]>
            : GetScalarType<T[P], AiGameGroupByOutputType[P]>
        }
      >
    >


  export type AiGameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    subject?: boolean
    difficultyLevel?: boolean
    status?: boolean
    questions?: boolean
    creator?: boolean | AiGame$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["aiGame"]>

  export type AiGameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    title?: boolean
    subject?: boolean
    difficultyLevel?: boolean
    status?: boolean
    questions?: boolean
    creator?: boolean | AiGame$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["aiGame"]>

  export type AiGameSelectScalar = {
    id?: boolean
    creatorId?: boolean
    title?: boolean
    subject?: boolean
    difficultyLevel?: boolean
    status?: boolean
    questions?: boolean
  }

  export type AiGameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AiGame$creatorArgs<ExtArgs>
  }
  export type AiGameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AiGame$creatorArgs<ExtArgs>
  }

  export type $AiGamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiGame"
    objects: {
      creator: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: number | null
      title: string
      subject: string | null
      difficultyLevel: string | null
      status: string | null
      questions: Prisma.JsonValue | null
    }, ExtArgs["result"]["aiGame"]>
    composites: {}
  }

  type AiGameGetPayload<S extends boolean | null | undefined | AiGameDefaultArgs> = $Result.GetResult<Prisma.$AiGamePayload, S>

  type AiGameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiGameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiGameCountAggregateInputType | true
    }

  export interface AiGameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiGame'], meta: { name: 'AiGame' } }
    /**
     * Find zero or one AiGame that matches the filter.
     * @param {AiGameFindUniqueArgs} args - Arguments to find a AiGame
     * @example
     * // Get one AiGame
     * const aiGame = await prisma.aiGame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiGameFindUniqueArgs>(args: SelectSubset<T, AiGameFindUniqueArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiGame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiGameFindUniqueOrThrowArgs} args - Arguments to find a AiGame
     * @example
     * // Get one AiGame
     * const aiGame = await prisma.aiGame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiGameFindUniqueOrThrowArgs>(args: SelectSubset<T, AiGameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiGame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameFindFirstArgs} args - Arguments to find a AiGame
     * @example
     * // Get one AiGame
     * const aiGame = await prisma.aiGame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiGameFindFirstArgs>(args?: SelectSubset<T, AiGameFindFirstArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiGame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameFindFirstOrThrowArgs} args - Arguments to find a AiGame
     * @example
     * // Get one AiGame
     * const aiGame = await prisma.aiGame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiGameFindFirstOrThrowArgs>(args?: SelectSubset<T, AiGameFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiGames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiGames
     * const aiGames = await prisma.aiGame.findMany()
     * 
     * // Get first 10 AiGames
     * const aiGames = await prisma.aiGame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiGameWithIdOnly = await prisma.aiGame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiGameFindManyArgs>(args?: SelectSubset<T, AiGameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiGame.
     * @param {AiGameCreateArgs} args - Arguments to create a AiGame.
     * @example
     * // Create one AiGame
     * const AiGame = await prisma.aiGame.create({
     *   data: {
     *     // ... data to create a AiGame
     *   }
     * })
     * 
     */
    create<T extends AiGameCreateArgs>(args: SelectSubset<T, AiGameCreateArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiGames.
     * @param {AiGameCreateManyArgs} args - Arguments to create many AiGames.
     * @example
     * // Create many AiGames
     * const aiGame = await prisma.aiGame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiGameCreateManyArgs>(args?: SelectSubset<T, AiGameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiGames and returns the data saved in the database.
     * @param {AiGameCreateManyAndReturnArgs} args - Arguments to create many AiGames.
     * @example
     * // Create many AiGames
     * const aiGame = await prisma.aiGame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiGames and only return the `id`
     * const aiGameWithIdOnly = await prisma.aiGame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiGameCreateManyAndReturnArgs>(args?: SelectSubset<T, AiGameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiGame.
     * @param {AiGameDeleteArgs} args - Arguments to delete one AiGame.
     * @example
     * // Delete one AiGame
     * const AiGame = await prisma.aiGame.delete({
     *   where: {
     *     // ... filter to delete one AiGame
     *   }
     * })
     * 
     */
    delete<T extends AiGameDeleteArgs>(args: SelectSubset<T, AiGameDeleteArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiGame.
     * @param {AiGameUpdateArgs} args - Arguments to update one AiGame.
     * @example
     * // Update one AiGame
     * const aiGame = await prisma.aiGame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiGameUpdateArgs>(args: SelectSubset<T, AiGameUpdateArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiGames.
     * @param {AiGameDeleteManyArgs} args - Arguments to filter AiGames to delete.
     * @example
     * // Delete a few AiGames
     * const { count } = await prisma.aiGame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiGameDeleteManyArgs>(args?: SelectSubset<T, AiGameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiGames
     * const aiGame = await prisma.aiGame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiGameUpdateManyArgs>(args: SelectSubset<T, AiGameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiGame.
     * @param {AiGameUpsertArgs} args - Arguments to update or create a AiGame.
     * @example
     * // Update or create a AiGame
     * const aiGame = await prisma.aiGame.upsert({
     *   create: {
     *     // ... data to create a AiGame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiGame we want to update
     *   }
     * })
     */
    upsert<T extends AiGameUpsertArgs>(args: SelectSubset<T, AiGameUpsertArgs<ExtArgs>>): Prisma__AiGameClient<$Result.GetResult<Prisma.$AiGamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiGames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameCountArgs} args - Arguments to filter AiGames to count.
     * @example
     * // Count the number of AiGames
     * const count = await prisma.aiGame.count({
     *   where: {
     *     // ... the filter for the AiGames we want to count
     *   }
     * })
    **/
    count<T extends AiGameCountArgs>(
      args?: Subset<T, AiGameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiGameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiGameAggregateArgs>(args: Subset<T, AiGameAggregateArgs>): Prisma.PrismaPromise<GetAiGameAggregateType<T>>

    /**
     * Group by AiGame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiGameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiGameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiGameGroupByArgs['orderBy'] }
        : { orderBy?: AiGameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiGameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiGame model
   */
  readonly fields: AiGameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiGame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiGameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AiGame$creatorArgs<ExtArgs> = {}>(args?: Subset<T, AiGame$creatorArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiGame model
   */ 
  interface AiGameFieldRefs {
    readonly id: FieldRef<"AiGame", 'String'>
    readonly creatorId: FieldRef<"AiGame", 'Int'>
    readonly title: FieldRef<"AiGame", 'String'>
    readonly subject: FieldRef<"AiGame", 'String'>
    readonly difficultyLevel: FieldRef<"AiGame", 'String'>
    readonly status: FieldRef<"AiGame", 'String'>
    readonly questions: FieldRef<"AiGame", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AiGame findUnique
   */
  export type AiGameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter, which AiGame to fetch.
     */
    where: AiGameWhereUniqueInput
  }

  /**
   * AiGame findUniqueOrThrow
   */
  export type AiGameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter, which AiGame to fetch.
     */
    where: AiGameWhereUniqueInput
  }

  /**
   * AiGame findFirst
   */
  export type AiGameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter, which AiGame to fetch.
     */
    where?: AiGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGames to fetch.
     */
    orderBy?: AiGameOrderByWithRelationInput | AiGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGames.
     */
    cursor?: AiGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGames.
     */
    distinct?: AiGameScalarFieldEnum | AiGameScalarFieldEnum[]
  }

  /**
   * AiGame findFirstOrThrow
   */
  export type AiGameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter, which AiGame to fetch.
     */
    where?: AiGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGames to fetch.
     */
    orderBy?: AiGameOrderByWithRelationInput | AiGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiGames.
     */
    cursor?: AiGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiGames.
     */
    distinct?: AiGameScalarFieldEnum | AiGameScalarFieldEnum[]
  }

  /**
   * AiGame findMany
   */
  export type AiGameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter, which AiGames to fetch.
     */
    where?: AiGameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiGames to fetch.
     */
    orderBy?: AiGameOrderByWithRelationInput | AiGameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiGames.
     */
    cursor?: AiGameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiGames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiGames.
     */
    skip?: number
    distinct?: AiGameScalarFieldEnum | AiGameScalarFieldEnum[]
  }

  /**
   * AiGame create
   */
  export type AiGameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * The data needed to create a AiGame.
     */
    data: XOR<AiGameCreateInput, AiGameUncheckedCreateInput>
  }

  /**
   * AiGame createMany
   */
  export type AiGameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiGames.
     */
    data: AiGameCreateManyInput | AiGameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiGame createManyAndReturn
   */
  export type AiGameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiGames.
     */
    data: AiGameCreateManyInput | AiGameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiGame update
   */
  export type AiGameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * The data needed to update a AiGame.
     */
    data: XOR<AiGameUpdateInput, AiGameUncheckedUpdateInput>
    /**
     * Choose, which AiGame to update.
     */
    where: AiGameWhereUniqueInput
  }

  /**
   * AiGame updateMany
   */
  export type AiGameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiGames.
     */
    data: XOR<AiGameUpdateManyMutationInput, AiGameUncheckedUpdateManyInput>
    /**
     * Filter which AiGames to update
     */
    where?: AiGameWhereInput
  }

  /**
   * AiGame upsert
   */
  export type AiGameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * The filter to search for the AiGame to update in case it exists.
     */
    where: AiGameWhereUniqueInput
    /**
     * In case the AiGame found by the `where` argument doesn't exist, create a new AiGame with this data.
     */
    create: XOR<AiGameCreateInput, AiGameUncheckedCreateInput>
    /**
     * In case the AiGame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiGameUpdateInput, AiGameUncheckedUpdateInput>
  }

  /**
   * AiGame delete
   */
  export type AiGameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
    /**
     * Filter which AiGame to delete.
     */
    where: AiGameWhereUniqueInput
  }

  /**
   * AiGame deleteMany
   */
  export type AiGameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiGames to delete
     */
    where?: AiGameWhereInput
  }

  /**
   * AiGame.creator
   */
  export type AiGame$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * AiGame without action
   */
  export type AiGameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiGame
     */
    select?: AiGameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiGameInclude<ExtArgs> | null
  }


  /**
   * Model LessonPlan
   */

  export type AggregateLessonPlan = {
    _count: LessonPlanCountAggregateOutputType | null
    _avg: LessonPlanAvgAggregateOutputType | null
    _sum: LessonPlanSumAggregateOutputType | null
    _min: LessonPlanMinAggregateOutputType | null
    _max: LessonPlanMaxAggregateOutputType | null
  }

  export type LessonPlanAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type LessonPlanSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type LessonPlanMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
    grade: string | null
    topic: string | null
    createdAt: Date | null
  }

  export type LessonPlanMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
    grade: string | null
    topic: string | null
    createdAt: Date | null
  }

  export type LessonPlanCountAggregateOutputType = {
    id: number
    teacherId: number
    subject: number
    grade: number
    topic: number
    content: number
    createdAt: number
    _all: number
  }


  export type LessonPlanAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type LessonPlanSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type LessonPlanMinAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    grade?: true
    topic?: true
    createdAt?: true
  }

  export type LessonPlanMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    grade?: true
    topic?: true
    createdAt?: true
  }

  export type LessonPlanCountAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    grade?: true
    topic?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type LessonPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonPlan to aggregate.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonPlans
    **/
    _count?: true | LessonPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonPlanMaxAggregateInputType
  }

  export type GetLessonPlanAggregateType<T extends LessonPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonPlan[P]>
      : GetScalarType<T[P], AggregateLessonPlan[P]>
  }




  export type LessonPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonPlanWhereInput
    orderBy?: LessonPlanOrderByWithAggregationInput | LessonPlanOrderByWithAggregationInput[]
    by: LessonPlanScalarFieldEnum[] | LessonPlanScalarFieldEnum
    having?: LessonPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonPlanCountAggregateInputType | true
    _avg?: LessonPlanAvgAggregateInputType
    _sum?: LessonPlanSumAggregateInputType
    _min?: LessonPlanMinAggregateInputType
    _max?: LessonPlanMaxAggregateInputType
  }

  export type LessonPlanGroupByOutputType = {
    id: number
    teacherId: number | null
    subject: string | null
    grade: string | null
    topic: string | null
    content: JsonValue | null
    createdAt: Date
    _count: LessonPlanCountAggregateOutputType | null
    _avg: LessonPlanAvgAggregateOutputType | null
    _sum: LessonPlanSumAggregateOutputType | null
    _min: LessonPlanMinAggregateOutputType | null
    _max: LessonPlanMaxAggregateOutputType | null
  }

  type GetLessonPlanGroupByPayload<T extends LessonPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonPlanGroupByOutputType[P]>
            : GetScalarType<T[P], LessonPlanGroupByOutputType[P]>
        }
      >
    >


  export type LessonPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    grade?: boolean
    topic?: boolean
    content?: boolean
    createdAt?: boolean
    teacher?: boolean | LessonPlan$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessonPlan"]>

  export type LessonPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    grade?: boolean
    topic?: boolean
    content?: boolean
    createdAt?: boolean
    teacher?: boolean | LessonPlan$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["lessonPlan"]>

  export type LessonPlanSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    grade?: boolean
    topic?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type LessonPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | LessonPlan$teacherArgs<ExtArgs>
  }
  export type LessonPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | LessonPlan$teacherArgs<ExtArgs>
  }

  export type $LessonPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonPlan"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number | null
      subject: string | null
      grade: string | null
      topic: string | null
      content: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["lessonPlan"]>
    composites: {}
  }

  type LessonPlanGetPayload<S extends boolean | null | undefined | LessonPlanDefaultArgs> = $Result.GetResult<Prisma.$LessonPlanPayload, S>

  type LessonPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonPlanCountAggregateInputType | true
    }

  export interface LessonPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonPlan'], meta: { name: 'LessonPlan' } }
    /**
     * Find zero or one LessonPlan that matches the filter.
     * @param {LessonPlanFindUniqueArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonPlanFindUniqueArgs>(args: SelectSubset<T, LessonPlanFindUniqueArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LessonPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonPlanFindUniqueOrThrowArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LessonPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindFirstArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonPlanFindFirstArgs>(args?: SelectSubset<T, LessonPlanFindFirstArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LessonPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindFirstOrThrowArgs} args - Arguments to find a LessonPlan
     * @example
     * // Get one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LessonPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonPlans
     * const lessonPlans = await prisma.lessonPlan.findMany()
     * 
     * // Get first 10 LessonPlans
     * const lessonPlans = await prisma.lessonPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonPlanWithIdOnly = await prisma.lessonPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonPlanFindManyArgs>(args?: SelectSubset<T, LessonPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LessonPlan.
     * @param {LessonPlanCreateArgs} args - Arguments to create a LessonPlan.
     * @example
     * // Create one LessonPlan
     * const LessonPlan = await prisma.lessonPlan.create({
     *   data: {
     *     // ... data to create a LessonPlan
     *   }
     * })
     * 
     */
    create<T extends LessonPlanCreateArgs>(args: SelectSubset<T, LessonPlanCreateArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LessonPlans.
     * @param {LessonPlanCreateManyArgs} args - Arguments to create many LessonPlans.
     * @example
     * // Create many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonPlanCreateManyArgs>(args?: SelectSubset<T, LessonPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonPlans and returns the data saved in the database.
     * @param {LessonPlanCreateManyAndReturnArgs} args - Arguments to create many LessonPlans.
     * @example
     * // Create many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonPlans and only return the `id`
     * const lessonPlanWithIdOnly = await prisma.lessonPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LessonPlan.
     * @param {LessonPlanDeleteArgs} args - Arguments to delete one LessonPlan.
     * @example
     * // Delete one LessonPlan
     * const LessonPlan = await prisma.lessonPlan.delete({
     *   where: {
     *     // ... filter to delete one LessonPlan
     *   }
     * })
     * 
     */
    delete<T extends LessonPlanDeleteArgs>(args: SelectSubset<T, LessonPlanDeleteArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LessonPlan.
     * @param {LessonPlanUpdateArgs} args - Arguments to update one LessonPlan.
     * @example
     * // Update one LessonPlan
     * const lessonPlan = await prisma.lessonPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonPlanUpdateArgs>(args: SelectSubset<T, LessonPlanUpdateArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LessonPlans.
     * @param {LessonPlanDeleteManyArgs} args - Arguments to filter LessonPlans to delete.
     * @example
     * // Delete a few LessonPlans
     * const { count } = await prisma.lessonPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonPlanDeleteManyArgs>(args?: SelectSubset<T, LessonPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonPlans
     * const lessonPlan = await prisma.lessonPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonPlanUpdateManyArgs>(args: SelectSubset<T, LessonPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LessonPlan.
     * @param {LessonPlanUpsertArgs} args - Arguments to update or create a LessonPlan.
     * @example
     * // Update or create a LessonPlan
     * const lessonPlan = await prisma.lessonPlan.upsert({
     *   create: {
     *     // ... data to create a LessonPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonPlan we want to update
     *   }
     * })
     */
    upsert<T extends LessonPlanUpsertArgs>(args: SelectSubset<T, LessonPlanUpsertArgs<ExtArgs>>): Prisma__LessonPlanClient<$Result.GetResult<Prisma.$LessonPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LessonPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanCountArgs} args - Arguments to filter LessonPlans to count.
     * @example
     * // Count the number of LessonPlans
     * const count = await prisma.lessonPlan.count({
     *   where: {
     *     // ... the filter for the LessonPlans we want to count
     *   }
     * })
    **/
    count<T extends LessonPlanCountArgs>(
      args?: Subset<T, LessonPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonPlanAggregateArgs>(args: Subset<T, LessonPlanAggregateArgs>): Prisma.PrismaPromise<GetLessonPlanAggregateType<T>>

    /**
     * Group by LessonPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonPlanGroupByArgs['orderBy'] }
        : { orderBy?: LessonPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonPlan model
   */
  readonly fields: LessonPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends LessonPlan$teacherArgs<ExtArgs> = {}>(args?: Subset<T, LessonPlan$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonPlan model
   */ 
  interface LessonPlanFieldRefs {
    readonly id: FieldRef<"LessonPlan", 'Int'>
    readonly teacherId: FieldRef<"LessonPlan", 'Int'>
    readonly subject: FieldRef<"LessonPlan", 'String'>
    readonly grade: FieldRef<"LessonPlan", 'String'>
    readonly topic: FieldRef<"LessonPlan", 'String'>
    readonly content: FieldRef<"LessonPlan", 'Json'>
    readonly createdAt: FieldRef<"LessonPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LessonPlan findUnique
   */
  export type LessonPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan findUniqueOrThrow
   */
  export type LessonPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan findFirst
   */
  export type LessonPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonPlans.
     */
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan findFirstOrThrow
   */
  export type LessonPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlan to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonPlans.
     */
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan findMany
   */
  export type LessonPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter, which LessonPlans to fetch.
     */
    where?: LessonPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonPlans to fetch.
     */
    orderBy?: LessonPlanOrderByWithRelationInput | LessonPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonPlans.
     */
    cursor?: LessonPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonPlans.
     */
    skip?: number
    distinct?: LessonPlanScalarFieldEnum | LessonPlanScalarFieldEnum[]
  }

  /**
   * LessonPlan create
   */
  export type LessonPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonPlan.
     */
    data?: XOR<LessonPlanCreateInput, LessonPlanUncheckedCreateInput>
  }

  /**
   * LessonPlan createMany
   */
  export type LessonPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonPlans.
     */
    data: LessonPlanCreateManyInput | LessonPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonPlan createManyAndReturn
   */
  export type LessonPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LessonPlans.
     */
    data: LessonPlanCreateManyInput | LessonPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonPlan update
   */
  export type LessonPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonPlan.
     */
    data: XOR<LessonPlanUpdateInput, LessonPlanUncheckedUpdateInput>
    /**
     * Choose, which LessonPlan to update.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan updateMany
   */
  export type LessonPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonPlans.
     */
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyInput>
    /**
     * Filter which LessonPlans to update
     */
    where?: LessonPlanWhereInput
  }

  /**
   * LessonPlan upsert
   */
  export type LessonPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonPlan to update in case it exists.
     */
    where: LessonPlanWhereUniqueInput
    /**
     * In case the LessonPlan found by the `where` argument doesn't exist, create a new LessonPlan with this data.
     */
    create: XOR<LessonPlanCreateInput, LessonPlanUncheckedCreateInput>
    /**
     * In case the LessonPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonPlanUpdateInput, LessonPlanUncheckedUpdateInput>
  }

  /**
   * LessonPlan delete
   */
  export type LessonPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
    /**
     * Filter which LessonPlan to delete.
     */
    where: LessonPlanWhereUniqueInput
  }

  /**
   * LessonPlan deleteMany
   */
  export type LessonPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonPlans to delete
     */
    where?: LessonPlanWhereInput
  }

  /**
   * LessonPlan.teacher
   */
  export type LessonPlan$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * LessonPlan without action
   */
  export type LessonPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonPlan
     */
    select?: LessonPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonPlanInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedResource
   */

  export type AggregateGeneratedResource = {
    _count: GeneratedResourceCountAggregateOutputType | null
    _avg: GeneratedResourceAvgAggregateOutputType | null
    _sum: GeneratedResourceSumAggregateOutputType | null
    _min: GeneratedResourceMinAggregateOutputType | null
    _max: GeneratedResourceMaxAggregateOutputType | null
  }

  export type GeneratedResourceAvgAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type GeneratedResourceSumAggregateOutputType = {
    id: number | null
    teacherId: number | null
  }

  export type GeneratedResourceMinAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
    className: string | null
    term: string | null
    updatedAt: Date | null
  }

  export type GeneratedResourceMaxAggregateOutputType = {
    id: number | null
    teacherId: number | null
    subject: string | null
    className: string | null
    term: string | null
    updatedAt: Date | null
  }

  export type GeneratedResourceCountAggregateOutputType = {
    id: number
    teacherId: number
    subject: number
    className: number
    term: number
    schemeContent: number
    lessonPlansContent: number
    updatedAt: number
    _all: number
  }


  export type GeneratedResourceAvgAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type GeneratedResourceSumAggregateInputType = {
    id?: true
    teacherId?: true
  }

  export type GeneratedResourceMinAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    className?: true
    term?: true
    updatedAt?: true
  }

  export type GeneratedResourceMaxAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    className?: true
    term?: true
    updatedAt?: true
  }

  export type GeneratedResourceCountAggregateInputType = {
    id?: true
    teacherId?: true
    subject?: true
    className?: true
    term?: true
    schemeContent?: true
    lessonPlansContent?: true
    updatedAt?: true
    _all?: true
  }

  export type GeneratedResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedResource to aggregate.
     */
    where?: GeneratedResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResources to fetch.
     */
    orderBy?: GeneratedResourceOrderByWithRelationInput | GeneratedResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedResources
    **/
    _count?: true | GeneratedResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneratedResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneratedResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedResourceMaxAggregateInputType
  }

  export type GetGeneratedResourceAggregateType<T extends GeneratedResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedResource[P]>
      : GetScalarType<T[P], AggregateGeneratedResource[P]>
  }




  export type GeneratedResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResourceWhereInput
    orderBy?: GeneratedResourceOrderByWithAggregationInput | GeneratedResourceOrderByWithAggregationInput[]
    by: GeneratedResourceScalarFieldEnum[] | GeneratedResourceScalarFieldEnum
    having?: GeneratedResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedResourceCountAggregateInputType | true
    _avg?: GeneratedResourceAvgAggregateInputType
    _sum?: GeneratedResourceSumAggregateInputType
    _min?: GeneratedResourceMinAggregateInputType
    _max?: GeneratedResourceMaxAggregateInputType
  }

  export type GeneratedResourceGroupByOutputType = {
    id: number
    teacherId: number | null
    subject: string | null
    className: string | null
    term: string | null
    schemeContent: JsonValue | null
    lessonPlansContent: JsonValue | null
    updatedAt: Date
    _count: GeneratedResourceCountAggregateOutputType | null
    _avg: GeneratedResourceAvgAggregateOutputType | null
    _sum: GeneratedResourceSumAggregateOutputType | null
    _min: GeneratedResourceMinAggregateOutputType | null
    _max: GeneratedResourceMaxAggregateOutputType | null
  }

  type GetGeneratedResourceGroupByPayload<T extends GeneratedResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedResourceGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedResourceGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    className?: boolean
    term?: boolean
    schemeContent?: boolean
    lessonPlansContent?: boolean
    updatedAt?: boolean
    teacher?: boolean | GeneratedResource$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["generatedResource"]>

  export type GeneratedResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    className?: boolean
    term?: boolean
    schemeContent?: boolean
    lessonPlansContent?: boolean
    updatedAt?: boolean
    teacher?: boolean | GeneratedResource$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["generatedResource"]>

  export type GeneratedResourceSelectScalar = {
    id?: boolean
    teacherId?: boolean
    subject?: boolean
    className?: boolean
    term?: boolean
    schemeContent?: boolean
    lessonPlansContent?: boolean
    updatedAt?: boolean
  }

  export type GeneratedResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | GeneratedResource$teacherArgs<ExtArgs>
  }
  export type GeneratedResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | GeneratedResource$teacherArgs<ExtArgs>
  }

  export type $GeneratedResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedResource"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacherId: number | null
      subject: string | null
      className: string | null
      term: string | null
      schemeContent: Prisma.JsonValue | null
      lessonPlansContent: Prisma.JsonValue | null
      updatedAt: Date
    }, ExtArgs["result"]["generatedResource"]>
    composites: {}
  }

  type GeneratedResourceGetPayload<S extends boolean | null | undefined | GeneratedResourceDefaultArgs> = $Result.GetResult<Prisma.$GeneratedResourcePayload, S>

  type GeneratedResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GeneratedResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GeneratedResourceCountAggregateInputType | true
    }

  export interface GeneratedResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedResource'], meta: { name: 'GeneratedResource' } }
    /**
     * Find zero or one GeneratedResource that matches the filter.
     * @param {GeneratedResourceFindUniqueArgs} args - Arguments to find a GeneratedResource
     * @example
     * // Get one GeneratedResource
     * const generatedResource = await prisma.generatedResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedResourceFindUniqueArgs>(args: SelectSubset<T, GeneratedResourceFindUniqueArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GeneratedResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GeneratedResourceFindUniqueOrThrowArgs} args - Arguments to find a GeneratedResource
     * @example
     * // Get one GeneratedResource
     * const generatedResource = await prisma.generatedResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GeneratedResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceFindFirstArgs} args - Arguments to find a GeneratedResource
     * @example
     * // Get one GeneratedResource
     * const generatedResource = await prisma.generatedResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedResourceFindFirstArgs>(args?: SelectSubset<T, GeneratedResourceFindFirstArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GeneratedResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceFindFirstOrThrowArgs} args - Arguments to find a GeneratedResource
     * @example
     * // Get one GeneratedResource
     * const generatedResource = await prisma.generatedResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GeneratedResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedResources
     * const generatedResources = await prisma.generatedResource.findMany()
     * 
     * // Get first 10 GeneratedResources
     * const generatedResources = await prisma.generatedResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedResourceWithIdOnly = await prisma.generatedResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedResourceFindManyArgs>(args?: SelectSubset<T, GeneratedResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GeneratedResource.
     * @param {GeneratedResourceCreateArgs} args - Arguments to create a GeneratedResource.
     * @example
     * // Create one GeneratedResource
     * const GeneratedResource = await prisma.generatedResource.create({
     *   data: {
     *     // ... data to create a GeneratedResource
     *   }
     * })
     * 
     */
    create<T extends GeneratedResourceCreateArgs>(args: SelectSubset<T, GeneratedResourceCreateArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GeneratedResources.
     * @param {GeneratedResourceCreateManyArgs} args - Arguments to create many GeneratedResources.
     * @example
     * // Create many GeneratedResources
     * const generatedResource = await prisma.generatedResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedResourceCreateManyArgs>(args?: SelectSubset<T, GeneratedResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedResources and returns the data saved in the database.
     * @param {GeneratedResourceCreateManyAndReturnArgs} args - Arguments to create many GeneratedResources.
     * @example
     * // Create many GeneratedResources
     * const generatedResource = await prisma.generatedResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedResources and only return the `id`
     * const generatedResourceWithIdOnly = await prisma.generatedResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GeneratedResource.
     * @param {GeneratedResourceDeleteArgs} args - Arguments to delete one GeneratedResource.
     * @example
     * // Delete one GeneratedResource
     * const GeneratedResource = await prisma.generatedResource.delete({
     *   where: {
     *     // ... filter to delete one GeneratedResource
     *   }
     * })
     * 
     */
    delete<T extends GeneratedResourceDeleteArgs>(args: SelectSubset<T, GeneratedResourceDeleteArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GeneratedResource.
     * @param {GeneratedResourceUpdateArgs} args - Arguments to update one GeneratedResource.
     * @example
     * // Update one GeneratedResource
     * const generatedResource = await prisma.generatedResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedResourceUpdateArgs>(args: SelectSubset<T, GeneratedResourceUpdateArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GeneratedResources.
     * @param {GeneratedResourceDeleteManyArgs} args - Arguments to filter GeneratedResources to delete.
     * @example
     * // Delete a few GeneratedResources
     * const { count } = await prisma.generatedResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedResourceDeleteManyArgs>(args?: SelectSubset<T, GeneratedResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedResources
     * const generatedResource = await prisma.generatedResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedResourceUpdateManyArgs>(args: SelectSubset<T, GeneratedResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GeneratedResource.
     * @param {GeneratedResourceUpsertArgs} args - Arguments to update or create a GeneratedResource.
     * @example
     * // Update or create a GeneratedResource
     * const generatedResource = await prisma.generatedResource.upsert({
     *   create: {
     *     // ... data to create a GeneratedResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedResource we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedResourceUpsertArgs>(args: SelectSubset<T, GeneratedResourceUpsertArgs<ExtArgs>>): Prisma__GeneratedResourceClient<$Result.GetResult<Prisma.$GeneratedResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GeneratedResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceCountArgs} args - Arguments to filter GeneratedResources to count.
     * @example
     * // Count the number of GeneratedResources
     * const count = await prisma.generatedResource.count({
     *   where: {
     *     // ... the filter for the GeneratedResources we want to count
     *   }
     * })
    **/
    count<T extends GeneratedResourceCountArgs>(
      args?: Subset<T, GeneratedResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedResourceAggregateArgs>(args: Subset<T, GeneratedResourceAggregateArgs>): Prisma.PrismaPromise<GetGeneratedResourceAggregateType<T>>

    /**
     * Group by GeneratedResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedResourceGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedResource model
   */
  readonly fields: GeneratedResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends GeneratedResource$teacherArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResource$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedResource model
   */ 
  interface GeneratedResourceFieldRefs {
    readonly id: FieldRef<"GeneratedResource", 'Int'>
    readonly teacherId: FieldRef<"GeneratedResource", 'Int'>
    readonly subject: FieldRef<"GeneratedResource", 'String'>
    readonly className: FieldRef<"GeneratedResource", 'String'>
    readonly term: FieldRef<"GeneratedResource", 'String'>
    readonly schemeContent: FieldRef<"GeneratedResource", 'Json'>
    readonly lessonPlansContent: FieldRef<"GeneratedResource", 'Json'>
    readonly updatedAt: FieldRef<"GeneratedResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedResource findUnique
   */
  export type GeneratedResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResource to fetch.
     */
    where: GeneratedResourceWhereUniqueInput
  }

  /**
   * GeneratedResource findUniqueOrThrow
   */
  export type GeneratedResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResource to fetch.
     */
    where: GeneratedResourceWhereUniqueInput
  }

  /**
   * GeneratedResource findFirst
   */
  export type GeneratedResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResource to fetch.
     */
    where?: GeneratedResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResources to fetch.
     */
    orderBy?: GeneratedResourceOrderByWithRelationInput | GeneratedResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedResources.
     */
    cursor?: GeneratedResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedResources.
     */
    distinct?: GeneratedResourceScalarFieldEnum | GeneratedResourceScalarFieldEnum[]
  }

  /**
   * GeneratedResource findFirstOrThrow
   */
  export type GeneratedResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResource to fetch.
     */
    where?: GeneratedResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResources to fetch.
     */
    orderBy?: GeneratedResourceOrderByWithRelationInput | GeneratedResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedResources.
     */
    cursor?: GeneratedResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedResources.
     */
    distinct?: GeneratedResourceScalarFieldEnum | GeneratedResourceScalarFieldEnum[]
  }

  /**
   * GeneratedResource findMany
   */
  export type GeneratedResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResources to fetch.
     */
    where?: GeneratedResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResources to fetch.
     */
    orderBy?: GeneratedResourceOrderByWithRelationInput | GeneratedResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedResources.
     */
    cursor?: GeneratedResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResources.
     */
    skip?: number
    distinct?: GeneratedResourceScalarFieldEnum | GeneratedResourceScalarFieldEnum[]
  }

  /**
   * GeneratedResource create
   */
  export type GeneratedResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedResource.
     */
    data?: XOR<GeneratedResourceCreateInput, GeneratedResourceUncheckedCreateInput>
  }

  /**
   * GeneratedResource createMany
   */
  export type GeneratedResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedResources.
     */
    data: GeneratedResourceCreateManyInput | GeneratedResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedResource createManyAndReturn
   */
  export type GeneratedResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GeneratedResources.
     */
    data: GeneratedResourceCreateManyInput | GeneratedResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedResource update
   */
  export type GeneratedResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedResource.
     */
    data: XOR<GeneratedResourceUpdateInput, GeneratedResourceUncheckedUpdateInput>
    /**
     * Choose, which GeneratedResource to update.
     */
    where: GeneratedResourceWhereUniqueInput
  }

  /**
   * GeneratedResource updateMany
   */
  export type GeneratedResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedResources.
     */
    data: XOR<GeneratedResourceUpdateManyMutationInput, GeneratedResourceUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedResources to update
     */
    where?: GeneratedResourceWhereInput
  }

  /**
   * GeneratedResource upsert
   */
  export type GeneratedResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedResource to update in case it exists.
     */
    where: GeneratedResourceWhereUniqueInput
    /**
     * In case the GeneratedResource found by the `where` argument doesn't exist, create a new GeneratedResource with this data.
     */
    create: XOR<GeneratedResourceCreateInput, GeneratedResourceUncheckedCreateInput>
    /**
     * In case the GeneratedResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedResourceUpdateInput, GeneratedResourceUncheckedUpdateInput>
  }

  /**
   * GeneratedResource delete
   */
  export type GeneratedResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
    /**
     * Filter which GeneratedResource to delete.
     */
    where: GeneratedResourceWhereUniqueInput
  }

  /**
   * GeneratedResource deleteMany
   */
  export type GeneratedResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedResources to delete
     */
    where?: GeneratedResourceWhereInput
  }

  /**
   * GeneratedResource.teacher
   */
  export type GeneratedResource$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * GeneratedResource without action
   */
  export type GeneratedResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResource
     */
    select?: GeneratedResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResourceInclude<ExtArgs> | null
  }


  /**
   * Model ReportCard
   */

  export type AggregateReportCard = {
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  export type ReportCardAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    gradeAverage: Decimal | null
    position: number | null
    totalStudents: number | null
    attendancePercentage: Decimal | null
  }

  export type ReportCardSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    gradeAverage: Decimal | null
    position: number | null
    totalStudents: number | null
    attendancePercentage: Decimal | null
  }

  export type ReportCardMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    session: string | null
    term: string | null
    status: string | null
    classTeacherComment: string | null
    principalComment: string | null
    gradeAverage: Decimal | null
    position: number | null
    totalStudents: number | null
    attendancePercentage: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type ReportCardMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    session: string | null
    term: string | null
    status: string | null
    classTeacherComment: string | null
    principalComment: string | null
    gradeAverage: Decimal | null
    position: number | null
    totalStudents: number | null
    attendancePercentage: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type ReportCardCountAggregateOutputType = {
    id: number
    studentId: number
    session: number
    term: number
    status: number
    classTeacherComment: number
    principalComment: number
    gradeAverage: number
    position: number
    totalStudents: number
    attendancePercentage: number
    skills: number
    psychomotor: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type ReportCardAvgAggregateInputType = {
    id?: true
    studentId?: true
    gradeAverage?: true
    position?: true
    totalStudents?: true
    attendancePercentage?: true
  }

  export type ReportCardSumAggregateInputType = {
    id?: true
    studentId?: true
    gradeAverage?: true
    position?: true
    totalStudents?: true
    attendancePercentage?: true
  }

  export type ReportCardMinAggregateInputType = {
    id?: true
    studentId?: true
    session?: true
    term?: true
    status?: true
    classTeacherComment?: true
    principalComment?: true
    gradeAverage?: true
    position?: true
    totalStudents?: true
    attendancePercentage?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type ReportCardMaxAggregateInputType = {
    id?: true
    studentId?: true
    session?: true
    term?: true
    status?: true
    classTeacherComment?: true
    principalComment?: true
    gradeAverage?: true
    position?: true
    totalStudents?: true
    attendancePercentage?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type ReportCardCountAggregateInputType = {
    id?: true
    studentId?: true
    session?: true
    term?: true
    status?: true
    classTeacherComment?: true
    principalComment?: true
    gradeAverage?: true
    position?: true
    totalStudents?: true
    attendancePercentage?: true
    skills?: true
    psychomotor?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type ReportCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCard to aggregate.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportCards
    **/
    _count?: true | ReportCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportCardMaxAggregateInputType
  }

  export type GetReportCardAggregateType<T extends ReportCardAggregateArgs> = {
        [P in keyof T & keyof AggregateReportCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportCard[P]>
      : GetScalarType<T[P], AggregateReportCard[P]>
  }




  export type ReportCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithAggregationInput | ReportCardOrderByWithAggregationInput[]
    by: ReportCardScalarFieldEnum[] | ReportCardScalarFieldEnum
    having?: ReportCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCardCountAggregateInputType | true
    _avg?: ReportCardAvgAggregateInputType
    _sum?: ReportCardSumAggregateInputType
    _min?: ReportCardMinAggregateInputType
    _max?: ReportCardMaxAggregateInputType
  }

  export type ReportCardGroupByOutputType = {
    id: number
    studentId: number | null
    session: string
    term: string
    status: string | null
    classTeacherComment: string | null
    principalComment: string | null
    gradeAverage: Decimal | null
    position: number | null
    totalStudents: number | null
    attendancePercentage: Decimal | null
    skills: JsonValue | null
    psychomotor: JsonValue | null
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  type GetReportCardGroupByPayload<T extends ReportCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
            : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
        }
      >
    >


  export type ReportCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    session?: boolean
    term?: boolean
    status?: boolean
    classTeacherComment?: boolean
    principalComment?: boolean
    gradeAverage?: boolean
    position?: boolean
    totalStudents?: boolean
    attendancePercentage?: boolean
    skills?: boolean
    psychomotor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    student?: boolean | ReportCard$studentArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    session?: boolean
    term?: boolean
    status?: boolean
    classTeacherComment?: boolean
    principalComment?: boolean
    gradeAverage?: boolean
    position?: boolean
    totalStudents?: boolean
    attendancePercentage?: boolean
    skills?: boolean
    psychomotor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    student?: boolean | ReportCard$studentArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectScalar = {
    id?: boolean
    studentId?: boolean
    session?: boolean
    term?: boolean
    status?: boolean
    classTeacherComment?: boolean
    principalComment?: boolean
    gradeAverage?: boolean
    position?: boolean
    totalStudents?: boolean
    attendancePercentage?: boolean
    skills?: boolean
    psychomotor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type ReportCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | ReportCard$studentArgs<ExtArgs>
  }
  export type ReportCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | ReportCard$studentArgs<ExtArgs>
  }

  export type $ReportCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportCard"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number | null
      session: string
      term: string
      status: string | null
      classTeacherComment: string | null
      principalComment: string | null
      gradeAverage: Prisma.Decimal | null
      position: number | null
      totalStudents: number | null
      attendancePercentage: Prisma.Decimal | null
      skills: Prisma.JsonValue | null
      psychomotor: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["reportCard"]>
    composites: {}
  }

  type ReportCardGetPayload<S extends boolean | null | undefined | ReportCardDefaultArgs> = $Result.GetResult<Prisma.$ReportCardPayload, S>

  type ReportCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCardCountAggregateInputType | true
    }

  export interface ReportCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportCard'], meta: { name: 'ReportCard' } }
    /**
     * Find zero or one ReportCard that matches the filter.
     * @param {ReportCardFindUniqueArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportCardFindUniqueArgs>(args: SelectSubset<T, ReportCardFindUniqueArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportCardFindUniqueOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportCardFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportCardFindFirstArgs>(args?: SelectSubset<T, ReportCardFindFirstArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportCardFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportCards
     * const reportCards = await prisma.reportCard.findMany()
     * 
     * // Get first 10 ReportCards
     * const reportCards = await prisma.reportCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportCardFindManyArgs>(args?: SelectSubset<T, ReportCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportCard.
     * @param {ReportCardCreateArgs} args - Arguments to create a ReportCard.
     * @example
     * // Create one ReportCard
     * const ReportCard = await prisma.reportCard.create({
     *   data: {
     *     // ... data to create a ReportCard
     *   }
     * })
     * 
     */
    create<T extends ReportCardCreateArgs>(args: SelectSubset<T, ReportCardCreateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportCards.
     * @param {ReportCardCreateManyArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCardCreateManyArgs>(args?: SelectSubset<T, ReportCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportCards and returns the data saved in the database.
     * @param {ReportCardCreateManyAndReturnArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportCards and only return the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCardCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportCard.
     * @param {ReportCardDeleteArgs} args - Arguments to delete one ReportCard.
     * @example
     * // Delete one ReportCard
     * const ReportCard = await prisma.reportCard.delete({
     *   where: {
     *     // ... filter to delete one ReportCard
     *   }
     * })
     * 
     */
    delete<T extends ReportCardDeleteArgs>(args: SelectSubset<T, ReportCardDeleteArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportCard.
     * @param {ReportCardUpdateArgs} args - Arguments to update one ReportCard.
     * @example
     * // Update one ReportCard
     * const reportCard = await prisma.reportCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportCardUpdateArgs>(args: SelectSubset<T, ReportCardUpdateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportCards.
     * @param {ReportCardDeleteManyArgs} args - Arguments to filter ReportCards to delete.
     * @example
     * // Delete a few ReportCards
     * const { count } = await prisma.reportCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportCardDeleteManyArgs>(args?: SelectSubset<T, ReportCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportCards
     * const reportCard = await prisma.reportCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportCardUpdateManyArgs>(args: SelectSubset<T, ReportCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportCard.
     * @param {ReportCardUpsertArgs} args - Arguments to update or create a ReportCard.
     * @example
     * // Update or create a ReportCard
     * const reportCard = await prisma.reportCard.upsert({
     *   create: {
     *     // ... data to create a ReportCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportCard we want to update
     *   }
     * })
     */
    upsert<T extends ReportCardUpsertArgs>(args: SelectSubset<T, ReportCardUpsertArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardCountArgs} args - Arguments to filter ReportCards to count.
     * @example
     * // Count the number of ReportCards
     * const count = await prisma.reportCard.count({
     *   where: {
     *     // ... the filter for the ReportCards we want to count
     *   }
     * })
    **/
    count<T extends ReportCardCountArgs>(
      args?: Subset<T, ReportCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCardAggregateArgs>(args: Subset<T, ReportCardAggregateArgs>): Prisma.PrismaPromise<GetReportCardAggregateType<T>>

    /**
     * Group by ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportCardGroupByArgs['orderBy'] }
        : { orderBy?: ReportCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportCard model
   */
  readonly fields: ReportCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends ReportCard$studentArgs<ExtArgs> = {}>(args?: Subset<T, ReportCard$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportCard model
   */ 
  interface ReportCardFieldRefs {
    readonly id: FieldRef<"ReportCard", 'Int'>
    readonly studentId: FieldRef<"ReportCard", 'Int'>
    readonly session: FieldRef<"ReportCard", 'String'>
    readonly term: FieldRef<"ReportCard", 'String'>
    readonly status: FieldRef<"ReportCard", 'String'>
    readonly classTeacherComment: FieldRef<"ReportCard", 'String'>
    readonly principalComment: FieldRef<"ReportCard", 'String'>
    readonly gradeAverage: FieldRef<"ReportCard", 'Decimal'>
    readonly position: FieldRef<"ReportCard", 'Int'>
    readonly totalStudents: FieldRef<"ReportCard", 'Int'>
    readonly attendancePercentage: FieldRef<"ReportCard", 'Decimal'>
    readonly skills: FieldRef<"ReportCard", 'Json'>
    readonly psychomotor: FieldRef<"ReportCard", 'Json'>
    readonly createdAt: FieldRef<"ReportCard", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportCard", 'DateTime'>
    readonly publishedAt: FieldRef<"ReportCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportCard findUnique
   */
  export type ReportCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findUniqueOrThrow
   */
  export type ReportCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findFirst
   */
  export type ReportCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findFirstOrThrow
   */
  export type ReportCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findMany
   */
  export type ReportCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCards to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard create
   */
  export type ReportCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportCard.
     */
    data: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
  }

  /**
   * ReportCard createMany
   */
  export type ReportCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportCard createManyAndReturn
   */
  export type ReportCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportCard update
   */
  export type ReportCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportCard.
     */
    data: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
    /**
     * Choose, which ReportCard to update.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard updateMany
   */
  export type ReportCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportCards.
     */
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyInput>
    /**
     * Filter which ReportCards to update
     */
    where?: ReportCardWhereInput
  }

  /**
   * ReportCard upsert
   */
  export type ReportCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportCard to update in case it exists.
     */
    where: ReportCardWhereUniqueInput
    /**
     * In case the ReportCard found by the `where` argument doesn't exist, create a new ReportCard with this data.
     */
    create: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
    /**
     * In case the ReportCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
  }

  /**
   * ReportCard delete
   */
  export type ReportCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter which ReportCard to delete.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard deleteMany
   */
  export type ReportCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCards to delete
     */
    where?: ReportCardWhereInput
  }

  /**
   * ReportCard.student
   */
  export type ReportCard$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * ReportCard without action
   */
  export type ReportCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    supabaseUid: 'supabaseUid',
    email: 'email',
    name: 'name',
    role: 'role',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    avatarUrl: 'avatarUrl',
    grade: 'grade',
    section: 'section',
    department: 'department',
    attendanceStatus: 'attendanceStatus',
    birthday: 'birthday',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    avatarUrl: 'avatarUrl',
    email: 'email',
    phone: 'phone',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const ParentChildScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    studentId: 'studentId'
  };

  export type ParentChildScalarFieldEnum = (typeof ParentChildScalarFieldEnum)[keyof typeof ParentChildScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    grade: 'grade',
    section: 'section',
    department: 'department',
    studentCount: 'studentCount',
    createdAt: 'createdAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const TeacherSubjectScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subject: 'subject'
  };

  export type TeacherSubjectScalarFieldEnum = (typeof TeacherSubjectScalarFieldEnum)[keyof typeof TeacherSubjectScalarFieldEnum]


  export const TeacherClassScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    className: 'className'
  };

  export type TeacherClassScalarFieldEnum = (typeof TeacherClassScalarFieldEnum)[keyof typeof TeacherClassScalarFieldEnum]


  export const TimetableScalarFieldEnum: {
    id: 'id',
    day: 'day',
    startTime: 'startTime',
    endTime: 'endTime',
    subject: 'subject',
    className: 'className',
    teacherId: 'teacherId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimetableScalarFieldEnum = (typeof TimetableScalarFieldEnum)[keyof typeof TimetableScalarFieldEnum]


  export const StudentAttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type StudentAttendanceScalarFieldEnum = (typeof StudentAttendanceScalarFieldEnum)[keyof typeof StudentAttendanceScalarFieldEnum]


  export const AcademicPerformanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subject: 'subject',
    score: 'score',
    term: 'term',
    session: 'session'
  };

  export type AcademicPerformanceScalarFieldEnum = (typeof AcademicPerformanceScalarFieldEnum)[keyof typeof AcademicPerformanceScalarFieldEnum]


  export const BehaviorRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    type: 'type',
    title: 'title',
    summary: 'summary',
    timestamp: 'timestamp'
  };

  export type BehaviorRecordScalarFieldEnum = (typeof BehaviorRecordScalarFieldEnum)[keyof typeof BehaviorRecordScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    name: 'name',
    description: 'description',
    iconName: 'iconName',
    color: 'color',
    awardedAt: 'awardedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    name: 'name',
    issuer: 'issuer',
    fileUrl: 'fileUrl',
    issuedDate: 'issuedDate'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const AwardScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    name: 'name',
    description: 'description',
    date: 'date'
  };

  export type AwardScalarFieldEnum = (typeof AwardScalarFieldEnum)[keyof typeof AwardScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    className: 'className',
    subject: 'subject',
    dueDate: 'dueDate',
    totalStudents: 'totalStudents',
    submissionsCount: 'submissionsCount',
    createdAt: 'createdAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    studentId: 'studentId',
    submittedAt: 'submittedAt',
    isLate: 'isLate',
    status: 'status',
    grade: 'grade',
    feedback: 'feedback',
    textSubmission: 'textSubmission',
    fileUrl: 'fileUrl'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    type: 'type',
    date: 'date',
    time: 'time',
    className: 'className',
    subject: 'subject',
    isPublished: 'isPublished',
    teacherId: 'teacherId'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    timestamp: 'timestamp',
    category: 'category',
    isPinned: 'isPinned',
    audience: 'audience',
    createdBy: 'createdBy'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    title: 'title',
    summary: 'summary',
    isRead: 'isRead',
    timestamp: 'timestamp',
    studentId: 'studentId',
    relatedId: 'relatedId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    createdAt: 'createdAt',
    lastMessageAt: 'lastMessageAt',
    lastMessageText: 'lastMessageText'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    conversationId: 'conversationId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    type: 'type',
    mediaUrl: 'mediaUrl',
    createdAt: 'createdAt',
    isRead: 'isRead'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ForumTopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    authorName: 'authorName',
    createdAt: 'createdAt',
    postCount: 'postCount',
    lastActivity: 'lastActivity'
  };

  export type ForumTopicScalarFieldEnum = (typeof ForumTopicScalarFieldEnum)[keyof typeof ForumTopicScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    authorName: 'authorName',
    content: 'content',
    timestamp: 'timestamp'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    rating: 'rating',
    comment: 'comment',
    status: 'status',
    timeline: 'timeline',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    avatarUrl: 'avatarUrl'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const BusRouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type BusRouteScalarFieldEnum = (typeof BusRouteScalarFieldEnum)[keyof typeof BusRouteScalarFieldEnum]


  export const BusRosterScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    driverId: 'driverId',
    date: 'date'
  };

  export type BusRosterScalarFieldEnum = (typeof BusRosterScalarFieldEnum)[keyof typeof BusRosterScalarFieldEnum]


  export const PickupPointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    routeId: 'routeId',
    lat: 'lat',
    lng: 'lng',
    uiPositionTop: 'uiPositionTop',
    uiPositionLeft: 'uiPositionLeft',
    isUserStop: 'isUserStop'
  };

  export type PickupPointScalarFieldEnum = (typeof PickupPointScalarFieldEnum)[keyof typeof PickupPointScalarFieldEnum]


  export const StudentFeeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    totalFee: 'totalFee',
    paidAmount: 'paidAmount',
    dueDate: 'dueDate',
    status: 'status'
  };

  export type StudentFeeScalarFieldEnum = (typeof StudentFeeScalarFieldEnum)[keyof typeof StudentFeeScalarFieldEnum]


  export const FeePaymentScalarFieldEnum: {
    id: 'id',
    feeId: 'feeId',
    amount: 'amount',
    date: 'date',
    method: 'method',
    reference: 'reference',
    recordedBy: 'recordedBy'
  };

  export type FeePaymentScalarFieldEnum = (typeof FeePaymentScalarFieldEnum)[keyof typeof FeePaymentScalarFieldEnum]


  export const StoreProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    price: 'price',
    imageUrl: 'imageUrl',
    stock: 'stock'
  };

  export type StoreProductScalarFieldEnum = (typeof StoreProductScalarFieldEnum)[keyof typeof StoreProductScalarFieldEnum]


  export const StoreOrderScalarFieldEnum: {
    id: 'id',
    customerName: 'customerName',
    totalAmount: 'totalAmount',
    status: 'status',
    orderDate: 'orderDate',
    items: 'items'
  };

  export type StoreOrderScalarFieldEnum = (typeof StoreOrderScalarFieldEnum)[keyof typeof StoreOrderScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userName: 'userName',
    userRole: 'userRole',
    action: 'action',
    type: 'type',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const HealthLogScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    time: 'time',
    reason: 'reason',
    notes: 'notes',
    parentNotified: 'parentNotified',
    medicationAdministered: 'medicationAdministered',
    recordedBy: 'recordedBy'
  };

  export type HealthLogScalarFieldEnum = (typeof HealthLogScalarFieldEnum)[keyof typeof HealthLogScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    coverUrl: 'coverUrl',
    category: 'category',
    status: 'status'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const DigitalResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    subject: 'subject',
    description: 'description',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl'
  };

  export type DigitalResourceScalarFieldEnum = (typeof DigitalResourceScalarFieldEnum)[keyof typeof DigitalResourceScalarFieldEnum]


  export const CbtTestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    className: 'className',
    subject: 'subject',
    durationMinutes: 'durationMinutes',
    isPublished: 'isPublished',
    createdAt: 'createdAt'
  };

  export type CbtTestScalarFieldEnum = (typeof CbtTestScalarFieldEnum)[keyof typeof CbtTestScalarFieldEnum]


  export const CbtQuestionScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    questionText: 'questionText',
    options: 'options',
    correctAnswer: 'correctAnswer'
  };

  export type CbtQuestionScalarFieldEnum = (typeof CbtQuestionScalarFieldEnum)[keyof typeof CbtQuestionScalarFieldEnum]


  export const CbtResultScalarFieldEnum: {
    id: 'id',
    testId: 'testId',
    studentId: 'studentId',
    score: 'score',
    totalQuestions: 'totalQuestions',
    submittedAt: 'submittedAt'
  };

  export type CbtResultScalarFieldEnum = (typeof CbtResultScalarFieldEnum)[keyof typeof CbtResultScalarFieldEnum]


  export const CalendarEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    type: 'type',
    description: 'description'
  };

  export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


  export const ExtracurricularActivityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    schedule: 'schedule'
  };

  export type ExtracurricularActivityScalarFieldEnum = (typeof ExtracurricularActivityScalarFieldEnum)[keyof typeof ExtracurricularActivityScalarFieldEnum]


  export const PtaMeetingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    agenda: 'agenda'
  };

  export type PtaMeetingScalarFieldEnum = (typeof PtaMeetingScalarFieldEnum)[keyof typeof PtaMeetingScalarFieldEnum]


  export const SchoolPolicyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url'
  };

  export type SchoolPolicyScalarFieldEnum = (typeof SchoolPolicyScalarFieldEnum)[keyof typeof SchoolPolicyScalarFieldEnum]


  export const VolunteeringOpportunityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    spotsTotal: 'spotsTotal',
    spotsFilled: 'spotsFilled'
  };

  export type VolunteeringOpportunityScalarFieldEnum = (typeof VolunteeringOpportunityScalarFieldEnum)[keyof typeof VolunteeringOpportunityScalarFieldEnum]


  export const PermissionSlipScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    title: 'title',
    description: 'description',
    location: 'location',
    date: 'date',
    status: 'status'
  };

  export type PermissionSlipScalarFieldEnum = (typeof PermissionSlipScalarFieldEnum)[keyof typeof PermissionSlipScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    parentId: 'parentId',
    date: 'date',
    time: 'time',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PdResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    source: 'source',
    summary: 'summary',
    url: 'url'
  };

  export type PdResourceScalarFieldEnum = (typeof PdResourceScalarFieldEnum)[keyof typeof PdResourceScalarFieldEnum]


  export const AiGameScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    title: 'title',
    subject: 'subject',
    difficultyLevel: 'difficultyLevel',
    status: 'status',
    questions: 'questions'
  };

  export type AiGameScalarFieldEnum = (typeof AiGameScalarFieldEnum)[keyof typeof AiGameScalarFieldEnum]


  export const LessonPlanScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subject: 'subject',
    grade: 'grade',
    topic: 'topic',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type LessonPlanScalarFieldEnum = (typeof LessonPlanScalarFieldEnum)[keyof typeof LessonPlanScalarFieldEnum]


  export const GeneratedResourceScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    subject: 'subject',
    className: 'className',
    term: 'term',
    schemeContent: 'schemeContent',
    lessonPlansContent: 'lessonPlansContent',
    updatedAt: 'updatedAt'
  };

  export type GeneratedResourceScalarFieldEnum = (typeof GeneratedResourceScalarFieldEnum)[keyof typeof GeneratedResourceScalarFieldEnum]


  export const ReportCardScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    session: 'session',
    term: 'term',
    status: 'status',
    classTeacherComment: 'classTeacherComment',
    principalComment: 'principalComment',
    gradeAverage: 'gradeAverage',
    position: 'position',
    totalStudents: 'totalStudents',
    attendancePercentage: 'attendancePercentage',
    skills: 'skills',
    psychomotor: 'psychomotor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type ReportCardScalarFieldEnum = (typeof ReportCardScalarFieldEnum)[keyof typeof ReportCardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    supabaseUid?: UuidNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    studentProfile?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    teacherProfile?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parentProfile?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    messagesSent?: MessageListRelationFilter
    conversationsParticipated?: ConversationParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    complaints?: ComplaintListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    supabaseUid?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studentProfile?: StudentOrderByWithRelationInput
    teacherProfile?: TeacherOrderByWithRelationInput
    parentProfile?: ParentOrderByWithRelationInput
    messagesSent?: MessageOrderByRelationAggregateInput
    conversationsParticipated?: ConversationParticipantOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    supabaseUid?: UuidNullableFilter<"User"> | string | null
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    studentProfile?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    teacherProfile?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parentProfile?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    messagesSent?: MessageListRelationFilter
    conversationsParticipated?: ConversationParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    complaints?: ComplaintListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    supabaseUid?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    supabaseUid?: UuidNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: IntFilter<"Student"> | number
    userId?: IntNullableFilter<"Student"> | number | null
    name?: StringFilter<"Student"> | string
    avatarUrl?: StringNullableFilter<"Student"> | string | null
    grade?: IntFilter<"Student"> | number
    section?: StringFilter<"Student"> | string
    department?: StringNullableFilter<"Student"> | string | null
    attendanceStatus?: StringNullableFilter<"Student"> | string | null
    birthday?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    parents?: ParentChildListRelationFilter
    attendanceRecords?: StudentAttendanceListRelationFilter
    academicPerformance?: AcademicPerformanceListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
    badges?: BadgeListRelationFilter
    certificates?: CertificateListRelationFilter
    awards?: AwardListRelationFilter
    submissions?: SubmissionListRelationFilter
    fees?: StudentFeeListRelationFilter
    cbtResults?: CbtResultListRelationFilter
    permissionSlips?: PermissionSlipListRelationFilter
    reportCards?: ReportCardListRelationFilter
    healthLogs?: HealthLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrderInput | SortOrder
    attendanceStatus?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    parents?: ParentChildOrderByRelationAggregateInput
    attendanceRecords?: StudentAttendanceOrderByRelationAggregateInput
    academicPerformance?: AcademicPerformanceOrderByRelationAggregateInput
    behaviorRecords?: BehaviorRecordOrderByRelationAggregateInput
    badges?: BadgeOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    awards?: AwardOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
    fees?: StudentFeeOrderByRelationAggregateInput
    cbtResults?: CbtResultOrderByRelationAggregateInput
    permissionSlips?: PermissionSlipOrderByRelationAggregateInput
    reportCards?: ReportCardOrderByRelationAggregateInput
    healthLogs?: HealthLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    name?: StringFilter<"Student"> | string
    avatarUrl?: StringNullableFilter<"Student"> | string | null
    grade?: IntFilter<"Student"> | number
    section?: StringFilter<"Student"> | string
    department?: StringNullableFilter<"Student"> | string | null
    attendanceStatus?: StringNullableFilter<"Student"> | string | null
    birthday?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    parents?: ParentChildListRelationFilter
    attendanceRecords?: StudentAttendanceListRelationFilter
    academicPerformance?: AcademicPerformanceListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
    badges?: BadgeListRelationFilter
    certificates?: CertificateListRelationFilter
    awards?: AwardListRelationFilter
    submissions?: SubmissionListRelationFilter
    fees?: StudentFeeListRelationFilter
    cbtResults?: CbtResultListRelationFilter
    permissionSlips?: PermissionSlipListRelationFilter
    reportCards?: ReportCardListRelationFilter
    healthLogs?: HealthLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrderInput | SortOrder
    attendanceStatus?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Student"> | number
    userId?: IntNullableWithAggregatesFilter<"Student"> | number | null
    name?: StringWithAggregatesFilter<"Student"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"Student"> | string | null
    grade?: IntWithAggregatesFilter<"Student"> | number
    section?: StringWithAggregatesFilter<"Student"> | string
    department?: StringNullableWithAggregatesFilter<"Student"> | string | null
    attendanceStatus?: StringNullableWithAggregatesFilter<"Student"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: IntFilter<"Teacher"> | number
    userId?: IntNullableFilter<"Teacher"> | number | null
    name?: StringFilter<"Teacher"> | string
    avatarUrl?: StringNullableFilter<"Teacher"> | string | null
    email?: StringFilter<"Teacher"> | string
    phone?: StringNullableFilter<"Teacher"> | string | null
    status?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subjects?: TeacherSubjectListRelationFilter
    classes?: TeacherClassListRelationFilter
    timetableEntries?: TimetableListRelationFilter
    exams?: ExamListRelationFilter
    createdAiGames?: AiGameListRelationFilter
    lessonPlans?: LessonPlanListRelationFilter
    generatedResources?: GeneratedResourceListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    subjects?: TeacherSubjectOrderByRelationAggregateInput
    classes?: TeacherClassOrderByRelationAggregateInput
    timetableEntries?: TimetableOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    createdAiGames?: AiGameOrderByRelationAggregateInput
    lessonPlans?: LessonPlanOrderByRelationAggregateInput
    generatedResources?: GeneratedResourceOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    email?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    name?: StringFilter<"Teacher"> | string
    avatarUrl?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringNullableFilter<"Teacher"> | string | null
    status?: StringNullableFilter<"Teacher"> | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    subjects?: TeacherSubjectListRelationFilter
    classes?: TeacherClassListRelationFilter
    timetableEntries?: TimetableListRelationFilter
    exams?: ExamListRelationFilter
    createdAiGames?: AiGameListRelationFilter
    lessonPlans?: LessonPlanListRelationFilter
    generatedResources?: GeneratedResourceListRelationFilter
    appointments?: AppointmentListRelationFilter
  }, "id" | "userId" | "email">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _avg?: TeacherAvgOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
    _sum?: TeacherSumOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teacher"> | number
    userId?: IntNullableWithAggregatesFilter<"Teacher"> | number | null
    name?: StringWithAggregatesFilter<"Teacher"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    email?: StringWithAggregatesFilter<"Teacher"> | string
    phone?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    status?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: IntFilter<"Parent"> | number
    userId?: IntNullableFilter<"Parent"> | number | null
    name?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringNullableFilter<"Parent"> | string | null
    avatarUrl?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    children?: ParentChildListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    children?: ParentChildOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    email?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    name?: StringFilter<"Parent"> | string
    phone?: StringNullableFilter<"Parent"> | string | null
    avatarUrl?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    children?: ParentChildListRelationFilter
    appointments?: AppointmentListRelationFilter
  }, "id" | "userId" | "email">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _avg?: ParentAvgOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
    _sum?: ParentSumOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Parent"> | number
    userId?: IntNullableWithAggregatesFilter<"Parent"> | number | null
    name?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringWithAggregatesFilter<"Parent"> | string
    phone?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type ParentChildWhereInput = {
    AND?: ParentChildWhereInput | ParentChildWhereInput[]
    OR?: ParentChildWhereInput[]
    NOT?: ParentChildWhereInput | ParentChildWhereInput[]
    id?: IntFilter<"ParentChild"> | number
    parentId?: IntFilter<"ParentChild"> | number
    studentId?: IntFilter<"ParentChild"> | number
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ParentChildOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    parent?: ParentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type ParentChildWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    parentId_studentId?: ParentChildParentIdStudentIdCompoundUniqueInput
    AND?: ParentChildWhereInput | ParentChildWhereInput[]
    OR?: ParentChildWhereInput[]
    NOT?: ParentChildWhereInput | ParentChildWhereInput[]
    parentId?: IntFilter<"ParentChild"> | number
    studentId?: IntFilter<"ParentChild"> | number
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "parentId_studentId">

  export type ParentChildOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
    _count?: ParentChildCountOrderByAggregateInput
    _avg?: ParentChildAvgOrderByAggregateInput
    _max?: ParentChildMaxOrderByAggregateInput
    _min?: ParentChildMinOrderByAggregateInput
    _sum?: ParentChildSumOrderByAggregateInput
  }

  export type ParentChildScalarWhereWithAggregatesInput = {
    AND?: ParentChildScalarWhereWithAggregatesInput | ParentChildScalarWhereWithAggregatesInput[]
    OR?: ParentChildScalarWhereWithAggregatesInput[]
    NOT?: ParentChildScalarWhereWithAggregatesInput | ParentChildScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ParentChild"> | number
    parentId?: IntWithAggregatesFilter<"ParentChild"> | number
    studentId?: IntWithAggregatesFilter<"ParentChild"> | number
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    subject?: StringFilter<"Class"> | string
    grade?: IntFilter<"Class"> | number
    section?: StringFilter<"Class"> | string
    department?: StringNullableFilter<"Class"> | string | null
    studentCount?: IntNullableFilter<"Class"> | number | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrderInput | SortOrder
    studentCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    subject?: StringFilter<"Class"> | string
    grade?: IntFilter<"Class"> | number
    section?: StringFilter<"Class"> | string
    department?: StringNullableFilter<"Class"> | string | null
    studentCount?: IntNullableFilter<"Class"> | number | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrderInput | SortOrder
    studentCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    subject?: StringWithAggregatesFilter<"Class"> | string
    grade?: IntWithAggregatesFilter<"Class"> | number
    section?: StringWithAggregatesFilter<"Class"> | string
    department?: StringNullableWithAggregatesFilter<"Class"> | string | null
    studentCount?: IntNullableWithAggregatesFilter<"Class"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type TeacherSubjectWhereInput = {
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    id?: IntFilter<"TeacherSubject"> | number
    teacherId?: IntFilter<"TeacherSubject"> | number
    subject?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type TeacherSubjectOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type TeacherSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    teacherId?: IntFilter<"TeacherSubject"> | number
    subject?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type TeacherSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    _count?: TeacherSubjectCountOrderByAggregateInput
    _avg?: TeacherSubjectAvgOrderByAggregateInput
    _max?: TeacherSubjectMaxOrderByAggregateInput
    _min?: TeacherSubjectMinOrderByAggregateInput
    _sum?: TeacherSubjectSumOrderByAggregateInput
  }

  export type TeacherSubjectScalarWhereWithAggregatesInput = {
    AND?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    OR?: TeacherSubjectScalarWhereWithAggregatesInput[]
    NOT?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherSubject"> | number
    teacherId?: IntWithAggregatesFilter<"TeacherSubject"> | number
    subject?: StringWithAggregatesFilter<"TeacherSubject"> | string
  }

  export type TeacherClassWhereInput = {
    AND?: TeacherClassWhereInput | TeacherClassWhereInput[]
    OR?: TeacherClassWhereInput[]
    NOT?: TeacherClassWhereInput | TeacherClassWhereInput[]
    id?: IntFilter<"TeacherClass"> | number
    teacherId?: IntFilter<"TeacherClass"> | number
    className?: StringFilter<"TeacherClass"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type TeacherClassOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    className?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type TeacherClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeacherClassWhereInput | TeacherClassWhereInput[]
    OR?: TeacherClassWhereInput[]
    NOT?: TeacherClassWhereInput | TeacherClassWhereInput[]
    teacherId?: IntFilter<"TeacherClass"> | number
    className?: StringFilter<"TeacherClass"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type TeacherClassOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    className?: SortOrder
    _count?: TeacherClassCountOrderByAggregateInput
    _avg?: TeacherClassAvgOrderByAggregateInput
    _max?: TeacherClassMaxOrderByAggregateInput
    _min?: TeacherClassMinOrderByAggregateInput
    _sum?: TeacherClassSumOrderByAggregateInput
  }

  export type TeacherClassScalarWhereWithAggregatesInput = {
    AND?: TeacherClassScalarWhereWithAggregatesInput | TeacherClassScalarWhereWithAggregatesInput[]
    OR?: TeacherClassScalarWhereWithAggregatesInput[]
    NOT?: TeacherClassScalarWhereWithAggregatesInput | TeacherClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeacherClass"> | number
    teacherId?: IntWithAggregatesFilter<"TeacherClass"> | number
    className?: StringWithAggregatesFilter<"TeacherClass"> | string
  }

  export type TimetableWhereInput = {
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    id?: IntFilter<"Timetable"> | number
    day?: StringFilter<"Timetable"> | string
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    className?: StringFilter<"Timetable"> | string
    teacherId?: IntNullableFilter<"Timetable"> | number | null
    status?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }

  export type TimetableOrderByWithRelationInput = {
    id?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type TimetableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    day?: StringFilter<"Timetable"> | string
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    className?: StringFilter<"Timetable"> | string
    teacherId?: IntNullableFilter<"Timetable"> | number | null
    status?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type TimetableOrderByWithAggregationInput = {
    id?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimetableCountOrderByAggregateInput
    _avg?: TimetableAvgOrderByAggregateInput
    _max?: TimetableMaxOrderByAggregateInput
    _min?: TimetableMinOrderByAggregateInput
    _sum?: TimetableSumOrderByAggregateInput
  }

  export type TimetableScalarWhereWithAggregatesInput = {
    AND?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    OR?: TimetableScalarWhereWithAggregatesInput[]
    NOT?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Timetable"> | number
    day?: StringWithAggregatesFilter<"Timetable"> | string
    startTime?: StringWithAggregatesFilter<"Timetable"> | string
    endTime?: StringWithAggregatesFilter<"Timetable"> | string
    subject?: StringWithAggregatesFilter<"Timetable"> | string
    className?: StringWithAggregatesFilter<"Timetable"> | string
    teacherId?: IntNullableWithAggregatesFilter<"Timetable"> | number | null
    status?: StringNullableWithAggregatesFilter<"Timetable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
  }

  export type StudentAttendanceWhereInput = {
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    id?: IntFilter<"StudentAttendance"> | number
    studentId?: IntFilter<"StudentAttendance"> | number
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: StringFilter<"StudentAttendance"> | string
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentAttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentAttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    studentId_date?: StudentAttendanceStudentIdDateCompoundUniqueInput
    AND?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    OR?: StudentAttendanceWhereInput[]
    NOT?: StudentAttendanceWhereInput | StudentAttendanceWhereInput[]
    studentId?: IntFilter<"StudentAttendance"> | number
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: StringFilter<"StudentAttendance"> | string
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "studentId_date">

  export type StudentAttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: StudentAttendanceCountOrderByAggregateInput
    _avg?: StudentAttendanceAvgOrderByAggregateInput
    _max?: StudentAttendanceMaxOrderByAggregateInput
    _min?: StudentAttendanceMinOrderByAggregateInput
    _sum?: StudentAttendanceSumOrderByAggregateInput
  }

  export type StudentAttendanceScalarWhereWithAggregatesInput = {
    AND?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    OR?: StudentAttendanceScalarWhereWithAggregatesInput[]
    NOT?: StudentAttendanceScalarWhereWithAggregatesInput | StudentAttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentAttendance"> | number
    studentId?: IntWithAggregatesFilter<"StudentAttendance"> | number
    date?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
    status?: StringWithAggregatesFilter<"StudentAttendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentAttendance"> | Date | string
  }

  export type AcademicPerformanceWhereInput = {
    AND?: AcademicPerformanceWhereInput | AcademicPerformanceWhereInput[]
    OR?: AcademicPerformanceWhereInput[]
    NOT?: AcademicPerformanceWhereInput | AcademicPerformanceWhereInput[]
    id?: IntFilter<"AcademicPerformance"> | number
    studentId?: IntFilter<"AcademicPerformance"> | number
    subject?: StringFilter<"AcademicPerformance"> | string
    score?: IntNullableFilter<"AcademicPerformance"> | number | null
    term?: StringFilter<"AcademicPerformance"> | string
    session?: StringNullableFilter<"AcademicPerformance"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type AcademicPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    score?: SortOrderInput | SortOrder
    term?: SortOrder
    session?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type AcademicPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AcademicPerformanceWhereInput | AcademicPerformanceWhereInput[]
    OR?: AcademicPerformanceWhereInput[]
    NOT?: AcademicPerformanceWhereInput | AcademicPerformanceWhereInput[]
    studentId?: IntFilter<"AcademicPerformance"> | number
    subject?: StringFilter<"AcademicPerformance"> | string
    score?: IntNullableFilter<"AcademicPerformance"> | number | null
    term?: StringFilter<"AcademicPerformance"> | string
    session?: StringNullableFilter<"AcademicPerformance"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type AcademicPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    score?: SortOrderInput | SortOrder
    term?: SortOrder
    session?: SortOrderInput | SortOrder
    _count?: AcademicPerformanceCountOrderByAggregateInput
    _avg?: AcademicPerformanceAvgOrderByAggregateInput
    _max?: AcademicPerformanceMaxOrderByAggregateInput
    _min?: AcademicPerformanceMinOrderByAggregateInput
    _sum?: AcademicPerformanceSumOrderByAggregateInput
  }

  export type AcademicPerformanceScalarWhereWithAggregatesInput = {
    AND?: AcademicPerformanceScalarWhereWithAggregatesInput | AcademicPerformanceScalarWhereWithAggregatesInput[]
    OR?: AcademicPerformanceScalarWhereWithAggregatesInput[]
    NOT?: AcademicPerformanceScalarWhereWithAggregatesInput | AcademicPerformanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AcademicPerformance"> | number
    studentId?: IntWithAggregatesFilter<"AcademicPerformance"> | number
    subject?: StringWithAggregatesFilter<"AcademicPerformance"> | string
    score?: IntNullableWithAggregatesFilter<"AcademicPerformance"> | number | null
    term?: StringWithAggregatesFilter<"AcademicPerformance"> | string
    session?: StringNullableWithAggregatesFilter<"AcademicPerformance"> | string | null
  }

  export type BehaviorRecordWhereInput = {
    AND?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    OR?: BehaviorRecordWhereInput[]
    NOT?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    id?: IntFilter<"BehaviorRecord"> | number
    studentId?: IntFilter<"BehaviorRecord"> | number
    type?: StringFilter<"BehaviorRecord"> | string
    title?: StringFilter<"BehaviorRecord"> | string
    summary?: StringNullableFilter<"BehaviorRecord"> | string | null
    timestamp?: DateTimeFilter<"BehaviorRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type BehaviorRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type BehaviorRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    OR?: BehaviorRecordWhereInput[]
    NOT?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    studentId?: IntFilter<"BehaviorRecord"> | number
    type?: StringFilter<"BehaviorRecord"> | string
    title?: StringFilter<"BehaviorRecord"> | string
    summary?: StringNullableFilter<"BehaviorRecord"> | string | null
    timestamp?: DateTimeFilter<"BehaviorRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type BehaviorRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: BehaviorRecordCountOrderByAggregateInput
    _avg?: BehaviorRecordAvgOrderByAggregateInput
    _max?: BehaviorRecordMaxOrderByAggregateInput
    _min?: BehaviorRecordMinOrderByAggregateInput
    _sum?: BehaviorRecordSumOrderByAggregateInput
  }

  export type BehaviorRecordScalarWhereWithAggregatesInput = {
    AND?: BehaviorRecordScalarWhereWithAggregatesInput | BehaviorRecordScalarWhereWithAggregatesInput[]
    OR?: BehaviorRecordScalarWhereWithAggregatesInput[]
    NOT?: BehaviorRecordScalarWhereWithAggregatesInput | BehaviorRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BehaviorRecord"> | number
    studentId?: IntWithAggregatesFilter<"BehaviorRecord"> | number
    type?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    title?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    summary?: StringNullableWithAggregatesFilter<"BehaviorRecord"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"BehaviorRecord"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: IntFilter<"Badge"> | number
    studentId?: IntFilter<"Badge"> | number
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    iconName?: StringNullableFilter<"Badge"> | string | null
    color?: StringNullableFilter<"Badge"> | string | null
    awardedAt?: DateTimeFilter<"Badge"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    awardedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    studentId?: IntFilter<"Badge"> | number
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    iconName?: StringNullableFilter<"Badge"> | string | null
    color?: StringNullableFilter<"Badge"> | string | null
    awardedAt?: DateTimeFilter<"Badge"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    iconName?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    awardedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Badge"> | number
    studentId?: IntWithAggregatesFilter<"Badge"> | number
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    iconName?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    color?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    awardedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: IntFilter<"Certificate"> | number
    studentId?: IntFilter<"Certificate"> | number
    name?: StringFilter<"Certificate"> | string
    issuer?: StringNullableFilter<"Certificate"> | string | null
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    issuer?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    issuedDate?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    studentId?: IntFilter<"Certificate"> | number
    name?: StringFilter<"Certificate"> | string
    issuer?: StringNullableFilter<"Certificate"> | string | null
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    issuer?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    issuedDate?: SortOrderInput | SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Certificate"> | number
    studentId?: IntWithAggregatesFilter<"Certificate"> | number
    name?: StringWithAggregatesFilter<"Certificate"> | string
    issuer?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    issuedDate?: DateTimeNullableWithAggregatesFilter<"Certificate"> | Date | string | null
  }

  export type AwardWhereInput = {
    AND?: AwardWhereInput | AwardWhereInput[]
    OR?: AwardWhereInput[]
    NOT?: AwardWhereInput | AwardWhereInput[]
    id?: IntFilter<"Award"> | number
    studentId?: IntFilter<"Award"> | number
    name?: StringFilter<"Award"> | string
    description?: StringNullableFilter<"Award"> | string | null
    date?: DateTimeNullableFilter<"Award"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type AwardOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type AwardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AwardWhereInput | AwardWhereInput[]
    OR?: AwardWhereInput[]
    NOT?: AwardWhereInput | AwardWhereInput[]
    studentId?: IntFilter<"Award"> | number
    name?: StringFilter<"Award"> | string
    description?: StringNullableFilter<"Award"> | string | null
    date?: DateTimeNullableFilter<"Award"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type AwardOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    _count?: AwardCountOrderByAggregateInput
    _avg?: AwardAvgOrderByAggregateInput
    _max?: AwardMaxOrderByAggregateInput
    _min?: AwardMinOrderByAggregateInput
    _sum?: AwardSumOrderByAggregateInput
  }

  export type AwardScalarWhereWithAggregatesInput = {
    AND?: AwardScalarWhereWithAggregatesInput | AwardScalarWhereWithAggregatesInput[]
    OR?: AwardScalarWhereWithAggregatesInput[]
    NOT?: AwardScalarWhereWithAggregatesInput | AwardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Award"> | number
    studentId?: IntWithAggregatesFilter<"Award"> | number
    name?: StringWithAggregatesFilter<"Award"> | string
    description?: StringNullableWithAggregatesFilter<"Award"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Award"> | Date | string | null
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: IntFilter<"Assignment"> | number
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    className?: StringFilter<"Assignment"> | string
    subject?: StringFilter<"Assignment"> | string
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    totalStudents?: IntNullableFilter<"Assignment"> | number | null
    submissionsCount?: IntNullableFilter<"Assignment"> | number | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    submissions?: SubmissionListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    className?: SortOrder
    subject?: SortOrder
    dueDate?: SortOrder
    totalStudents?: SortOrderInput | SortOrder
    submissionsCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    submissions?: SubmissionOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    title?: StringFilter<"Assignment"> | string
    description?: StringNullableFilter<"Assignment"> | string | null
    className?: StringFilter<"Assignment"> | string
    subject?: StringFilter<"Assignment"> | string
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    totalStudents?: IntNullableFilter<"Assignment"> | number | null
    submissionsCount?: IntNullableFilter<"Assignment"> | number | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    submissions?: SubmissionListRelationFilter
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    className?: SortOrder
    subject?: SortOrder
    dueDate?: SortOrder
    totalStudents?: SortOrderInput | SortOrder
    submissionsCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assignment"> | number
    title?: StringWithAggregatesFilter<"Assignment"> | string
    description?: StringNullableWithAggregatesFilter<"Assignment"> | string | null
    className?: StringWithAggregatesFilter<"Assignment"> | string
    subject?: StringWithAggregatesFilter<"Assignment"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    totalStudents?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    submissionsCount?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    id?: IntFilter<"Submission"> | number
    assignmentId?: IntFilter<"Submission"> | number
    studentId?: IntFilter<"Submission"> | number
    submittedAt?: DateTimeFilter<"Submission"> | Date | string
    isLate?: BoolNullableFilter<"Submission"> | boolean | null
    status?: StringNullableFilter<"Submission"> | string | null
    grade?: IntNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    textSubmission?: StringNullableFilter<"Submission"> | string | null
    fileUrl?: StringNullableFilter<"Submission"> | string | null
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    isLate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    textSubmission?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    assignmentId?: IntFilter<"Submission"> | number
    studentId?: IntFilter<"Submission"> | number
    submittedAt?: DateTimeFilter<"Submission"> | Date | string
    isLate?: BoolNullableFilter<"Submission"> | boolean | null
    status?: StringNullableFilter<"Submission"> | string | null
    grade?: IntNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    textSubmission?: StringNullableFilter<"Submission"> | string | null
    fileUrl?: StringNullableFilter<"Submission"> | string | null
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    isLate?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    textSubmission?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    OR?: SubmissionScalarWhereWithAggregatesInput[]
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Submission"> | number
    assignmentId?: IntWithAggregatesFilter<"Submission"> | number
    studentId?: IntWithAggregatesFilter<"Submission"> | number
    submittedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
    isLate?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    grade?: IntNullableWithAggregatesFilter<"Submission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    textSubmission?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Submission"> | string | null
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: IntFilter<"Exam"> | number
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    time?: StringFilter<"Exam"> | string
    className?: StringFilter<"Exam"> | string
    subject?: StringFilter<"Exam"> | string
    isPublished?: BoolNullableFilter<"Exam"> | boolean | null
    teacherId?: IntNullableFilter<"Exam"> | number | null
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    time?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    isPublished?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    time?: StringFilter<"Exam"> | string
    className?: StringFilter<"Exam"> | string
    subject?: StringFilter<"Exam"> | string
    isPublished?: BoolNullableFilter<"Exam"> | boolean | null
    teacherId?: IntNullableFilter<"Exam"> | number | null
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    time?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    isPublished?: SortOrderInput | SortOrder
    teacherId?: SortOrderInput | SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exam"> | number
    type?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    time?: StringWithAggregatesFilter<"Exam"> | string
    className?: StringWithAggregatesFilter<"Exam"> | string
    subject?: StringWithAggregatesFilter<"Exam"> | string
    isPublished?: BoolNullableWithAggregatesFilter<"Exam"> | boolean | null
    teacherId?: IntNullableWithAggregatesFilter<"Exam"> | number | null
  }

  export type NoticeWhereInput = {
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    id?: IntFilter<"Notice"> | number
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    timestamp?: DateTimeFilter<"Notice"> | Date | string
    category?: StringFilter<"Notice"> | string
    isPinned?: BoolNullableFilter<"Notice"> | boolean | null
    audience?: JsonNullableFilter<"Notice">
    createdBy?: StringNullableFilter<"Notice"> | string | null
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    category?: SortOrder
    isPinned?: SortOrderInput | SortOrder
    audience?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
  }

  export type NoticeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeWhereInput | NoticeWhereInput[]
    OR?: NoticeWhereInput[]
    NOT?: NoticeWhereInput | NoticeWhereInput[]
    title?: StringFilter<"Notice"> | string
    content?: StringFilter<"Notice"> | string
    timestamp?: DateTimeFilter<"Notice"> | Date | string
    category?: StringFilter<"Notice"> | string
    isPinned?: BoolNullableFilter<"Notice"> | boolean | null
    audience?: JsonNullableFilter<"Notice">
    createdBy?: StringNullableFilter<"Notice"> | string | null
  }, "id">

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    category?: SortOrder
    isPinned?: SortOrderInput | SortOrder
    audience?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    OR?: NoticeScalarWhereWithAggregatesInput[]
    NOT?: NoticeScalarWhereWithAggregatesInput | NoticeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notice"> | number
    title?: StringWithAggregatesFilter<"Notice"> | string
    content?: StringWithAggregatesFilter<"Notice"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Notice"> | Date | string
    category?: StringWithAggregatesFilter<"Notice"> | string
    isPinned?: BoolNullableWithAggregatesFilter<"Notice"> | boolean | null
    audience?: JsonNullableWithAggregatesFilter<"Notice">
    createdBy?: StringNullableWithAggregatesFilter<"Notice"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntNullableFilter<"Notification"> | number | null
    category?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    summary?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolNullableFilter<"Notification"> | boolean | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    studentId?: IntNullableFilter<"Notification"> | number | null
    relatedId?: IntNullableFilter<"Notification"> | number | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    isRead?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    studentId?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntNullableFilter<"Notification"> | number | null
    category?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    summary?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolNullableFilter<"Notification"> | boolean | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    studentId?: IntNullableFilter<"Notification"> | number | null
    relatedId?: IntNullableFilter<"Notification"> | number | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    isRead?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    studentId?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    category?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    summary?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolNullableWithAggregatesFilter<"Notification"> | boolean | null
    timestamp?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    studentId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    relatedId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: IntFilter<"Conversation"> | number
    type?: StringFilter<"Conversation"> | string
    name?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessageText?: StringNullableFilter<"Conversation"> | string | null
    messages?: MessageListRelationFilter
    participants?: ConversationParticipantListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessageText?: SortOrderInput | SortOrder
    messages?: MessageOrderByRelationAggregateInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    type?: StringFilter<"Conversation"> | string
    name?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessageText?: StringNullableFilter<"Conversation"> | string | null
    messages?: MessageListRelationFilter
    participants?: ConversationParticipantListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessageText?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Conversation"> | number
    type?: StringWithAggregatesFilter<"Conversation"> | string
    name?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    lastMessageText?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    userId?: IntFilter<"ConversationParticipant"> | number
    role?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    conversationId_userId?: ConversationParticipantConversationIdUserIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    userId?: IntFilter<"ConversationParticipant"> | number
    role?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "conversationId_userId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    joinedAt?: SortOrderInput | SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _avg?: ConversationParticipantAvgOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
    _sum?: ConversationParticipantSumOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    conversationId?: IntWithAggregatesFilter<"ConversationParticipant"> | number
    userId?: IntWithAggregatesFilter<"ConversationParticipant"> | number
    role?: StringNullableWithAggregatesFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeNullableWithAggregatesFilter<"ConversationParticipant"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    conversationId?: IntFilter<"Message"> | number
    senderId?: IntNullableFilter<"Message"> | number | null
    content?: StringNullableFilter<"Message"> | string | null
    type?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolNullableFilter<"Message"> | boolean | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: IntFilter<"Message"> | number
    senderId?: IntNullableFilter<"Message"> | number | null
    content?: StringNullableFilter<"Message"> | string | null
    type?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolNullableFilter<"Message"> | boolean | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    sender?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    conversationId?: IntWithAggregatesFilter<"Message"> | number
    senderId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    type?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isRead?: BoolNullableWithAggregatesFilter<"Message"> | boolean | null
  }

  export type ForumTopicWhereInput = {
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    id?: IntFilter<"ForumTopic"> | number
    title?: StringFilter<"ForumTopic"> | string
    authorName?: StringFilter<"ForumTopic"> | string
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    postCount?: IntNullableFilter<"ForumTopic"> | number | null
    lastActivity?: DateTimeFilter<"ForumTopic"> | Date | string
    posts?: ForumPostListRelationFilter
  }

  export type ForumTopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    postCount?: SortOrderInput | SortOrder
    lastActivity?: SortOrder
    posts?: ForumPostOrderByRelationAggregateInput
  }

  export type ForumTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ForumTopicWhereInput | ForumTopicWhereInput[]
    OR?: ForumTopicWhereInput[]
    NOT?: ForumTopicWhereInput | ForumTopicWhereInput[]
    title?: StringFilter<"ForumTopic"> | string
    authorName?: StringFilter<"ForumTopic"> | string
    createdAt?: DateTimeFilter<"ForumTopic"> | Date | string
    postCount?: IntNullableFilter<"ForumTopic"> | number | null
    lastActivity?: DateTimeFilter<"ForumTopic"> | Date | string
    posts?: ForumPostListRelationFilter
  }, "id">

  export type ForumTopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    postCount?: SortOrderInput | SortOrder
    lastActivity?: SortOrder
    _count?: ForumTopicCountOrderByAggregateInput
    _avg?: ForumTopicAvgOrderByAggregateInput
    _max?: ForumTopicMaxOrderByAggregateInput
    _min?: ForumTopicMinOrderByAggregateInput
    _sum?: ForumTopicSumOrderByAggregateInput
  }

  export type ForumTopicScalarWhereWithAggregatesInput = {
    AND?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    OR?: ForumTopicScalarWhereWithAggregatesInput[]
    NOT?: ForumTopicScalarWhereWithAggregatesInput | ForumTopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ForumTopic"> | number
    title?: StringWithAggregatesFilter<"ForumTopic"> | string
    authorName?: StringWithAggregatesFilter<"ForumTopic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
    postCount?: IntNullableWithAggregatesFilter<"ForumTopic"> | number | null
    lastActivity?: DateTimeWithAggregatesFilter<"ForumTopic"> | Date | string
  }

  export type ForumPostWhereInput = {
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    id?: IntFilter<"ForumPost"> | number
    topicId?: IntFilter<"ForumPost"> | number
    authorName?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    timestamp?: DateTimeFilter<"ForumPost"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorName?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    topic?: ForumTopicOrderByWithRelationInput
  }

  export type ForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    topicId?: IntFilter<"ForumPost"> | number
    authorName?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    timestamp?: DateTimeFilter<"ForumPost"> | Date | string
    topic?: XOR<ForumTopicRelationFilter, ForumTopicWhereInput>
  }, "id">

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorName?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _avg?: ForumPostAvgOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
    _sum?: ForumPostSumOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    OR?: ForumPostScalarWhereWithAggregatesInput[]
    NOT?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ForumPost"> | number
    topicId?: IntWithAggregatesFilter<"ForumPost"> | number
    authorName?: StringWithAggregatesFilter<"ForumPost"> | string
    content?: StringWithAggregatesFilter<"ForumPost"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: UuidFilter<"Complaint"> | string
    userId?: IntNullableFilter<"Complaint"> | number | null
    category?: StringFilter<"Complaint"> | string
    rating?: IntNullableFilter<"Complaint"> | number | null
    comment?: StringNullableFilter<"Complaint"> | string | null
    status?: StringNullableFilter<"Complaint"> | string | null
    timeline?: JsonNullableFilter<"Complaint">
    imageUrl?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    userId?: IntNullableFilter<"Complaint"> | number | null
    category?: StringFilter<"Complaint"> | string
    rating?: IntNullableFilter<"Complaint"> | number | null
    comment?: StringNullableFilter<"Complaint"> | string | null
    status?: StringNullableFilter<"Complaint"> | string | null
    timeline?: JsonNullableFilter<"Complaint">
    imageUrl?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    category?: SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Complaint"> | string
    userId?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    category?: StringWithAggregatesFilter<"Complaint"> | string
    rating?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    comment?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    status?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    timeline?: JsonNullableWithAggregatesFilter<"Complaint">
    imageUrl?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: IntFilter<"Driver"> | number
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    avatarUrl?: StringNullableFilter<"Driver"> | string | null
    roster?: BusRosterListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    roster?: BusRosterOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    name?: StringFilter<"Driver"> | string
    phone?: StringNullableFilter<"Driver"> | string | null
    avatarUrl?: StringNullableFilter<"Driver"> | string | null
    roster?: BusRosterListRelationFilter
  }, "id">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Driver"> | number
    name?: StringWithAggregatesFilter<"Driver"> | string
    phone?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Driver"> | string | null
  }

  export type BusRouteWhereInput = {
    AND?: BusRouteWhereInput | BusRouteWhereInput[]
    OR?: BusRouteWhereInput[]
    NOT?: BusRouteWhereInput | BusRouteWhereInput[]
    id?: StringFilter<"BusRoute"> | string
    name?: StringFilter<"BusRoute"> | string
    description?: StringNullableFilter<"BusRoute"> | string | null
    roster?: BusRosterListRelationFilter
    pickupPoints?: PickupPointListRelationFilter
  }

  export type BusRouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    roster?: BusRosterOrderByRelationAggregateInput
    pickupPoints?: PickupPointOrderByRelationAggregateInput
  }

  export type BusRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusRouteWhereInput | BusRouteWhereInput[]
    OR?: BusRouteWhereInput[]
    NOT?: BusRouteWhereInput | BusRouteWhereInput[]
    name?: StringFilter<"BusRoute"> | string
    description?: StringNullableFilter<"BusRoute"> | string | null
    roster?: BusRosterListRelationFilter
    pickupPoints?: PickupPointListRelationFilter
  }, "id">

  export type BusRouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: BusRouteCountOrderByAggregateInput
    _max?: BusRouteMaxOrderByAggregateInput
    _min?: BusRouteMinOrderByAggregateInput
  }

  export type BusRouteScalarWhereWithAggregatesInput = {
    AND?: BusRouteScalarWhereWithAggregatesInput | BusRouteScalarWhereWithAggregatesInput[]
    OR?: BusRouteScalarWhereWithAggregatesInput[]
    NOT?: BusRouteScalarWhereWithAggregatesInput | BusRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusRoute"> | string
    name?: StringWithAggregatesFilter<"BusRoute"> | string
    description?: StringNullableWithAggregatesFilter<"BusRoute"> | string | null
  }

  export type BusRosterWhereInput = {
    AND?: BusRosterWhereInput | BusRosterWhereInput[]
    OR?: BusRosterWhereInput[]
    NOT?: BusRosterWhereInput | BusRosterWhereInput[]
    id?: IntFilter<"BusRoster"> | number
    routeId?: StringNullableFilter<"BusRoster"> | string | null
    driverId?: IntNullableFilter<"BusRoster"> | number | null
    date?: DateTimeFilter<"BusRoster"> | Date | string
    route?: XOR<BusRouteNullableRelationFilter, BusRouteWhereInput> | null
    driver?: XOR<DriverNullableRelationFilter, DriverWhereInput> | null
  }

  export type BusRosterOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    date?: SortOrder
    route?: BusRouteOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
  }

  export type BusRosterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BusRosterWhereInput | BusRosterWhereInput[]
    OR?: BusRosterWhereInput[]
    NOT?: BusRosterWhereInput | BusRosterWhereInput[]
    routeId?: StringNullableFilter<"BusRoster"> | string | null
    driverId?: IntNullableFilter<"BusRoster"> | number | null
    date?: DateTimeFilter<"BusRoster"> | Date | string
    route?: XOR<BusRouteNullableRelationFilter, BusRouteWhereInput> | null
    driver?: XOR<DriverNullableRelationFilter, DriverWhereInput> | null
  }, "id">

  export type BusRosterOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: BusRosterCountOrderByAggregateInput
    _avg?: BusRosterAvgOrderByAggregateInput
    _max?: BusRosterMaxOrderByAggregateInput
    _min?: BusRosterMinOrderByAggregateInput
    _sum?: BusRosterSumOrderByAggregateInput
  }

  export type BusRosterScalarWhereWithAggregatesInput = {
    AND?: BusRosterScalarWhereWithAggregatesInput | BusRosterScalarWhereWithAggregatesInput[]
    OR?: BusRosterScalarWhereWithAggregatesInput[]
    NOT?: BusRosterScalarWhereWithAggregatesInput | BusRosterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusRoster"> | number
    routeId?: StringNullableWithAggregatesFilter<"BusRoster"> | string | null
    driverId?: IntNullableWithAggregatesFilter<"BusRoster"> | number | null
    date?: DateTimeWithAggregatesFilter<"BusRoster"> | Date | string
  }

  export type PickupPointWhereInput = {
    AND?: PickupPointWhereInput | PickupPointWhereInput[]
    OR?: PickupPointWhereInput[]
    NOT?: PickupPointWhereInput | PickupPointWhereInput[]
    id?: IntFilter<"PickupPoint"> | number
    name?: StringFilter<"PickupPoint"> | string
    routeId?: StringNullableFilter<"PickupPoint"> | string | null
    lat?: FloatNullableFilter<"PickupPoint"> | number | null
    lng?: FloatNullableFilter<"PickupPoint"> | number | null
    uiPositionTop?: StringNullableFilter<"PickupPoint"> | string | null
    uiPositionLeft?: StringNullableFilter<"PickupPoint"> | string | null
    isUserStop?: BoolNullableFilter<"PickupPoint"> | boolean | null
    route?: XOR<BusRouteNullableRelationFilter, BusRouteWhereInput> | null
  }

  export type PickupPointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    routeId?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    uiPositionTop?: SortOrderInput | SortOrder
    uiPositionLeft?: SortOrderInput | SortOrder
    isUserStop?: SortOrderInput | SortOrder
    route?: BusRouteOrderByWithRelationInput
  }

  export type PickupPointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PickupPointWhereInput | PickupPointWhereInput[]
    OR?: PickupPointWhereInput[]
    NOT?: PickupPointWhereInput | PickupPointWhereInput[]
    name?: StringFilter<"PickupPoint"> | string
    routeId?: StringNullableFilter<"PickupPoint"> | string | null
    lat?: FloatNullableFilter<"PickupPoint"> | number | null
    lng?: FloatNullableFilter<"PickupPoint"> | number | null
    uiPositionTop?: StringNullableFilter<"PickupPoint"> | string | null
    uiPositionLeft?: StringNullableFilter<"PickupPoint"> | string | null
    isUserStop?: BoolNullableFilter<"PickupPoint"> | boolean | null
    route?: XOR<BusRouteNullableRelationFilter, BusRouteWhereInput> | null
  }, "id">

  export type PickupPointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    routeId?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    uiPositionTop?: SortOrderInput | SortOrder
    uiPositionLeft?: SortOrderInput | SortOrder
    isUserStop?: SortOrderInput | SortOrder
    _count?: PickupPointCountOrderByAggregateInput
    _avg?: PickupPointAvgOrderByAggregateInput
    _max?: PickupPointMaxOrderByAggregateInput
    _min?: PickupPointMinOrderByAggregateInput
    _sum?: PickupPointSumOrderByAggregateInput
  }

  export type PickupPointScalarWhereWithAggregatesInput = {
    AND?: PickupPointScalarWhereWithAggregatesInput | PickupPointScalarWhereWithAggregatesInput[]
    OR?: PickupPointScalarWhereWithAggregatesInput[]
    NOT?: PickupPointScalarWhereWithAggregatesInput | PickupPointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PickupPoint"> | number
    name?: StringWithAggregatesFilter<"PickupPoint"> | string
    routeId?: StringNullableWithAggregatesFilter<"PickupPoint"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"PickupPoint"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"PickupPoint"> | number | null
    uiPositionTop?: StringNullableWithAggregatesFilter<"PickupPoint"> | string | null
    uiPositionLeft?: StringNullableWithAggregatesFilter<"PickupPoint"> | string | null
    isUserStop?: BoolNullableWithAggregatesFilter<"PickupPoint"> | boolean | null
  }

  export type StudentFeeWhereInput = {
    AND?: StudentFeeWhereInput | StudentFeeWhereInput[]
    OR?: StudentFeeWhereInput[]
    NOT?: StudentFeeWhereInput | StudentFeeWhereInput[]
    id?: IntFilter<"StudentFee"> | number
    studentId?: IntFilter<"StudentFee"> | number
    totalFee?: DecimalFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalNullableFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    status?: StringNullableFilter<"StudentFee"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    payments?: FeePaymentListRelationFilter
  }

  export type StudentFeeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    payments?: FeePaymentOrderByRelationAggregateInput
  }

  export type StudentFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentFeeWhereInput | StudentFeeWhereInput[]
    OR?: StudentFeeWhereInput[]
    NOT?: StudentFeeWhereInput | StudentFeeWhereInput[]
    studentId?: IntFilter<"StudentFee"> | number
    totalFee?: DecimalFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalNullableFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    status?: StringNullableFilter<"StudentFee"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    payments?: FeePaymentListRelationFilter
  }, "id">

  export type StudentFeeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: StudentFeeCountOrderByAggregateInput
    _avg?: StudentFeeAvgOrderByAggregateInput
    _max?: StudentFeeMaxOrderByAggregateInput
    _min?: StudentFeeMinOrderByAggregateInput
    _sum?: StudentFeeSumOrderByAggregateInput
  }

  export type StudentFeeScalarWhereWithAggregatesInput = {
    AND?: StudentFeeScalarWhereWithAggregatesInput | StudentFeeScalarWhereWithAggregatesInput[]
    OR?: StudentFeeScalarWhereWithAggregatesInput[]
    NOT?: StudentFeeScalarWhereWithAggregatesInput | StudentFeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentFee"> | number
    studentId?: IntWithAggregatesFilter<"StudentFee"> | number
    totalFee?: DecimalWithAggregatesFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalNullableWithAggregatesFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeWithAggregatesFilter<"StudentFee"> | Date | string
    status?: StringNullableWithAggregatesFilter<"StudentFee"> | string | null
  }

  export type FeePaymentWhereInput = {
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    id?: IntFilter<"FeePayment"> | number
    feeId?: IntFilter<"FeePayment"> | number
    amount?: DecimalFilter<"FeePayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeNullableFilter<"FeePayment"> | Date | string | null
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
    fee?: XOR<StudentFeeRelationFilter, StudentFeeWhereInput>
  }

  export type FeePaymentOrderByWithRelationInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    date?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    fee?: StudentFeeOrderByWithRelationInput
  }

  export type FeePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeePaymentWhereInput | FeePaymentWhereInput[]
    OR?: FeePaymentWhereInput[]
    NOT?: FeePaymentWhereInput | FeePaymentWhereInput[]
    feeId?: IntFilter<"FeePayment"> | number
    amount?: DecimalFilter<"FeePayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeNullableFilter<"FeePayment"> | Date | string | null
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
    fee?: XOR<StudentFeeRelationFilter, StudentFeeWhereInput>
  }, "id">

  export type FeePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    date?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    _count?: FeePaymentCountOrderByAggregateInput
    _avg?: FeePaymentAvgOrderByAggregateInput
    _max?: FeePaymentMaxOrderByAggregateInput
    _min?: FeePaymentMinOrderByAggregateInput
    _sum?: FeePaymentSumOrderByAggregateInput
  }

  export type FeePaymentScalarWhereWithAggregatesInput = {
    AND?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    OR?: FeePaymentScalarWhereWithAggregatesInput[]
    NOT?: FeePaymentScalarWhereWithAggregatesInput | FeePaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeePayment"> | number
    feeId?: IntWithAggregatesFilter<"FeePayment"> | number
    amount?: DecimalWithAggregatesFilter<"FeePayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeNullableWithAggregatesFilter<"FeePayment"> | Date | string | null
    method?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
    recordedBy?: StringNullableWithAggregatesFilter<"FeePayment"> | string | null
  }

  export type StoreProductWhereInput = {
    AND?: StoreProductWhereInput | StoreProductWhereInput[]
    OR?: StoreProductWhereInput[]
    NOT?: StoreProductWhereInput | StoreProductWhereInput[]
    id?: IntFilter<"StoreProduct"> | number
    name?: StringFilter<"StoreProduct"> | string
    category?: StringFilter<"StoreProduct"> | string
    price?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"StoreProduct"> | string | null
    stock?: IntNullableFilter<"StoreProduct"> | number | null
  }

  export type StoreProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
  }

  export type StoreProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StoreProductWhereInput | StoreProductWhereInput[]
    OR?: StoreProductWhereInput[]
    NOT?: StoreProductWhereInput | StoreProductWhereInput[]
    name?: StringFilter<"StoreProduct"> | string
    category?: StringFilter<"StoreProduct"> | string
    price?: DecimalFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"StoreProduct"> | string | null
    stock?: IntNullableFilter<"StoreProduct"> | number | null
  }, "id">

  export type StoreProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    _count?: StoreProductCountOrderByAggregateInput
    _avg?: StoreProductAvgOrderByAggregateInput
    _max?: StoreProductMaxOrderByAggregateInput
    _min?: StoreProductMinOrderByAggregateInput
    _sum?: StoreProductSumOrderByAggregateInput
  }

  export type StoreProductScalarWhereWithAggregatesInput = {
    AND?: StoreProductScalarWhereWithAggregatesInput | StoreProductScalarWhereWithAggregatesInput[]
    OR?: StoreProductScalarWhereWithAggregatesInput[]
    NOT?: StoreProductScalarWhereWithAggregatesInput | StoreProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StoreProduct"> | number
    name?: StringWithAggregatesFilter<"StoreProduct"> | string
    category?: StringWithAggregatesFilter<"StoreProduct"> | string
    price?: DecimalWithAggregatesFilter<"StoreProduct"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableWithAggregatesFilter<"StoreProduct"> | string | null
    stock?: IntNullableWithAggregatesFilter<"StoreProduct"> | number | null
  }

  export type StoreOrderWhereInput = {
    AND?: StoreOrderWhereInput | StoreOrderWhereInput[]
    OR?: StoreOrderWhereInput[]
    NOT?: StoreOrderWhereInput | StoreOrderWhereInput[]
    id?: StringFilter<"StoreOrder"> | string
    customerName?: StringFilter<"StoreOrder"> | string
    totalAmount?: DecimalFilter<"StoreOrder"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableFilter<"StoreOrder"> | string | null
    orderDate?: DateTimeFilter<"StoreOrder"> | Date | string
    items?: JsonNullableFilter<"StoreOrder">
  }

  export type StoreOrderOrderByWithRelationInput = {
    id?: SortOrder
    customerName?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    items?: SortOrderInput | SortOrder
  }

  export type StoreOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StoreOrderWhereInput | StoreOrderWhereInput[]
    OR?: StoreOrderWhereInput[]
    NOT?: StoreOrderWhereInput | StoreOrderWhereInput[]
    customerName?: StringFilter<"StoreOrder"> | string
    totalAmount?: DecimalFilter<"StoreOrder"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableFilter<"StoreOrder"> | string | null
    orderDate?: DateTimeFilter<"StoreOrder"> | Date | string
    items?: JsonNullableFilter<"StoreOrder">
  }, "id">

  export type StoreOrderOrderByWithAggregationInput = {
    id?: SortOrder
    customerName?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    items?: SortOrderInput | SortOrder
    _count?: StoreOrderCountOrderByAggregateInput
    _avg?: StoreOrderAvgOrderByAggregateInput
    _max?: StoreOrderMaxOrderByAggregateInput
    _min?: StoreOrderMinOrderByAggregateInput
    _sum?: StoreOrderSumOrderByAggregateInput
  }

  export type StoreOrderScalarWhereWithAggregatesInput = {
    AND?: StoreOrderScalarWhereWithAggregatesInput | StoreOrderScalarWhereWithAggregatesInput[]
    OR?: StoreOrderScalarWhereWithAggregatesInput[]
    NOT?: StoreOrderScalarWhereWithAggregatesInput | StoreOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StoreOrder"> | string
    customerName?: StringWithAggregatesFilter<"StoreOrder"> | string
    totalAmount?: DecimalWithAggregatesFilter<"StoreOrder"> | Decimal | DecimalJsLike | number | string
    status?: StringNullableWithAggregatesFilter<"StoreOrder"> | string | null
    orderDate?: DateTimeWithAggregatesFilter<"StoreOrder"> | Date | string
    items?: JsonNullableWithAggregatesFilter<"StoreOrder">
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    userName?: StringNullableFilter<"AuditLog"> | string | null
    userRole?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    type?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userName?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    action?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userName?: StringNullableFilter<"AuditLog"> | string | null
    userRole?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    type?: StringFilter<"AuditLog"> | string
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userName?: SortOrderInput | SortOrder
    userRole?: SortOrderInput | SortOrder
    action?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    userName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userRole?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    type?: StringWithAggregatesFilter<"AuditLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type HealthLogWhereInput = {
    AND?: HealthLogWhereInput | HealthLogWhereInput[]
    OR?: HealthLogWhereInput[]
    NOT?: HealthLogWhereInput | HealthLogWhereInput[]
    id?: IntFilter<"HealthLog"> | number
    studentId?: IntNullableFilter<"HealthLog"> | number | null
    date?: DateTimeFilter<"HealthLog"> | Date | string
    time?: StringNullableFilter<"HealthLog"> | string | null
    reason?: StringFilter<"HealthLog"> | string
    notes?: StringNullableFilter<"HealthLog"> | string | null
    parentNotified?: BoolNullableFilter<"HealthLog"> | boolean | null
    medicationAdministered?: JsonNullableFilter<"HealthLog">
    recordedBy?: StringNullableFilter<"HealthLog"> | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type HealthLogOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    parentNotified?: SortOrderInput | SortOrder
    medicationAdministered?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type HealthLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HealthLogWhereInput | HealthLogWhereInput[]
    OR?: HealthLogWhereInput[]
    NOT?: HealthLogWhereInput | HealthLogWhereInput[]
    studentId?: IntNullableFilter<"HealthLog"> | number | null
    date?: DateTimeFilter<"HealthLog"> | Date | string
    time?: StringNullableFilter<"HealthLog"> | string | null
    reason?: StringFilter<"HealthLog"> | string
    notes?: StringNullableFilter<"HealthLog"> | string | null
    parentNotified?: BoolNullableFilter<"HealthLog"> | boolean | null
    medicationAdministered?: JsonNullableFilter<"HealthLog">
    recordedBy?: StringNullableFilter<"HealthLog"> | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id">

  export type HealthLogOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    parentNotified?: SortOrderInput | SortOrder
    medicationAdministered?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    _count?: HealthLogCountOrderByAggregateInput
    _avg?: HealthLogAvgOrderByAggregateInput
    _max?: HealthLogMaxOrderByAggregateInput
    _min?: HealthLogMinOrderByAggregateInput
    _sum?: HealthLogSumOrderByAggregateInput
  }

  export type HealthLogScalarWhereWithAggregatesInput = {
    AND?: HealthLogScalarWhereWithAggregatesInput | HealthLogScalarWhereWithAggregatesInput[]
    OR?: HealthLogScalarWhereWithAggregatesInput[]
    NOT?: HealthLogScalarWhereWithAggregatesInput | HealthLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthLog"> | number
    studentId?: IntNullableWithAggregatesFilter<"HealthLog"> | number | null
    date?: DateTimeWithAggregatesFilter<"HealthLog"> | Date | string
    time?: StringNullableWithAggregatesFilter<"HealthLog"> | string | null
    reason?: StringWithAggregatesFilter<"HealthLog"> | string
    notes?: StringNullableWithAggregatesFilter<"HealthLog"> | string | null
    parentNotified?: BoolNullableWithAggregatesFilter<"HealthLog"> | boolean | null
    medicationAdministered?: JsonNullableWithAggregatesFilter<"HealthLog">
    recordedBy?: StringNullableWithAggregatesFilter<"HealthLog"> | string | null
  }

  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: IntFilter<"Book"> | number
    title?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    coverUrl?: StringNullableFilter<"Book"> | string | null
    category?: StringFilter<"Book"> | string
    status?: StringNullableFilter<"Book"> | string | null
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrderInput | SortOrder
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    title?: StringFilter<"Book"> | string
    author?: StringFilter<"Book"> | string
    coverUrl?: StringNullableFilter<"Book"> | string | null
    category?: StringFilter<"Book"> | string
    status?: StringNullableFilter<"Book"> | string | null
  }, "id">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: BookCountOrderByAggregateInput
    _avg?: BookAvgOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
    _sum?: BookSumOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Book"> | number
    title?: StringWithAggregatesFilter<"Book"> | string
    author?: StringWithAggregatesFilter<"Book"> | string
    coverUrl?: StringNullableWithAggregatesFilter<"Book"> | string | null
    category?: StringWithAggregatesFilter<"Book"> | string
    status?: StringNullableWithAggregatesFilter<"Book"> | string | null
  }

  export type DigitalResourceWhereInput = {
    AND?: DigitalResourceWhereInput | DigitalResourceWhereInput[]
    OR?: DigitalResourceWhereInput[]
    NOT?: DigitalResourceWhereInput | DigitalResourceWhereInput[]
    id?: IntFilter<"DigitalResource"> | number
    title?: StringFilter<"DigitalResource"> | string
    type?: StringFilter<"DigitalResource"> | string
    subject?: StringNullableFilter<"DigitalResource"> | string | null
    description?: StringNullableFilter<"DigitalResource"> | string | null
    url?: StringFilter<"DigitalResource"> | string
    thumbnailUrl?: StringNullableFilter<"DigitalResource"> | string | null
  }

  export type DigitalResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
  }

  export type DigitalResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DigitalResourceWhereInput | DigitalResourceWhereInput[]
    OR?: DigitalResourceWhereInput[]
    NOT?: DigitalResourceWhereInput | DigitalResourceWhereInput[]
    title?: StringFilter<"DigitalResource"> | string
    type?: StringFilter<"DigitalResource"> | string
    subject?: StringNullableFilter<"DigitalResource"> | string | null
    description?: StringNullableFilter<"DigitalResource"> | string | null
    url?: StringFilter<"DigitalResource"> | string
    thumbnailUrl?: StringNullableFilter<"DigitalResource"> | string | null
  }, "id">

  export type DigitalResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    _count?: DigitalResourceCountOrderByAggregateInput
    _avg?: DigitalResourceAvgOrderByAggregateInput
    _max?: DigitalResourceMaxOrderByAggregateInput
    _min?: DigitalResourceMinOrderByAggregateInput
    _sum?: DigitalResourceSumOrderByAggregateInput
  }

  export type DigitalResourceScalarWhereWithAggregatesInput = {
    AND?: DigitalResourceScalarWhereWithAggregatesInput | DigitalResourceScalarWhereWithAggregatesInput[]
    OR?: DigitalResourceScalarWhereWithAggregatesInput[]
    NOT?: DigitalResourceScalarWhereWithAggregatesInput | DigitalResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DigitalResource"> | number
    title?: StringWithAggregatesFilter<"DigitalResource"> | string
    type?: StringWithAggregatesFilter<"DigitalResource"> | string
    subject?: StringNullableWithAggregatesFilter<"DigitalResource"> | string | null
    description?: StringNullableWithAggregatesFilter<"DigitalResource"> | string | null
    url?: StringWithAggregatesFilter<"DigitalResource"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"DigitalResource"> | string | null
  }

  export type CbtTestWhereInput = {
    AND?: CbtTestWhereInput | CbtTestWhereInput[]
    OR?: CbtTestWhereInput[]
    NOT?: CbtTestWhereInput | CbtTestWhereInput[]
    id?: IntFilter<"CbtTest"> | number
    title?: StringFilter<"CbtTest"> | string
    type?: StringFilter<"CbtTest"> | string
    className?: StringFilter<"CbtTest"> | string
    subject?: StringFilter<"CbtTest"> | string
    durationMinutes?: IntFilter<"CbtTest"> | number
    isPublished?: BoolNullableFilter<"CbtTest"> | boolean | null
    createdAt?: DateTimeFilter<"CbtTest"> | Date | string
    questions?: CbtQuestionListRelationFilter
    results?: CbtResultListRelationFilter
  }

  export type CbtTestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    durationMinutes?: SortOrder
    isPublished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    questions?: CbtQuestionOrderByRelationAggregateInput
    results?: CbtResultOrderByRelationAggregateInput
  }

  export type CbtTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CbtTestWhereInput | CbtTestWhereInput[]
    OR?: CbtTestWhereInput[]
    NOT?: CbtTestWhereInput | CbtTestWhereInput[]
    title?: StringFilter<"CbtTest"> | string
    type?: StringFilter<"CbtTest"> | string
    className?: StringFilter<"CbtTest"> | string
    subject?: StringFilter<"CbtTest"> | string
    durationMinutes?: IntFilter<"CbtTest"> | number
    isPublished?: BoolNullableFilter<"CbtTest"> | boolean | null
    createdAt?: DateTimeFilter<"CbtTest"> | Date | string
    questions?: CbtQuestionListRelationFilter
    results?: CbtResultListRelationFilter
  }, "id">

  export type CbtTestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    durationMinutes?: SortOrder
    isPublished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CbtTestCountOrderByAggregateInput
    _avg?: CbtTestAvgOrderByAggregateInput
    _max?: CbtTestMaxOrderByAggregateInput
    _min?: CbtTestMinOrderByAggregateInput
    _sum?: CbtTestSumOrderByAggregateInput
  }

  export type CbtTestScalarWhereWithAggregatesInput = {
    AND?: CbtTestScalarWhereWithAggregatesInput | CbtTestScalarWhereWithAggregatesInput[]
    OR?: CbtTestScalarWhereWithAggregatesInput[]
    NOT?: CbtTestScalarWhereWithAggregatesInput | CbtTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CbtTest"> | number
    title?: StringWithAggregatesFilter<"CbtTest"> | string
    type?: StringWithAggregatesFilter<"CbtTest"> | string
    className?: StringWithAggregatesFilter<"CbtTest"> | string
    subject?: StringWithAggregatesFilter<"CbtTest"> | string
    durationMinutes?: IntWithAggregatesFilter<"CbtTest"> | number
    isPublished?: BoolNullableWithAggregatesFilter<"CbtTest"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"CbtTest"> | Date | string
  }

  export type CbtQuestionWhereInput = {
    AND?: CbtQuestionWhereInput | CbtQuestionWhereInput[]
    OR?: CbtQuestionWhereInput[]
    NOT?: CbtQuestionWhereInput | CbtQuestionWhereInput[]
    id?: IntFilter<"CbtQuestion"> | number
    testId?: IntFilter<"CbtQuestion"> | number
    questionText?: StringFilter<"CbtQuestion"> | string
    options?: JsonFilter<"CbtQuestion">
    correctAnswer?: StringFilter<"CbtQuestion"> | string
    test?: XOR<CbtTestRelationFilter, CbtTestWhereInput>
  }

  export type CbtQuestionOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    test?: CbtTestOrderByWithRelationInput
  }

  export type CbtQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CbtQuestionWhereInput | CbtQuestionWhereInput[]
    OR?: CbtQuestionWhereInput[]
    NOT?: CbtQuestionWhereInput | CbtQuestionWhereInput[]
    testId?: IntFilter<"CbtQuestion"> | number
    questionText?: StringFilter<"CbtQuestion"> | string
    options?: JsonFilter<"CbtQuestion">
    correctAnswer?: StringFilter<"CbtQuestion"> | string
    test?: XOR<CbtTestRelationFilter, CbtTestWhereInput>
  }, "id">

  export type CbtQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    _count?: CbtQuestionCountOrderByAggregateInput
    _avg?: CbtQuestionAvgOrderByAggregateInput
    _max?: CbtQuestionMaxOrderByAggregateInput
    _min?: CbtQuestionMinOrderByAggregateInput
    _sum?: CbtQuestionSumOrderByAggregateInput
  }

  export type CbtQuestionScalarWhereWithAggregatesInput = {
    AND?: CbtQuestionScalarWhereWithAggregatesInput | CbtQuestionScalarWhereWithAggregatesInput[]
    OR?: CbtQuestionScalarWhereWithAggregatesInput[]
    NOT?: CbtQuestionScalarWhereWithAggregatesInput | CbtQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CbtQuestion"> | number
    testId?: IntWithAggregatesFilter<"CbtQuestion"> | number
    questionText?: StringWithAggregatesFilter<"CbtQuestion"> | string
    options?: JsonWithAggregatesFilter<"CbtQuestion">
    correctAnswer?: StringWithAggregatesFilter<"CbtQuestion"> | string
  }

  export type CbtResultWhereInput = {
    AND?: CbtResultWhereInput | CbtResultWhereInput[]
    OR?: CbtResultWhereInput[]
    NOT?: CbtResultWhereInput | CbtResultWhereInput[]
    id?: IntFilter<"CbtResult"> | number
    testId?: IntFilter<"CbtResult"> | number
    studentId?: IntFilter<"CbtResult"> | number
    score?: IntFilter<"CbtResult"> | number
    totalQuestions?: IntFilter<"CbtResult"> | number
    submittedAt?: DateTimeFilter<"CbtResult"> | Date | string
    test?: XOR<CbtTestRelationFilter, CbtTestWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CbtResultOrderByWithRelationInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    submittedAt?: SortOrder
    test?: CbtTestOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type CbtResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CbtResultWhereInput | CbtResultWhereInput[]
    OR?: CbtResultWhereInput[]
    NOT?: CbtResultWhereInput | CbtResultWhereInput[]
    testId?: IntFilter<"CbtResult"> | number
    studentId?: IntFilter<"CbtResult"> | number
    score?: IntFilter<"CbtResult"> | number
    totalQuestions?: IntFilter<"CbtResult"> | number
    submittedAt?: DateTimeFilter<"CbtResult"> | Date | string
    test?: XOR<CbtTestRelationFilter, CbtTestWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type CbtResultOrderByWithAggregationInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    submittedAt?: SortOrder
    _count?: CbtResultCountOrderByAggregateInput
    _avg?: CbtResultAvgOrderByAggregateInput
    _max?: CbtResultMaxOrderByAggregateInput
    _min?: CbtResultMinOrderByAggregateInput
    _sum?: CbtResultSumOrderByAggregateInput
  }

  export type CbtResultScalarWhereWithAggregatesInput = {
    AND?: CbtResultScalarWhereWithAggregatesInput | CbtResultScalarWhereWithAggregatesInput[]
    OR?: CbtResultScalarWhereWithAggregatesInput[]
    NOT?: CbtResultScalarWhereWithAggregatesInput | CbtResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CbtResult"> | number
    testId?: IntWithAggregatesFilter<"CbtResult"> | number
    studentId?: IntWithAggregatesFilter<"CbtResult"> | number
    score?: IntWithAggregatesFilter<"CbtResult"> | number
    totalQuestions?: IntWithAggregatesFilter<"CbtResult"> | number
    submittedAt?: DateTimeWithAggregatesFilter<"CbtResult"> | Date | string
  }

  export type CalendarEventWhereInput = {
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    id?: IntFilter<"CalendarEvent"> | number
    title?: StringFilter<"CalendarEvent"> | string
    startDate?: DateTimeFilter<"CalendarEvent"> | Date | string
    endDate?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    type?: StringNullableFilter<"CalendarEvent"> | string | null
    description?: StringNullableFilter<"CalendarEvent"> | string | null
  }

  export type CalendarEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type CalendarEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CalendarEventWhereInput | CalendarEventWhereInput[]
    OR?: CalendarEventWhereInput[]
    NOT?: CalendarEventWhereInput | CalendarEventWhereInput[]
    title?: StringFilter<"CalendarEvent"> | string
    startDate?: DateTimeFilter<"CalendarEvent"> | Date | string
    endDate?: DateTimeNullableFilter<"CalendarEvent"> | Date | string | null
    type?: StringNullableFilter<"CalendarEvent"> | string | null
    description?: StringNullableFilter<"CalendarEvent"> | string | null
  }, "id">

  export type CalendarEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CalendarEventCountOrderByAggregateInput
    _avg?: CalendarEventAvgOrderByAggregateInput
    _max?: CalendarEventMaxOrderByAggregateInput
    _min?: CalendarEventMinOrderByAggregateInput
    _sum?: CalendarEventSumOrderByAggregateInput
  }

  export type CalendarEventScalarWhereWithAggregatesInput = {
    AND?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    OR?: CalendarEventScalarWhereWithAggregatesInput[]
    NOT?: CalendarEventScalarWhereWithAggregatesInput | CalendarEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalendarEvent"> | number
    title?: StringWithAggregatesFilter<"CalendarEvent"> | string
    startDate?: DateTimeWithAggregatesFilter<"CalendarEvent"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"CalendarEvent"> | Date | string | null
    type?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"CalendarEvent"> | string | null
  }

  export type ExtracurricularActivityWhereInput = {
    AND?: ExtracurricularActivityWhereInput | ExtracurricularActivityWhereInput[]
    OR?: ExtracurricularActivityWhereInput[]
    NOT?: ExtracurricularActivityWhereInput | ExtracurricularActivityWhereInput[]
    id?: IntFilter<"ExtracurricularActivity"> | number
    name?: StringFilter<"ExtracurricularActivity"> | string
    category?: StringFilter<"ExtracurricularActivity"> | string
    description?: StringNullableFilter<"ExtracurricularActivity"> | string | null
    schedule?: StringNullableFilter<"ExtracurricularActivity"> | string | null
  }

  export type ExtracurricularActivityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
  }

  export type ExtracurricularActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExtracurricularActivityWhereInput | ExtracurricularActivityWhereInput[]
    OR?: ExtracurricularActivityWhereInput[]
    NOT?: ExtracurricularActivityWhereInput | ExtracurricularActivityWhereInput[]
    name?: StringFilter<"ExtracurricularActivity"> | string
    category?: StringFilter<"ExtracurricularActivity"> | string
    description?: StringNullableFilter<"ExtracurricularActivity"> | string | null
    schedule?: StringNullableFilter<"ExtracurricularActivity"> | string | null
  }, "id">

  export type ExtracurricularActivityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    _count?: ExtracurricularActivityCountOrderByAggregateInput
    _avg?: ExtracurricularActivityAvgOrderByAggregateInput
    _max?: ExtracurricularActivityMaxOrderByAggregateInput
    _min?: ExtracurricularActivityMinOrderByAggregateInput
    _sum?: ExtracurricularActivitySumOrderByAggregateInput
  }

  export type ExtracurricularActivityScalarWhereWithAggregatesInput = {
    AND?: ExtracurricularActivityScalarWhereWithAggregatesInput | ExtracurricularActivityScalarWhereWithAggregatesInput[]
    OR?: ExtracurricularActivityScalarWhereWithAggregatesInput[]
    NOT?: ExtracurricularActivityScalarWhereWithAggregatesInput | ExtracurricularActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExtracurricularActivity"> | number
    name?: StringWithAggregatesFilter<"ExtracurricularActivity"> | string
    category?: StringWithAggregatesFilter<"ExtracurricularActivity"> | string
    description?: StringNullableWithAggregatesFilter<"ExtracurricularActivity"> | string | null
    schedule?: StringNullableWithAggregatesFilter<"ExtracurricularActivity"> | string | null
  }

  export type PtaMeetingWhereInput = {
    AND?: PtaMeetingWhereInput | PtaMeetingWhereInput[]
    OR?: PtaMeetingWhereInput[]
    NOT?: PtaMeetingWhereInput | PtaMeetingWhereInput[]
    id?: IntFilter<"PtaMeeting"> | number
    title?: StringFilter<"PtaMeeting"> | string
    date?: DateTimeFilter<"PtaMeeting"> | Date | string
    agenda?: JsonNullableFilter<"PtaMeeting">
  }

  export type PtaMeetingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    agenda?: SortOrderInput | SortOrder
  }

  export type PtaMeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PtaMeetingWhereInput | PtaMeetingWhereInput[]
    OR?: PtaMeetingWhereInput[]
    NOT?: PtaMeetingWhereInput | PtaMeetingWhereInput[]
    title?: StringFilter<"PtaMeeting"> | string
    date?: DateTimeFilter<"PtaMeeting"> | Date | string
    agenda?: JsonNullableFilter<"PtaMeeting">
  }, "id">

  export type PtaMeetingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    agenda?: SortOrderInput | SortOrder
    _count?: PtaMeetingCountOrderByAggregateInput
    _avg?: PtaMeetingAvgOrderByAggregateInput
    _max?: PtaMeetingMaxOrderByAggregateInput
    _min?: PtaMeetingMinOrderByAggregateInput
    _sum?: PtaMeetingSumOrderByAggregateInput
  }

  export type PtaMeetingScalarWhereWithAggregatesInput = {
    AND?: PtaMeetingScalarWhereWithAggregatesInput | PtaMeetingScalarWhereWithAggregatesInput[]
    OR?: PtaMeetingScalarWhereWithAggregatesInput[]
    NOT?: PtaMeetingScalarWhereWithAggregatesInput | PtaMeetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PtaMeeting"> | number
    title?: StringWithAggregatesFilter<"PtaMeeting"> | string
    date?: DateTimeWithAggregatesFilter<"PtaMeeting"> | Date | string
    agenda?: JsonNullableWithAggregatesFilter<"PtaMeeting">
  }

  export type SchoolPolicyWhereInput = {
    AND?: SchoolPolicyWhereInput | SchoolPolicyWhereInput[]
    OR?: SchoolPolicyWhereInput[]
    NOT?: SchoolPolicyWhereInput | SchoolPolicyWhereInput[]
    id?: IntFilter<"SchoolPolicy"> | number
    title?: StringFilter<"SchoolPolicy"> | string
    description?: StringNullableFilter<"SchoolPolicy"> | string | null
    url?: StringNullableFilter<"SchoolPolicy"> | string | null
  }

  export type SchoolPolicyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type SchoolPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SchoolPolicyWhereInput | SchoolPolicyWhereInput[]
    OR?: SchoolPolicyWhereInput[]
    NOT?: SchoolPolicyWhereInput | SchoolPolicyWhereInput[]
    title?: StringFilter<"SchoolPolicy"> | string
    description?: StringNullableFilter<"SchoolPolicy"> | string | null
    url?: StringNullableFilter<"SchoolPolicy"> | string | null
  }, "id">

  export type SchoolPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    _count?: SchoolPolicyCountOrderByAggregateInput
    _avg?: SchoolPolicyAvgOrderByAggregateInput
    _max?: SchoolPolicyMaxOrderByAggregateInput
    _min?: SchoolPolicyMinOrderByAggregateInput
    _sum?: SchoolPolicySumOrderByAggregateInput
  }

  export type SchoolPolicyScalarWhereWithAggregatesInput = {
    AND?: SchoolPolicyScalarWhereWithAggregatesInput | SchoolPolicyScalarWhereWithAggregatesInput[]
    OR?: SchoolPolicyScalarWhereWithAggregatesInput[]
    NOT?: SchoolPolicyScalarWhereWithAggregatesInput | SchoolPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SchoolPolicy"> | number
    title?: StringWithAggregatesFilter<"SchoolPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"SchoolPolicy"> | string | null
    url?: StringNullableWithAggregatesFilter<"SchoolPolicy"> | string | null
  }

  export type VolunteeringOpportunityWhereInput = {
    AND?: VolunteeringOpportunityWhereInput | VolunteeringOpportunityWhereInput[]
    OR?: VolunteeringOpportunityWhereInput[]
    NOT?: VolunteeringOpportunityWhereInput | VolunteeringOpportunityWhereInput[]
    id?: IntFilter<"VolunteeringOpportunity"> | number
    title?: StringFilter<"VolunteeringOpportunity"> | string
    description?: StringNullableFilter<"VolunteeringOpportunity"> | string | null
    date?: DateTimeNullableFilter<"VolunteeringOpportunity"> | Date | string | null
    spotsTotal?: IntNullableFilter<"VolunteeringOpportunity"> | number | null
    spotsFilled?: IntNullableFilter<"VolunteeringOpportunity"> | number | null
  }

  export type VolunteeringOpportunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    spotsTotal?: SortOrderInput | SortOrder
    spotsFilled?: SortOrderInput | SortOrder
  }

  export type VolunteeringOpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VolunteeringOpportunityWhereInput | VolunteeringOpportunityWhereInput[]
    OR?: VolunteeringOpportunityWhereInput[]
    NOT?: VolunteeringOpportunityWhereInput | VolunteeringOpportunityWhereInput[]
    title?: StringFilter<"VolunteeringOpportunity"> | string
    description?: StringNullableFilter<"VolunteeringOpportunity"> | string | null
    date?: DateTimeNullableFilter<"VolunteeringOpportunity"> | Date | string | null
    spotsTotal?: IntNullableFilter<"VolunteeringOpportunity"> | number | null
    spotsFilled?: IntNullableFilter<"VolunteeringOpportunity"> | number | null
  }, "id">

  export type VolunteeringOpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    spotsTotal?: SortOrderInput | SortOrder
    spotsFilled?: SortOrderInput | SortOrder
    _count?: VolunteeringOpportunityCountOrderByAggregateInput
    _avg?: VolunteeringOpportunityAvgOrderByAggregateInput
    _max?: VolunteeringOpportunityMaxOrderByAggregateInput
    _min?: VolunteeringOpportunityMinOrderByAggregateInput
    _sum?: VolunteeringOpportunitySumOrderByAggregateInput
  }

  export type VolunteeringOpportunityScalarWhereWithAggregatesInput = {
    AND?: VolunteeringOpportunityScalarWhereWithAggregatesInput | VolunteeringOpportunityScalarWhereWithAggregatesInput[]
    OR?: VolunteeringOpportunityScalarWhereWithAggregatesInput[]
    NOT?: VolunteeringOpportunityScalarWhereWithAggregatesInput | VolunteeringOpportunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VolunteeringOpportunity"> | number
    title?: StringWithAggregatesFilter<"VolunteeringOpportunity"> | string
    description?: StringNullableWithAggregatesFilter<"VolunteeringOpportunity"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"VolunteeringOpportunity"> | Date | string | null
    spotsTotal?: IntNullableWithAggregatesFilter<"VolunteeringOpportunity"> | number | null
    spotsFilled?: IntNullableWithAggregatesFilter<"VolunteeringOpportunity"> | number | null
  }

  export type PermissionSlipWhereInput = {
    AND?: PermissionSlipWhereInput | PermissionSlipWhereInput[]
    OR?: PermissionSlipWhereInput[]
    NOT?: PermissionSlipWhereInput | PermissionSlipWhereInput[]
    id?: IntFilter<"PermissionSlip"> | number
    studentId?: IntNullableFilter<"PermissionSlip"> | number | null
    title?: StringFilter<"PermissionSlip"> | string
    description?: StringNullableFilter<"PermissionSlip"> | string | null
    location?: StringNullableFilter<"PermissionSlip"> | string | null
    date?: DateTimeNullableFilter<"PermissionSlip"> | Date | string | null
    status?: StringNullableFilter<"PermissionSlip"> | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type PermissionSlipOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type PermissionSlipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PermissionSlipWhereInput | PermissionSlipWhereInput[]
    OR?: PermissionSlipWhereInput[]
    NOT?: PermissionSlipWhereInput | PermissionSlipWhereInput[]
    studentId?: IntNullableFilter<"PermissionSlip"> | number | null
    title?: StringFilter<"PermissionSlip"> | string
    description?: StringNullableFilter<"PermissionSlip"> | string | null
    location?: StringNullableFilter<"PermissionSlip"> | string | null
    date?: DateTimeNullableFilter<"PermissionSlip"> | Date | string | null
    status?: StringNullableFilter<"PermissionSlip"> | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id">

  export type PermissionSlipOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: PermissionSlipCountOrderByAggregateInput
    _avg?: PermissionSlipAvgOrderByAggregateInput
    _max?: PermissionSlipMaxOrderByAggregateInput
    _min?: PermissionSlipMinOrderByAggregateInput
    _sum?: PermissionSlipSumOrderByAggregateInput
  }

  export type PermissionSlipScalarWhereWithAggregatesInput = {
    AND?: PermissionSlipScalarWhereWithAggregatesInput | PermissionSlipScalarWhereWithAggregatesInput[]
    OR?: PermissionSlipScalarWhereWithAggregatesInput[]
    NOT?: PermissionSlipScalarWhereWithAggregatesInput | PermissionSlipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PermissionSlip"> | number
    studentId?: IntNullableWithAggregatesFilter<"PermissionSlip"> | number | null
    title?: StringWithAggregatesFilter<"PermissionSlip"> | string
    description?: StringNullableWithAggregatesFilter<"PermissionSlip"> | string | null
    location?: StringNullableWithAggregatesFilter<"PermissionSlip"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"PermissionSlip"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"PermissionSlip"> | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    teacherId?: IntNullableFilter<"Appointment"> | number | null
    parentId?: IntNullableFilter<"Appointment"> | number | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    status?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    teacherId?: IntNullableFilter<"Appointment"> | number | null
    parentId?: IntNullableFilter<"Appointment"> | number | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    status?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    teacherId?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    parentId?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    date?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    time?: StringWithAggregatesFilter<"Appointment"> | string
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    status?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type PdResourceWhereInput = {
    AND?: PdResourceWhereInput | PdResourceWhereInput[]
    OR?: PdResourceWhereInput[]
    NOT?: PdResourceWhereInput | PdResourceWhereInput[]
    id?: IntFilter<"PdResource"> | number
    title?: StringFilter<"PdResource"> | string
    type?: StringFilter<"PdResource"> | string
    source?: StringNullableFilter<"PdResource"> | string | null
    summary?: StringNullableFilter<"PdResource"> | string | null
    url?: StringNullableFilter<"PdResource"> | string | null
  }

  export type PdResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    source?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
  }

  export type PdResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PdResourceWhereInput | PdResourceWhereInput[]
    OR?: PdResourceWhereInput[]
    NOT?: PdResourceWhereInput | PdResourceWhereInput[]
    title?: StringFilter<"PdResource"> | string
    type?: StringFilter<"PdResource"> | string
    source?: StringNullableFilter<"PdResource"> | string | null
    summary?: StringNullableFilter<"PdResource"> | string | null
    url?: StringNullableFilter<"PdResource"> | string | null
  }, "id">

  export type PdResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    source?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    _count?: PdResourceCountOrderByAggregateInput
    _avg?: PdResourceAvgOrderByAggregateInput
    _max?: PdResourceMaxOrderByAggregateInput
    _min?: PdResourceMinOrderByAggregateInput
    _sum?: PdResourceSumOrderByAggregateInput
  }

  export type PdResourceScalarWhereWithAggregatesInput = {
    AND?: PdResourceScalarWhereWithAggregatesInput | PdResourceScalarWhereWithAggregatesInput[]
    OR?: PdResourceScalarWhereWithAggregatesInput[]
    NOT?: PdResourceScalarWhereWithAggregatesInput | PdResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PdResource"> | number
    title?: StringWithAggregatesFilter<"PdResource"> | string
    type?: StringWithAggregatesFilter<"PdResource"> | string
    source?: StringNullableWithAggregatesFilter<"PdResource"> | string | null
    summary?: StringNullableWithAggregatesFilter<"PdResource"> | string | null
    url?: StringNullableWithAggregatesFilter<"PdResource"> | string | null
  }

  export type AiGameWhereInput = {
    AND?: AiGameWhereInput | AiGameWhereInput[]
    OR?: AiGameWhereInput[]
    NOT?: AiGameWhereInput | AiGameWhereInput[]
    id?: UuidFilter<"AiGame"> | string
    creatorId?: IntNullableFilter<"AiGame"> | number | null
    title?: StringFilter<"AiGame"> | string
    subject?: StringNullableFilter<"AiGame"> | string | null
    difficultyLevel?: StringNullableFilter<"AiGame"> | string | null
    status?: StringNullableFilter<"AiGame"> | string | null
    questions?: JsonNullableFilter<"AiGame">
    creator?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }

  export type AiGameOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    subject?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    questions?: SortOrderInput | SortOrder
    creator?: TeacherOrderByWithRelationInput
  }

  export type AiGameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiGameWhereInput | AiGameWhereInput[]
    OR?: AiGameWhereInput[]
    NOT?: AiGameWhereInput | AiGameWhereInput[]
    creatorId?: IntNullableFilter<"AiGame"> | number | null
    title?: StringFilter<"AiGame"> | string
    subject?: StringNullableFilter<"AiGame"> | string | null
    difficultyLevel?: StringNullableFilter<"AiGame"> | string | null
    status?: StringNullableFilter<"AiGame"> | string | null
    questions?: JsonNullableFilter<"AiGame">
    creator?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type AiGameOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    subject?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    questions?: SortOrderInput | SortOrder
    _count?: AiGameCountOrderByAggregateInput
    _avg?: AiGameAvgOrderByAggregateInput
    _max?: AiGameMaxOrderByAggregateInput
    _min?: AiGameMinOrderByAggregateInput
    _sum?: AiGameSumOrderByAggregateInput
  }

  export type AiGameScalarWhereWithAggregatesInput = {
    AND?: AiGameScalarWhereWithAggregatesInput | AiGameScalarWhereWithAggregatesInput[]
    OR?: AiGameScalarWhereWithAggregatesInput[]
    NOT?: AiGameScalarWhereWithAggregatesInput | AiGameScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AiGame"> | string
    creatorId?: IntNullableWithAggregatesFilter<"AiGame"> | number | null
    title?: StringWithAggregatesFilter<"AiGame"> | string
    subject?: StringNullableWithAggregatesFilter<"AiGame"> | string | null
    difficultyLevel?: StringNullableWithAggregatesFilter<"AiGame"> | string | null
    status?: StringNullableWithAggregatesFilter<"AiGame"> | string | null
    questions?: JsonNullableWithAggregatesFilter<"AiGame">
  }

  export type LessonPlanWhereInput = {
    AND?: LessonPlanWhereInput | LessonPlanWhereInput[]
    OR?: LessonPlanWhereInput[]
    NOT?: LessonPlanWhereInput | LessonPlanWhereInput[]
    id?: IntFilter<"LessonPlan"> | number
    teacherId?: IntNullableFilter<"LessonPlan"> | number | null
    subject?: StringNullableFilter<"LessonPlan"> | string | null
    grade?: StringNullableFilter<"LessonPlan"> | string | null
    topic?: StringNullableFilter<"LessonPlan"> | string | null
    content?: JsonNullableFilter<"LessonPlan">
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }

  export type LessonPlanOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type LessonPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LessonPlanWhereInput | LessonPlanWhereInput[]
    OR?: LessonPlanWhereInput[]
    NOT?: LessonPlanWhereInput | LessonPlanWhereInput[]
    teacherId?: IntNullableFilter<"LessonPlan"> | number | null
    subject?: StringNullableFilter<"LessonPlan"> | string | null
    grade?: StringNullableFilter<"LessonPlan"> | string | null
    topic?: StringNullableFilter<"LessonPlan"> | string | null
    content?: JsonNullableFilter<"LessonPlan">
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type LessonPlanOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LessonPlanCountOrderByAggregateInput
    _avg?: LessonPlanAvgOrderByAggregateInput
    _max?: LessonPlanMaxOrderByAggregateInput
    _min?: LessonPlanMinOrderByAggregateInput
    _sum?: LessonPlanSumOrderByAggregateInput
  }

  export type LessonPlanScalarWhereWithAggregatesInput = {
    AND?: LessonPlanScalarWhereWithAggregatesInput | LessonPlanScalarWhereWithAggregatesInput[]
    OR?: LessonPlanScalarWhereWithAggregatesInput[]
    NOT?: LessonPlanScalarWhereWithAggregatesInput | LessonPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LessonPlan"> | number
    teacherId?: IntNullableWithAggregatesFilter<"LessonPlan"> | number | null
    subject?: StringNullableWithAggregatesFilter<"LessonPlan"> | string | null
    grade?: StringNullableWithAggregatesFilter<"LessonPlan"> | string | null
    topic?: StringNullableWithAggregatesFilter<"LessonPlan"> | string | null
    content?: JsonNullableWithAggregatesFilter<"LessonPlan">
    createdAt?: DateTimeWithAggregatesFilter<"LessonPlan"> | Date | string
  }

  export type GeneratedResourceWhereInput = {
    AND?: GeneratedResourceWhereInput | GeneratedResourceWhereInput[]
    OR?: GeneratedResourceWhereInput[]
    NOT?: GeneratedResourceWhereInput | GeneratedResourceWhereInput[]
    id?: IntFilter<"GeneratedResource"> | number
    teacherId?: IntNullableFilter<"GeneratedResource"> | number | null
    subject?: StringNullableFilter<"GeneratedResource"> | string | null
    className?: StringNullableFilter<"GeneratedResource"> | string | null
    term?: StringNullableFilter<"GeneratedResource"> | string | null
    schemeContent?: JsonNullableFilter<"GeneratedResource">
    lessonPlansContent?: JsonNullableFilter<"GeneratedResource">
    updatedAt?: DateTimeFilter<"GeneratedResource"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }

  export type GeneratedResourceOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    schemeContent?: SortOrderInput | SortOrder
    lessonPlansContent?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
  }

  export type GeneratedResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GeneratedResourceWhereInput | GeneratedResourceWhereInput[]
    OR?: GeneratedResourceWhereInput[]
    NOT?: GeneratedResourceWhereInput | GeneratedResourceWhereInput[]
    teacherId?: IntNullableFilter<"GeneratedResource"> | number | null
    subject?: StringNullableFilter<"GeneratedResource"> | string | null
    className?: StringNullableFilter<"GeneratedResource"> | string | null
    term?: StringNullableFilter<"GeneratedResource"> | string | null
    schemeContent?: JsonNullableFilter<"GeneratedResource">
    lessonPlansContent?: JsonNullableFilter<"GeneratedResource">
    updatedAt?: DateTimeFilter<"GeneratedResource"> | Date | string
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
  }, "id">

  export type GeneratedResourceOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    className?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    schemeContent?: SortOrderInput | SortOrder
    lessonPlansContent?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: GeneratedResourceCountOrderByAggregateInput
    _avg?: GeneratedResourceAvgOrderByAggregateInput
    _max?: GeneratedResourceMaxOrderByAggregateInput
    _min?: GeneratedResourceMinOrderByAggregateInput
    _sum?: GeneratedResourceSumOrderByAggregateInput
  }

  export type GeneratedResourceScalarWhereWithAggregatesInput = {
    AND?: GeneratedResourceScalarWhereWithAggregatesInput | GeneratedResourceScalarWhereWithAggregatesInput[]
    OR?: GeneratedResourceScalarWhereWithAggregatesInput[]
    NOT?: GeneratedResourceScalarWhereWithAggregatesInput | GeneratedResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GeneratedResource"> | number
    teacherId?: IntNullableWithAggregatesFilter<"GeneratedResource"> | number | null
    subject?: StringNullableWithAggregatesFilter<"GeneratedResource"> | string | null
    className?: StringNullableWithAggregatesFilter<"GeneratedResource"> | string | null
    term?: StringNullableWithAggregatesFilter<"GeneratedResource"> | string | null
    schemeContent?: JsonNullableWithAggregatesFilter<"GeneratedResource">
    lessonPlansContent?: JsonNullableWithAggregatesFilter<"GeneratedResource">
    updatedAt?: DateTimeWithAggregatesFilter<"GeneratedResource"> | Date | string
  }

  export type ReportCardWhereInput = {
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    id?: IntFilter<"ReportCard"> | number
    studentId?: IntNullableFilter<"ReportCard"> | number | null
    session?: StringFilter<"ReportCard"> | string
    term?: StringFilter<"ReportCard"> | string
    status?: StringNullableFilter<"ReportCard"> | string | null
    classTeacherComment?: StringNullableFilter<"ReportCard"> | string | null
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    gradeAverage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    position?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercentage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullableFilter<"ReportCard">
    psychomotor?: JsonNullableFilter<"ReportCard">
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    publishedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type ReportCardOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    session?: SortOrder
    term?: SortOrder
    status?: SortOrderInput | SortOrder
    classTeacherComment?: SortOrderInput | SortOrder
    principalComment?: SortOrderInput | SortOrder
    gradeAverage?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    totalStudents?: SortOrderInput | SortOrder
    attendancePercentage?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    psychomotor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type ReportCardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    studentId?: IntNullableFilter<"ReportCard"> | number | null
    session?: StringFilter<"ReportCard"> | string
    term?: StringFilter<"ReportCard"> | string
    status?: StringNullableFilter<"ReportCard"> | string | null
    classTeacherComment?: StringNullableFilter<"ReportCard"> | string | null
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    gradeAverage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    position?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercentage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullableFilter<"ReportCard">
    psychomotor?: JsonNullableFilter<"ReportCard">
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    publishedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "id">

  export type ReportCardOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrderInput | SortOrder
    session?: SortOrder
    term?: SortOrder
    status?: SortOrderInput | SortOrder
    classTeacherComment?: SortOrderInput | SortOrder
    principalComment?: SortOrderInput | SortOrder
    gradeAverage?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    totalStudents?: SortOrderInput | SortOrder
    attendancePercentage?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    psychomotor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: ReportCardCountOrderByAggregateInput
    _avg?: ReportCardAvgOrderByAggregateInput
    _max?: ReportCardMaxOrderByAggregateInput
    _min?: ReportCardMinOrderByAggregateInput
    _sum?: ReportCardSumOrderByAggregateInput
  }

  export type ReportCardScalarWhereWithAggregatesInput = {
    AND?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    OR?: ReportCardScalarWhereWithAggregatesInput[]
    NOT?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReportCard"> | number
    studentId?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    session?: StringWithAggregatesFilter<"ReportCard"> | string
    term?: StringWithAggregatesFilter<"ReportCard"> | string
    status?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    classTeacherComment?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    principalComment?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    gradeAverage?: DecimalNullableWithAggregatesFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    position?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    attendancePercentage?: DecimalNullableWithAggregatesFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullableWithAggregatesFilter<"ReportCard">
    psychomotor?: JsonNullableWithAggregatesFilter<"ReportCard">
    createdAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ReportCard"> | Date | string | null
  }

  export type UserCreateInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutParentProfileInput
    children?: ParentChildCreateNestedManyWithoutParentInput
    appointments?: AppointmentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: number
    userId?: number | null
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ParentChildUncheckedCreateNestedManyWithoutParentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentProfileNestedInput
    children?: ParentChildUpdateManyWithoutParentNestedInput
    appointments?: AppointmentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ParentChildUncheckedUpdateManyWithoutParentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: number
    userId?: number | null
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentChildCreateInput = {
    parent: ParentCreateNestedOneWithoutChildrenInput
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type ParentChildUncheckedCreateInput = {
    id?: number
    parentId: number
    studentId: number
  }

  export type ParentChildUpdateInput = {
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type ParentChildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentChildCreateManyInput = {
    id?: number
    parentId: number
    studentId: number
  }

  export type ParentChildUpdateManyMutationInput = {

  }

  export type ParentChildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassCreateInput = {
    id: string
    subject: string
    grade: number
    section: string
    department?: string | null
    studentCount?: number | null
    createdAt?: Date | string
  }

  export type ClassUncheckedCreateInput = {
    id: string
    subject: string
    grade: number
    section: string
    department?: string | null
    studentCount?: number | null
    createdAt?: Date | string
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    studentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    studentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManyInput = {
    id: string
    subject: string
    grade: number
    section: string
    department?: string | null
    studentCount?: number | null
    createdAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    studentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    studentCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherSubjectCreateInput = {
    subject: string
    teacher: TeacherCreateNestedOneWithoutSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateInput = {
    id?: number
    teacherId: number
    subject: string
  }

  export type TeacherSubjectUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    teacher?: TeacherUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManyInput = {
    id?: number
    teacherId: number
    subject: string
  }

  export type TeacherSubjectUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassCreateInput = {
    className: string
    teacher: TeacherCreateNestedOneWithoutClassesInput
  }

  export type TeacherClassUncheckedCreateInput = {
    id?: number
    teacherId: number
    className: string
  }

  export type TeacherClassUpdateInput = {
    className?: StringFieldUpdateOperationsInput | string
    teacher?: TeacherUpdateOneRequiredWithoutClassesNestedInput
  }

  export type TeacherClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassCreateManyInput = {
    id?: number
    teacherId: number
    className: string
  }

  export type TeacherClassUpdateManyMutationInput = {
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TimetableCreateInput = {
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutTimetableEntriesInput
  }

  export type TimetableUncheckedCreateInput = {
    id?: number
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    teacherId?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutTimetableEntriesNestedInput
  }

  export type TimetableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateManyInput = {
    id?: number
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    teacherId?: number | null
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateInput = {
    date: Date | string
    status: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type StudentAttendanceUncheckedCreateInput = {
    id?: number
    studentId: number
    date: Date | string
    status: string
    createdAt?: Date | string
  }

  export type StudentAttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type StudentAttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceCreateManyInput = {
    id?: number
    studentId: number
    date: Date | string
    status: string
    createdAt?: Date | string
  }

  export type StudentAttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPerformanceCreateInput = {
    subject: string
    score?: number | null
    term: string
    session?: string | null
    student: StudentCreateNestedOneWithoutAcademicPerformanceInput
  }

  export type AcademicPerformanceUncheckedCreateInput = {
    id?: number
    studentId: number
    subject: string
    score?: number | null
    term: string
    session?: string | null
  }

  export type AcademicPerformanceUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutAcademicPerformanceNestedInput
  }

  export type AcademicPerformanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicPerformanceCreateManyInput = {
    id?: number
    studentId: number
    subject: string
    score?: number | null
    term: string
    session?: string | null
  }

  export type AcademicPerformanceUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicPerformanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehaviorRecordCreateInput = {
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
    student: StudentCreateNestedOneWithoutBehaviorRecordsInput
  }

  export type BehaviorRecordUncheckedCreateInput = {
    id?: number
    studentId: number
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
  }

  export type BehaviorRecordUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutBehaviorRecordsNestedInput
  }

  export type BehaviorRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordCreateManyInput = {
    id?: number
    studentId: number
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
  }

  export type BehaviorRecordUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
    student: StudentCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: number
    studentId: number
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
  }

  export type BadgeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyInput = {
    id?: number
    studentId: number
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
    student: StudentCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: number
    studentId: number
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
  }

  export type CertificateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificateCreateManyInput = {
    id?: number
    studentId: number
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
  }

  export type CertificateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardCreateInput = {
    name: string
    description?: string | null
    date?: Date | string | null
    student: StudentCreateNestedOneWithoutAwardsInput
  }

  export type AwardUncheckedCreateInput = {
    id?: number
    studentId: number
    name: string
    description?: string | null
    date?: Date | string | null
  }

  export type AwardUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutAwardsNestedInput
  }

  export type AwardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardCreateManyInput = {
    id?: number
    studentId: number
    name: string
    description?: string | null
    date?: Date | string | null
  }

  export type AwardUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssignmentCreateInput = {
    title: string
    description?: string | null
    className: string
    subject: string
    dueDate: Date | string
    totalStudents?: number | null
    submissionsCount?: number | null
    createdAt?: Date | string
    submissions?: SubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    className: string
    subject: string
    dueDate: Date | string
    totalStudents?: number | null
    submissionsCount?: number | null
    createdAt?: Date | string
    submissions?: SubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    className: string
    subject: string
    dueDate: Date | string
    totalStudents?: number | null
    submissionsCount?: number | null
    createdAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateInput = {
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    student: StudentCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateInput = {
    id?: number
    assignmentId: number
    studentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type SubmissionUpdateInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: StudentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubmissionCreateManyInput = {
    id?: number
    assignmentId: number
    studentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type SubmissionUpdateManyMutationInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamCreateInput = {
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
    teacher?: TeacherCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: number
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
    teacherId?: number | null
  }

  export type ExamUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    teacher?: TeacherUpdateOneWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExamCreateManyInput = {
    id?: number
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
    teacherId?: number | null
  }

  export type ExamUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    timestamp?: Date | string
    category: string
    isPinned?: boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    timestamp?: Date | string
    category: string
    isPinned?: boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    timestamp?: Date | string
    category: string
    isPinned?: boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: StringFieldUpdateOperationsInput | string
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    audience?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    relatedId?: number | null
    user?: UserCreateNestedOneWithoutNotificationsInput
    student?: StudentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    studentId?: number | null
    relatedId?: number | null
  }

  export type NotificationUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutNotificationsNestedInput
    student?: StudentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId?: number | null
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    studentId?: number | null
    relatedId?: number | null
  }

  export type NotificationUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConversationCreateInput = {
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    messages?: MessageCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: number
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: number
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
  }

  export type ConversationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationParticipantCreateInput = {
    role?: string | null
    joinedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutConversationsParticipatedInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    conversationId: number
    userId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type ConversationParticipantUpdateInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsParticipatedNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantCreateManyInput = {
    conversationId: number
    userId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender?: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    conversationId: number
    senderId?: number | null
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type MessageUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageCreateManyInput = {
    id?: number
    conversationId: number
    senderId?: number | null
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type MessageUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ForumTopicCreateInput = {
    title: string
    authorName: string
    createdAt?: Date | string
    postCount?: number | null
    lastActivity?: Date | string
    posts?: ForumPostCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUncheckedCreateInput = {
    id?: number
    title: string
    authorName: string
    createdAt?: Date | string
    postCount?: number | null
    lastActivity?: Date | string
    posts?: ForumPostUncheckedCreateNestedManyWithoutTopicInput
  }

  export type ForumTopicUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: ForumPostUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ForumTopicCreateManyInput = {
    id?: number
    title: string
    authorName: string
    createdAt?: Date | string
    postCount?: number | null
    lastActivity?: Date | string
  }

  export type ForumTopicUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateInput = {
    authorName: string
    content: string
    timestamp?: Date | string
    topic: ForumTopicCreateNestedOneWithoutPostsInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: number
    topicId: number
    authorName: string
    content: string
    timestamp?: Date | string
  }

  export type ForumPostUpdateInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: ForumTopicUpdateOneRequiredWithoutPostsNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateManyInput = {
    id?: number
    topicId: number
    authorName: string
    content: string
    timestamp?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    id?: string
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: string
    userId?: number | null
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ComplaintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateManyInput = {
    id?: string
    userId?: number | null
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    name: string
    phone?: string | null
    avatarUrl?: string | null
    roster?: BusRosterCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    avatarUrl?: string | null
    roster?: BusRosterUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    avatarUrl?: string | null
  }

  export type DriverUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusRouteCreateInput = {
    id: string
    name: string
    description?: string | null
    roster?: BusRosterCreateNestedManyWithoutRouteInput
    pickupPoints?: PickupPointCreateNestedManyWithoutRouteInput
  }

  export type BusRouteUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    roster?: BusRosterUncheckedCreateNestedManyWithoutRouteInput
    pickupPoints?: PickupPointUncheckedCreateNestedManyWithoutRouteInput
  }

  export type BusRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUpdateManyWithoutRouteNestedInput
    pickupPoints?: PickupPointUpdateManyWithoutRouteNestedInput
  }

  export type BusRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUncheckedUpdateManyWithoutRouteNestedInput
    pickupPoints?: PickupPointUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type BusRouteCreateManyInput = {
    id: string
    name: string
    description?: string | null
  }

  export type BusRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusRosterCreateInput = {
    date: Date | string
    route?: BusRouteCreateNestedOneWithoutRosterInput
    driver?: DriverCreateNestedOneWithoutRosterInput
  }

  export type BusRosterUncheckedCreateInput = {
    id?: number
    routeId?: string | null
    driverId?: number | null
    date: Date | string
  }

  export type BusRosterUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: BusRouteUpdateOneWithoutRosterNestedInput
    driver?: DriverUpdateOneWithoutRosterNestedInput
  }

  export type BusRosterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterCreateManyInput = {
    id?: number
    routeId?: string | null
    driverId?: number | null
    date: Date | string
  }

  export type BusRosterUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupPointCreateInput = {
    name: string
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
    route?: BusRouteCreateNestedOneWithoutPickupPointsInput
  }

  export type PickupPointUncheckedCreateInput = {
    id?: number
    name: string
    routeId?: string | null
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
  }

  export type PickupPointUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
    route?: BusRouteUpdateOneWithoutPickupPointsNestedInput
  }

  export type PickupPointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PickupPointCreateManyInput = {
    id?: number
    name: string
    routeId?: string | null
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
  }

  export type PickupPointUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PickupPointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentFeeCreateInput = {
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
    student: StudentCreateNestedOneWithoutFeesInput
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type StudentFeeUncheckedCreateInput = {
    id?: number
    studentId: number
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type StudentFeeUpdateInput = {
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutFeesNestedInput
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type StudentFeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type StudentFeeCreateManyInput = {
    id?: number
    studentId: number
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
  }

  export type StudentFeeUpdateManyMutationInput = {
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentFeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeePaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
    fee: StudentFeeCreateNestedOneWithoutPaymentsInput
  }

  export type FeePaymentUncheckedCreateInput = {
    id?: number
    feeId: number
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
  }

  export type FeePaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: StudentFeeUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type FeePaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeePaymentCreateManyInput = {
    id?: number
    feeId: number
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
  }

  export type FeePaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeePaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feeId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreProductCreateInput = {
    name: string
    category: string
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    stock?: number | null
  }

  export type StoreProductUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    stock?: number | null
  }

  export type StoreProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreProductCreateManyInput = {
    id?: number
    name: string
    category: string
    price: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    stock?: number | null
  }

  export type StoreProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreOrderCreateInput = {
    id: string
    customerName: string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string | null
    orderDate?: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderUncheckedCreateInput = {
    id: string
    customerName: string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string | null
    orderDate?: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderCreateManyInput = {
    id: string
    customerName: string
    totalAmount: Decimal | DecimalJsLike | number | string
    status?: string | null
    orderDate?: Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StoreOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AuditLogCreateInput = {
    userName?: string | null
    userRole?: string | null
    action: string
    type: string
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    userName?: string | null
    userRole?: string | null
    action: string
    type: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    userName?: string | null
    userRole?: string | null
    action: string
    type: string
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userRole?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthLogCreateInput = {
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
    student?: StudentCreateNestedOneWithoutHealthLogsInput
  }

  export type HealthLogUncheckedCreateInput = {
    id?: number
    studentId?: number | null
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
  }

  export type HealthLogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutHealthLogsNestedInput
  }

  export type HealthLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HealthLogCreateManyInput = {
    id?: number
    studentId?: number | null
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
  }

  export type HealthLogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HealthLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCreateInput = {
    title: string
    author: string
    coverUrl?: string | null
    category: string
    status?: string | null
  }

  export type BookUncheckedCreateInput = {
    id?: number
    title: string
    author: string
    coverUrl?: string | null
    category: string
    status?: string | null
  }

  export type BookUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCreateManyInput = {
    id?: number
    title: string
    author: string
    coverUrl?: string | null
    category: string
    status?: string | null
  }

  export type BookUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: StringFieldUpdateOperationsInput | string
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DigitalResourceCreateInput = {
    title: string
    type: string
    subject?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
  }

  export type DigitalResourceUncheckedCreateInput = {
    id?: number
    title: string
    type: string
    subject?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
  }

  export type DigitalResourceUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DigitalResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DigitalResourceCreateManyInput = {
    id?: number
    title: string
    type: string
    subject?: string | null
    description?: string | null
    url: string
    thumbnailUrl?: string | null
  }

  export type DigitalResourceUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DigitalResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CbtTestCreateInput = {
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    questions?: CbtQuestionCreateNestedManyWithoutTestInput
    results?: CbtResultCreateNestedManyWithoutTestInput
  }

  export type CbtTestUncheckedCreateInput = {
    id?: number
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    questions?: CbtQuestionUncheckedCreateNestedManyWithoutTestInput
    results?: CbtResultUncheckedCreateNestedManyWithoutTestInput
  }

  export type CbtTestUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: CbtQuestionUpdateManyWithoutTestNestedInput
    results?: CbtResultUpdateManyWithoutTestNestedInput
  }

  export type CbtTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: CbtQuestionUncheckedUpdateManyWithoutTestNestedInput
    results?: CbtResultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type CbtTestCreateManyInput = {
    id?: number
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
  }

  export type CbtTestUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtQuestionCreateInput = {
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    test: CbtTestCreateNestedOneWithoutQuestionsInput
  }

  export type CbtQuestionUncheckedCreateInput = {
    id?: number
    testId: number
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
  }

  export type CbtQuestionUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    test?: CbtTestUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type CbtQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtQuestionCreateManyInput = {
    id?: number
    testId: number
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
  }

  export type CbtQuestionUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtResultCreateInput = {
    score: number
    totalQuestions: number
    submittedAt?: Date | string
    test: CbtTestCreateNestedOneWithoutResultsInput
    student: StudentCreateNestedOneWithoutCbtResultsInput
  }

  export type CbtResultUncheckedCreateInput = {
    id?: number
    testId: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type CbtResultUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: CbtTestUpdateOneRequiredWithoutResultsNestedInput
    student?: StudentUpdateOneRequiredWithoutCbtResultsNestedInput
  }

  export type CbtResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtResultCreateManyInput = {
    id?: number
    testId: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type CbtResultUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarEventCreateInput = {
    title: string
    startDate: Date | string
    endDate?: Date | string | null
    type?: string | null
    description?: string | null
  }

  export type CalendarEventUncheckedCreateInput = {
    id?: number
    title: string
    startDate: Date | string
    endDate?: Date | string | null
    type?: string | null
    description?: string | null
  }

  export type CalendarEventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventCreateManyInput = {
    id?: number
    title: string
    startDate: Date | string
    endDate?: Date | string | null
    type?: string | null
    description?: string | null
  }

  export type CalendarEventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExtracurricularActivityCreateInput = {
    name: string
    category: string
    description?: string | null
    schedule?: string | null
  }

  export type ExtracurricularActivityUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    schedule?: string | null
  }

  export type ExtracurricularActivityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExtracurricularActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExtracurricularActivityCreateManyInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    schedule?: string | null
  }

  export type ExtracurricularActivityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExtracurricularActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PtaMeetingCreateInput = {
    title: string
    date: Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingUncheckedCreateInput = {
    id?: number
    title: string
    date: Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingCreateManyInput = {
    id?: number
    title: string
    date: Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PtaMeetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    agenda?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SchoolPolicyCreateInput = {
    title: string
    description?: string | null
    url?: string | null
  }

  export type SchoolPolicyUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    url?: string | null
  }

  export type SchoolPolicyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolPolicyCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    url?: string | null
  }

  export type SchoolPolicyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VolunteeringOpportunityCreateInput = {
    title: string
    description?: string | null
    date?: Date | string | null
    spotsTotal?: number | null
    spotsFilled?: number | null
  }

  export type VolunteeringOpportunityUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date?: Date | string | null
    spotsTotal?: number | null
    spotsFilled?: number | null
  }

  export type VolunteeringOpportunityUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spotsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    spotsFilled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VolunteeringOpportunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spotsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    spotsFilled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VolunteeringOpportunityCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date?: Date | string | null
    spotsTotal?: number | null
    spotsFilled?: number | null
  }

  export type VolunteeringOpportunityUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spotsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    spotsFilled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VolunteeringOpportunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    spotsTotal?: NullableIntFieldUpdateOperationsInput | number | null
    spotsFilled?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PermissionSlipCreateInput = {
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
    student?: StudentCreateNestedOneWithoutPermissionSlipsInput
  }

  export type PermissionSlipUncheckedCreateInput = {
    id?: number
    studentId?: number | null
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
  }

  export type PermissionSlipUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneWithoutPermissionSlipsNestedInput
  }

  export type PermissionSlipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionSlipCreateManyInput = {
    id?: number
    studentId?: number | null
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
  }

  export type PermissionSlipUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionSlipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateInput = {
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutAppointmentsInput
    parent?: ParentCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    teacherId?: number | null
    parentId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutAppointmentsNestedInput
    parent?: ParentUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: number
    teacherId?: number | null
    parentId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdResourceCreateInput = {
    title: string
    type: string
    source?: string | null
    summary?: string | null
    url?: string | null
  }

  export type PdResourceUncheckedCreateInput = {
    id?: number
    title: string
    type: string
    source?: string | null
    summary?: string | null
    url?: string | null
  }

  export type PdResourceUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PdResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PdResourceCreateManyInput = {
    id?: number
    title: string
    type: string
    source?: string | null
    summary?: string | null
    url?: string | null
  }

  export type PdResourceUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PdResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AiGameCreateInput = {
    id?: string
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
    creator?: TeacherCreateNestedOneWithoutCreatedAiGamesInput
  }

  export type AiGameUncheckedCreateInput = {
    id?: string
    creatorId?: number | null
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
    creator?: TeacherUpdateOneWithoutCreatedAiGamesNestedInput
  }

  export type AiGameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameCreateManyInput = {
    id?: string
    creatorId?: number | null
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonPlanCreateInput = {
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutLessonPlansInput
  }

  export type LessonPlanUncheckedCreateInput = {
    id?: number
    teacherId?: number | null
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LessonPlanUpdateInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutLessonPlansNestedInput
  }

  export type LessonPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanCreateManyInput = {
    id?: number
    teacherId?: number | null
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LessonPlanUpdateManyMutationInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceCreateInput = {
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutGeneratedResourcesInput
  }

  export type GeneratedResourceUncheckedCreateInput = {
    id?: number
    teacherId?: number | null
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type GeneratedResourceUpdateInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutGeneratedResourcesNestedInput
  }

  export type GeneratedResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceCreateManyInput = {
    id?: number
    teacherId?: number | null
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type GeneratedResourceUpdateManyMutationInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardCreateInput = {
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    student?: StudentCreateNestedOneWithoutReportCardsInput
  }

  export type ReportCardUncheckedCreateInput = {
    id?: number
    studentId?: number | null
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ReportCardUpdateInput = {
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneWithoutReportCardsNestedInput
  }

  export type ReportCardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCardCreateManyInput = {
    id?: number
    studentId?: number | null
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ReportCardUpdateManyMutationInput = {
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherNullableRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type ParentNullableRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    supabaseUid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    supabaseUid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    supabaseUid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ParentChildListRelationFilter = {
    every?: ParentChildWhereInput
    some?: ParentChildWhereInput
    none?: ParentChildWhereInput
  }

  export type StudentAttendanceListRelationFilter = {
    every?: StudentAttendanceWhereInput
    some?: StudentAttendanceWhereInput
    none?: StudentAttendanceWhereInput
  }

  export type AcademicPerformanceListRelationFilter = {
    every?: AcademicPerformanceWhereInput
    some?: AcademicPerformanceWhereInput
    none?: AcademicPerformanceWhereInput
  }

  export type BehaviorRecordListRelationFilter = {
    every?: BehaviorRecordWhereInput
    some?: BehaviorRecordWhereInput
    none?: BehaviorRecordWhereInput
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type AwardListRelationFilter = {
    every?: AwardWhereInput
    some?: AwardWhereInput
    none?: AwardWhereInput
  }

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput
    some?: SubmissionWhereInput
    none?: SubmissionWhereInput
  }

  export type StudentFeeListRelationFilter = {
    every?: StudentFeeWhereInput
    some?: StudentFeeWhereInput
    none?: StudentFeeWhereInput
  }

  export type CbtResultListRelationFilter = {
    every?: CbtResultWhereInput
    some?: CbtResultWhereInput
    none?: CbtResultWhereInput
  }

  export type PermissionSlipListRelationFilter = {
    every?: PermissionSlipWhereInput
    some?: PermissionSlipWhereInput
    none?: PermissionSlipWhereInput
  }

  export type ReportCardListRelationFilter = {
    every?: ReportCardWhereInput
    some?: ReportCardWhereInput
    none?: ReportCardWhereInput
  }

  export type HealthLogListRelationFilter = {
    every?: HealthLogWhereInput
    some?: HealthLogWhereInput
    none?: HealthLogWhereInput
  }

  export type ParentChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicPerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehaviorRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AwardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CbtResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionSlipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    attendanceStatus?: SortOrder
    birthday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    grade?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    attendanceStatus?: SortOrder
    birthday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    attendanceStatus?: SortOrder
    birthday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    grade?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TeacherSubjectListRelationFilter = {
    every?: TeacherSubjectWhereInput
    some?: TeacherSubjectWhereInput
    none?: TeacherSubjectWhereInput
  }

  export type TeacherClassListRelationFilter = {
    every?: TeacherClassWhereInput
    some?: TeacherClassWhereInput
    none?: TeacherClassWhereInput
  }

  export type TimetableListRelationFilter = {
    every?: TimetableWhereInput
    some?: TimetableWhereInput
    none?: TimetableWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type AiGameListRelationFilter = {
    every?: AiGameWhereInput
    some?: AiGameWhereInput
    none?: AiGameWhereInput
  }

  export type LessonPlanListRelationFilter = {
    every?: LessonPlanWhereInput
    some?: LessonPlanWhereInput
    none?: LessonPlanWhereInput
  }

  export type GeneratedResourceListRelationFilter = {
    every?: GeneratedResourceWhereInput
    some?: GeneratedResourceWhereInput
    none?: GeneratedResourceWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type TeacherSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimetableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiGameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TeacherAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TeacherSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ParentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ParentRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentChildParentIdStudentIdCompoundUniqueInput = {
    parentId: number
    studentId: number
  }

  export type ParentChildCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
  }

  export type ParentChildAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
  }

  export type ParentChildMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
  }

  export type ParentChildMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
  }

  export type ParentChildSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    studentId?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    studentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    grade?: SortOrder
    studentCount?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    studentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    department?: SortOrder
    studentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    grade?: SortOrder
    studentCount?: SortOrder
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type TeacherSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
  }

  export type TeacherSubjectAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type TeacherSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
  }

  export type TeacherSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
  }

  export type TeacherSubjectSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type TeacherClassCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    className?: SortOrder
  }

  export type TeacherClassAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type TeacherClassMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    className?: SortOrder
  }

  export type TeacherClassMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    className?: SortOrder
  }

  export type TeacherClassSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type TimetableCountOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    teacherId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type TimetableMaxOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    teacherId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableMinOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    teacherId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type StudentAttendanceStudentIdDateCompoundUniqueInput = {
    studentId: number
    date: Date | string
  }

  export type StudentAttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentAttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type StudentAttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentAttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentAttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type AcademicPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    score?: SortOrder
    term?: SortOrder
    session?: SortOrder
  }

  export type AcademicPerformanceAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
  }

  export type AcademicPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    score?: SortOrder
    term?: SortOrder
    session?: SortOrder
  }

  export type AcademicPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    score?: SortOrder
    term?: SortOrder
    session?: SortOrder
  }

  export type AcademicPerformanceSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
  }

  export type BehaviorRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    timestamp?: SortOrder
  }

  export type BehaviorRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type BehaviorRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    timestamp?: SortOrder
  }

  export type BehaviorRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    timestamp?: SortOrder
  }

  export type BehaviorRecordSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    awardedAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    awardedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    color?: SortOrder
    awardedAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    fileUrl?: SortOrder
    issuedDate?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    fileUrl?: SortOrder
    issuedDate?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    fileUrl?: SortOrder
    issuedDate?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type AwardCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type AwardAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type AwardMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type AwardMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    date?: SortOrder
  }

  export type AwardSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    dueDate?: SortOrder
    totalStudents?: SortOrder
    submissionsCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    totalStudents?: SortOrder
    submissionsCount?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    dueDate?: SortOrder
    totalStudents?: SortOrder
    submissionsCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    dueDate?: SortOrder
    totalStudents?: SortOrder
    submissionsCount?: SortOrder
    createdAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    totalStudents?: SortOrder
    submissionsCount?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type AssignmentRelationFilter = {
    is?: AssignmentWhereInput
    isNot?: AssignmentWhereInput
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    isLate?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    textSubmission?: SortOrder
    fileUrl?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    grade?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    isLate?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    textSubmission?: SortOrder
    fileUrl?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    submittedAt?: SortOrder
    isLate?: SortOrder
    status?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    textSubmission?: SortOrder
    fileUrl?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    grade?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    time?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    isPublished?: SortOrder
    teacherId?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    time?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    isPublished?: SortOrder
    teacherId?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    time?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    isPublished?: SortOrder
    teacherId?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    category?: SortOrder
    isPinned?: SortOrder
    audience?: SortOrder
    createdBy?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    category?: SortOrder
    isPinned?: SortOrder
    createdBy?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    category?: SortOrder
    isPinned?: SortOrder
    createdBy?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    isRead?: SortOrder
    timestamp?: SortOrder
    studentId?: SortOrder
    relatedId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    relatedId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    isRead?: SortOrder
    timestamp?: SortOrder
    studentId?: SortOrder
    relatedId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    isRead?: SortOrder
    timestamp?: SortOrder
    studentId?: SortOrder
    relatedId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentId?: SortOrder
    relatedId?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageText?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageText?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    lastMessageAt?: SortOrder
    lastMessageText?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ConversationParticipantConversationIdUserIdCompoundUniqueInput = {
    conversationId: number
    userId: number
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantAvgOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantSumOrderByAggregateInput = {
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumTopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    postCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type ForumTopicAvgOrderByAggregateInput = {
    id?: SortOrder
    postCount?: SortOrder
  }

  export type ForumTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    postCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type ForumTopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    postCount?: SortOrder
    lastActivity?: SortOrder
  }

  export type ForumTopicSumOrderByAggregateInput = {
    id?: SortOrder
    postCount?: SortOrder
  }

  export type ForumTopicRelationFilter = {
    is?: ForumTopicWhereInput
    isNot?: ForumTopicWhereInput
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorName?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ForumPostAvgOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorName?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    authorName?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type ForumPostSumOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    timeline?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    userId?: SortOrder
    rating?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    userId?: SortOrder
    rating?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BusRosterListRelationFilter = {
    every?: BusRosterWhereInput
    some?: BusRosterWhereInput
    none?: BusRosterWhereInput
  }

  export type BusRosterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PickupPointListRelationFilter = {
    every?: PickupPointWhereInput
    some?: PickupPointWhereInput
    none?: PickupPointWhereInput
  }

  export type PickupPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusRouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type BusRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type BusRouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type BusRouteNullableRelationFilter = {
    is?: BusRouteWhereInput | null
    isNot?: BusRouteWhereInput | null
  }

  export type DriverNullableRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type BusRosterCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
  }

  export type BusRosterAvgOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
  }

  export type BusRosterMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
  }

  export type BusRosterMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
  }

  export type BusRosterSumOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PickupPointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    routeId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    uiPositionTop?: SortOrder
    uiPositionLeft?: SortOrder
    isUserStop?: SortOrder
  }

  export type PickupPointAvgOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type PickupPointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    routeId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    uiPositionTop?: SortOrder
    uiPositionLeft?: SortOrder
    isUserStop?: SortOrder
  }

  export type PickupPointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    routeId?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    uiPositionTop?: SortOrder
    uiPositionLeft?: SortOrder
    isUserStop?: SortOrder
  }

  export type PickupPointSumOrderByAggregateInput = {
    id?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type FeePaymentListRelationFilter = {
    every?: FeePaymentWhereInput
    some?: FeePaymentWhereInput
    none?: FeePaymentWhereInput
  }

  export type FeePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentFeeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type StudentFeeAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
  }

  export type StudentFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type StudentFeeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
  }

  export type StudentFeeSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    totalFee?: SortOrder
    paidAmount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StudentFeeRelationFilter = {
    is?: StudentFeeWhereInput
    isNot?: StudentFeeWhereInput
  }

  export type FeePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    recordedBy?: SortOrder
  }

  export type FeePaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
  }

  export type FeePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    recordedBy?: SortOrder
  }

  export type FeePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    method?: SortOrder
    reference?: SortOrder
    recordedBy?: SortOrder
  }

  export type FeePaymentSumOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    amount?: SortOrder
  }

  export type StoreProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    stock?: SortOrder
  }

  export type StoreProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type StoreProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    stock?: SortOrder
  }

  export type StoreProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    imageUrl?: SortOrder
    stock?: SortOrder
  }

  export type StoreProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type StoreOrderCountOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    items?: SortOrder
  }

  export type StoreOrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type StoreOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
  }

  export type StoreOrderMinOrderByAggregateInput = {
    id?: SortOrder
    customerName?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
  }

  export type StoreOrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userName?: SortOrder
    userRole?: SortOrder
    action?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HealthLogCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    medicationAdministered?: SortOrder
    recordedBy?: SortOrder
  }

  export type HealthLogAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type HealthLogMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    recordedBy?: SortOrder
  }

  export type HealthLogMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    recordedBy?: SortOrder
  }

  export type HealthLogSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    category?: SortOrder
    status?: SortOrder
  }

  export type BookAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    category?: SortOrder
    status?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    coverUrl?: SortOrder
    category?: SortOrder
    status?: SortOrder
  }

  export type BookSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DigitalResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type DigitalResourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DigitalResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type DigitalResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
  }

  export type DigitalResourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CbtQuestionListRelationFilter = {
    every?: CbtQuestionWhereInput
    some?: CbtQuestionWhereInput
    none?: CbtQuestionWhereInput
  }

  export type CbtQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CbtTestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    durationMinutes?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
  }

  export type CbtTestAvgOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
  }

  export type CbtTestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    durationMinutes?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
  }

  export type CbtTestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    className?: SortOrder
    subject?: SortOrder
    durationMinutes?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
  }

  export type CbtTestSumOrderByAggregateInput = {
    id?: SortOrder
    durationMinutes?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CbtTestRelationFilter = {
    is?: CbtTestWhereInput
    isNot?: CbtTestWhereInput
  }

  export type CbtQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
  }

  export type CbtQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
  }

  export type CbtQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    questionText?: SortOrder
    correctAnswer?: SortOrder
  }

  export type CbtQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    questionText?: SortOrder
    correctAnswer?: SortOrder
  }

  export type CbtQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CbtResultCountOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type CbtResultAvgOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
  }

  export type CbtResultMaxOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type CbtResultMinOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type CbtResultSumOrderByAggregateInput = {
    id?: SortOrder
    testId?: SortOrder
    studentId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
  }

  export type CalendarEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CalendarEventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CalendarEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CalendarEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    type?: SortOrder
    description?: SortOrder
  }

  export type CalendarEventSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExtracurricularActivityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    schedule?: SortOrder
  }

  export type ExtracurricularActivityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExtracurricularActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    schedule?: SortOrder
  }

  export type ExtracurricularActivityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    schedule?: SortOrder
  }

  export type ExtracurricularActivitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PtaMeetingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    agenda?: SortOrder
  }

  export type PtaMeetingAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PtaMeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
  }

  export type PtaMeetingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
  }

  export type PtaMeetingSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SchoolPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
  }

  export type SchoolPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SchoolPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
  }

  export type SchoolPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
  }

  export type SchoolPolicySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VolunteeringOpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    spotsTotal?: SortOrder
    spotsFilled?: SortOrder
  }

  export type VolunteeringOpportunityAvgOrderByAggregateInput = {
    id?: SortOrder
    spotsTotal?: SortOrder
    spotsFilled?: SortOrder
  }

  export type VolunteeringOpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    spotsTotal?: SortOrder
    spotsFilled?: SortOrder
  }

  export type VolunteeringOpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    spotsTotal?: SortOrder
    spotsFilled?: SortOrder
  }

  export type VolunteeringOpportunitySumOrderByAggregateInput = {
    id?: SortOrder
    spotsTotal?: SortOrder
    spotsFilled?: SortOrder
  }

  export type PermissionSlipCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PermissionSlipAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type PermissionSlipMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PermissionSlipMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PermissionSlipSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    parentId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    parentId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    parentId?: SortOrder
  }

  export type PdResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    source?: SortOrder
    summary?: SortOrder
    url?: SortOrder
  }

  export type PdResourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PdResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    source?: SortOrder
    summary?: SortOrder
    url?: SortOrder
  }

  export type PdResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    source?: SortOrder
    summary?: SortOrder
    url?: SortOrder
  }

  export type PdResourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AiGameCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficultyLevel?: SortOrder
    status?: SortOrder
    questions?: SortOrder
  }

  export type AiGameAvgOrderByAggregateInput = {
    creatorId?: SortOrder
  }

  export type AiGameMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficultyLevel?: SortOrder
    status?: SortOrder
  }

  export type AiGameMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    difficultyLevel?: SortOrder
    status?: SortOrder
  }

  export type AiGameSumOrderByAggregateInput = {
    creatorId?: SortOrder
  }

  export type LessonPlanCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    topic?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type LessonPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonPlanMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    grade?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
  }

  export type LessonPlanSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type GeneratedResourceCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    term?: SortOrder
    schemeContent?: SortOrder
    lessonPlansContent?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type GeneratedResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedResourceMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    subject?: SortOrder
    className?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
  }

  export type GeneratedResourceSumOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
  }

  export type ReportCardCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    session?: SortOrder
    term?: SortOrder
    status?: SortOrder
    classTeacherComment?: SortOrder
    principalComment?: SortOrder
    gradeAverage?: SortOrder
    position?: SortOrder
    totalStudents?: SortOrder
    attendancePercentage?: SortOrder
    skills?: SortOrder
    psychomotor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type ReportCardAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    gradeAverage?: SortOrder
    position?: SortOrder
    totalStudents?: SortOrder
    attendancePercentage?: SortOrder
  }

  export type ReportCardMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    session?: SortOrder
    term?: SortOrder
    status?: SortOrder
    classTeacherComment?: SortOrder
    principalComment?: SortOrder
    gradeAverage?: SortOrder
    position?: SortOrder
    totalStudents?: SortOrder
    attendancePercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type ReportCardMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    session?: SortOrder
    term?: SortOrder
    status?: SortOrder
    classTeacherComment?: SortOrder
    principalComment?: SortOrder
    gradeAverage?: SortOrder
    position?: SortOrder
    totalStudents?: SortOrder
    attendancePercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type ReportCardSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    gradeAverage?: SortOrder
    position?: SortOrder
    totalStudents?: SortOrder
    attendancePercentage?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutUserInput | ComplaintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutUserInput | ComplaintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutUserInput | ComplaintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput> | ComplaintCreateWithoutUserInput[] | ComplaintUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutUserInput | ComplaintCreateOrConnectWithoutUserInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutUserInput | ComplaintUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComplaintCreateManyUserInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutUserInput | ComplaintUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutUserInput | ComplaintUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ParentChildCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput> | ParentChildCreateWithoutStudentInput[] | ParentChildUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutStudentInput | ParentChildCreateOrConnectWithoutStudentInput[]
    createMany?: ParentChildCreateManyStudentInputEnvelope
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
  }

  export type StudentAttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AcademicPerformanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput> | AcademicPerformanceCreateWithoutStudentInput[] | AcademicPerformanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicPerformanceCreateOrConnectWithoutStudentInput | AcademicPerformanceCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicPerformanceCreateManyStudentInputEnvelope
    connect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
  }

  export type BehaviorRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutStudentInput = {
    create?: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput> | BadgeCreateWithoutStudentInput[] | BadgeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutStudentInput | BadgeCreateOrConnectWithoutStudentInput[]
    createMany?: BadgeCreateManyStudentInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type AwardCreateNestedManyWithoutStudentInput = {
    create?: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput> | AwardCreateWithoutStudentInput[] | AwardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutStudentInput | AwardCreateOrConnectWithoutStudentInput[]
    createMany?: AwardCreateManyStudentInputEnvelope
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput> | SubmissionCreateWithoutStudentInput[] | SubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStudentInput | SubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: SubmissionCreateManyStudentInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type StudentFeeCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type CbtResultCreateNestedManyWithoutStudentInput = {
    create?: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput> | CbtResultCreateWithoutStudentInput[] | CbtResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutStudentInput | CbtResultCreateOrConnectWithoutStudentInput[]
    createMany?: CbtResultCreateManyStudentInputEnvelope
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
  }

  export type PermissionSlipCreateNestedManyWithoutStudentInput = {
    create?: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput> | PermissionSlipCreateWithoutStudentInput[] | PermissionSlipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PermissionSlipCreateOrConnectWithoutStudentInput | PermissionSlipCreateOrConnectWithoutStudentInput[]
    createMany?: PermissionSlipCreateManyStudentInputEnvelope
    connect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
  }

  export type ReportCardCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HealthLogCreateNestedManyWithoutStudentInput = {
    create?: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput> | HealthLogCreateWithoutStudentInput[] | HealthLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HealthLogCreateOrConnectWithoutStudentInput | HealthLogCreateOrConnectWithoutStudentInput[]
    createMany?: HealthLogCreateManyStudentInputEnvelope
    connect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ParentChildUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput> | ParentChildCreateWithoutStudentInput[] | ParentChildUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutStudentInput | ParentChildCreateOrConnectWithoutStudentInput[]
    createMany?: ParentChildCreateManyStudentInputEnvelope
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
  }

  export type StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
  }

  export type AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput> | AcademicPerformanceCreateWithoutStudentInput[] | AcademicPerformanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicPerformanceCreateOrConnectWithoutStudentInput | AcademicPerformanceCreateOrConnectWithoutStudentInput[]
    createMany?: AcademicPerformanceCreateManyStudentInputEnvelope
    connect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
  }

  export type BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput> | BadgeCreateWithoutStudentInput[] | BadgeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutStudentInput | BadgeCreateOrConnectWithoutStudentInput[]
    createMany?: BadgeCreateManyStudentInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type AwardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput> | AwardCreateWithoutStudentInput[] | AwardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutStudentInput | AwardCreateOrConnectWithoutStudentInput[]
    createMany?: AwardCreateManyStudentInputEnvelope
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput> | SubmissionCreateWithoutStudentInput[] | SubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStudentInput | SubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: SubmissionCreateManyStudentInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type StudentFeeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type CbtResultUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput> | CbtResultCreateWithoutStudentInput[] | CbtResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutStudentInput | CbtResultCreateOrConnectWithoutStudentInput[]
    createMany?: CbtResultCreateManyStudentInputEnvelope
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
  }

  export type PermissionSlipUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput> | PermissionSlipCreateWithoutStudentInput[] | PermissionSlipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PermissionSlipCreateOrConnectWithoutStudentInput | PermissionSlipCreateOrConnectWithoutStudentInput[]
    createMany?: PermissionSlipCreateManyStudentInputEnvelope
    connect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
  }

  export type ReportCardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type HealthLogUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput> | HealthLogCreateWithoutStudentInput[] | HealthLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HealthLogCreateOrConnectWithoutStudentInput | HealthLogCreateOrConnectWithoutStudentInput[]
    createMany?: HealthLogCreateManyStudentInputEnvelope
    connect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutStudentProfileNestedInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    upsert?: UserUpsertWithoutStudentProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentProfileInput, UserUpdateWithoutStudentProfileInput>, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type ParentChildUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput> | ParentChildCreateWithoutStudentInput[] | ParentChildUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutStudentInput | ParentChildCreateOrConnectWithoutStudentInput[]
    upsert?: ParentChildUpsertWithWhereUniqueWithoutStudentInput | ParentChildUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentChildCreateManyStudentInputEnvelope
    set?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    disconnect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    delete?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    update?: ParentChildUpdateWithWhereUniqueWithoutStudentInput | ParentChildUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentChildUpdateManyWithWhereWithoutStudentInput | ParentChildUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
  }

  export type StudentAttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AcademicPerformanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput> | AcademicPerformanceCreateWithoutStudentInput[] | AcademicPerformanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicPerformanceCreateOrConnectWithoutStudentInput | AcademicPerformanceCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicPerformanceUpsertWithWhereUniqueWithoutStudentInput | AcademicPerformanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicPerformanceCreateManyStudentInputEnvelope
    set?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    disconnect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    delete?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    connect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    update?: AcademicPerformanceUpdateWithWhereUniqueWithoutStudentInput | AcademicPerformanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicPerformanceUpdateManyWithWhereWithoutStudentInput | AcademicPerformanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicPerformanceScalarWhereInput | AcademicPerformanceScalarWhereInput[]
  }

  export type BehaviorRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput | BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput | BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutStudentInput | BehaviorRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput> | BadgeCreateWithoutStudentInput[] | BadgeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutStudentInput | BadgeCreateOrConnectWithoutStudentInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutStudentInput | BadgeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BadgeCreateManyStudentInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutStudentInput | BadgeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutStudentInput | BadgeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type AwardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput> | AwardCreateWithoutStudentInput[] | AwardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutStudentInput | AwardCreateOrConnectWithoutStudentInput[]
    upsert?: AwardUpsertWithWhereUniqueWithoutStudentInput | AwardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AwardCreateManyStudentInputEnvelope
    set?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    disconnect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    delete?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    update?: AwardUpdateWithWhereUniqueWithoutStudentInput | AwardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AwardUpdateManyWithWhereWithoutStudentInput | AwardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AwardScalarWhereInput | AwardScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput> | SubmissionCreateWithoutStudentInput[] | SubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStudentInput | SubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutStudentInput | SubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SubmissionCreateManyStudentInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutStudentInput | SubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutStudentInput | SubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type StudentFeeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutStudentInput | StudentFeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutStudentInput | StudentFeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutStudentInput | StudentFeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type CbtResultUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput> | CbtResultCreateWithoutStudentInput[] | CbtResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutStudentInput | CbtResultCreateOrConnectWithoutStudentInput[]
    upsert?: CbtResultUpsertWithWhereUniqueWithoutStudentInput | CbtResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CbtResultCreateManyStudentInputEnvelope
    set?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    disconnect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    delete?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    update?: CbtResultUpdateWithWhereUniqueWithoutStudentInput | CbtResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CbtResultUpdateManyWithWhereWithoutStudentInput | CbtResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
  }

  export type PermissionSlipUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput> | PermissionSlipCreateWithoutStudentInput[] | PermissionSlipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PermissionSlipCreateOrConnectWithoutStudentInput | PermissionSlipCreateOrConnectWithoutStudentInput[]
    upsert?: PermissionSlipUpsertWithWhereUniqueWithoutStudentInput | PermissionSlipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PermissionSlipCreateManyStudentInputEnvelope
    set?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    disconnect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    delete?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    connect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    update?: PermissionSlipUpdateWithWhereUniqueWithoutStudentInput | PermissionSlipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PermissionSlipUpdateManyWithWhereWithoutStudentInput | PermissionSlipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PermissionSlipScalarWhereInput | PermissionSlipScalarWhereInput[]
  }

  export type ReportCardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HealthLogUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput> | HealthLogCreateWithoutStudentInput[] | HealthLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HealthLogCreateOrConnectWithoutStudentInput | HealthLogCreateOrConnectWithoutStudentInput[]
    upsert?: HealthLogUpsertWithWhereUniqueWithoutStudentInput | HealthLogUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HealthLogCreateManyStudentInputEnvelope
    set?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    disconnect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    delete?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    connect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    update?: HealthLogUpdateWithWhereUniqueWithoutStudentInput | HealthLogUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HealthLogUpdateManyWithWhereWithoutStudentInput | HealthLogUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HealthLogScalarWhereInput | HealthLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStudentInput | NotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStudentInput | NotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStudentInput | NotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParentChildUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput> | ParentChildCreateWithoutStudentInput[] | ParentChildUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutStudentInput | ParentChildCreateOrConnectWithoutStudentInput[]
    upsert?: ParentChildUpsertWithWhereUniqueWithoutStudentInput | ParentChildUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentChildCreateManyStudentInputEnvelope
    set?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    disconnect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    delete?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    update?: ParentChildUpdateWithWhereUniqueWithoutStudentInput | ParentChildUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentChildUpdateManyWithWhereWithoutStudentInput | ParentChildUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput> | StudentAttendanceCreateWithoutStudentInput[] | StudentAttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAttendanceCreateOrConnectWithoutStudentInput | StudentAttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput | StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAttendanceCreateManyStudentInputEnvelope
    set?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    disconnect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    delete?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    connect?: StudentAttendanceWhereUniqueInput | StudentAttendanceWhereUniqueInput[]
    update?: StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput | StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAttendanceUpdateManyWithWhereWithoutStudentInput | StudentAttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
  }

  export type AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput> | AcademicPerformanceCreateWithoutStudentInput[] | AcademicPerformanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AcademicPerformanceCreateOrConnectWithoutStudentInput | AcademicPerformanceCreateOrConnectWithoutStudentInput[]
    upsert?: AcademicPerformanceUpsertWithWhereUniqueWithoutStudentInput | AcademicPerformanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AcademicPerformanceCreateManyStudentInputEnvelope
    set?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    disconnect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    delete?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    connect?: AcademicPerformanceWhereUniqueInput | AcademicPerformanceWhereUniqueInput[]
    update?: AcademicPerformanceUpdateWithWhereUniqueWithoutStudentInput | AcademicPerformanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AcademicPerformanceUpdateManyWithWhereWithoutStudentInput | AcademicPerformanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AcademicPerformanceScalarWhereInput | AcademicPerformanceScalarWhereInput[]
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput | BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput | BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutStudentInput | BehaviorRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput> | BadgeCreateWithoutStudentInput[] | BadgeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutStudentInput | BadgeCreateOrConnectWithoutStudentInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutStudentInput | BadgeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BadgeCreateManyStudentInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutStudentInput | BadgeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutStudentInput | BadgeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type AwardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput> | AwardCreateWithoutStudentInput[] | AwardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AwardCreateOrConnectWithoutStudentInput | AwardCreateOrConnectWithoutStudentInput[]
    upsert?: AwardUpsertWithWhereUniqueWithoutStudentInput | AwardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AwardCreateManyStudentInputEnvelope
    set?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    disconnect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    delete?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    connect?: AwardWhereUniqueInput | AwardWhereUniqueInput[]
    update?: AwardUpdateWithWhereUniqueWithoutStudentInput | AwardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AwardUpdateManyWithWhereWithoutStudentInput | AwardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AwardScalarWhereInput | AwardScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput> | SubmissionCreateWithoutStudentInput[] | SubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutStudentInput | SubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutStudentInput | SubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SubmissionCreateManyStudentInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutStudentInput | SubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutStudentInput | SubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type StudentFeeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutStudentInput | StudentFeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutStudentInput | StudentFeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutStudentInput | StudentFeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type CbtResultUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput> | CbtResultCreateWithoutStudentInput[] | CbtResultUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutStudentInput | CbtResultCreateOrConnectWithoutStudentInput[]
    upsert?: CbtResultUpsertWithWhereUniqueWithoutStudentInput | CbtResultUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CbtResultCreateManyStudentInputEnvelope
    set?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    disconnect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    delete?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    update?: CbtResultUpdateWithWhereUniqueWithoutStudentInput | CbtResultUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CbtResultUpdateManyWithWhereWithoutStudentInput | CbtResultUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
  }

  export type PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput> | PermissionSlipCreateWithoutStudentInput[] | PermissionSlipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PermissionSlipCreateOrConnectWithoutStudentInput | PermissionSlipCreateOrConnectWithoutStudentInput[]
    upsert?: PermissionSlipUpsertWithWhereUniqueWithoutStudentInput | PermissionSlipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PermissionSlipCreateManyStudentInputEnvelope
    set?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    disconnect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    delete?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    connect?: PermissionSlipWhereUniqueInput | PermissionSlipWhereUniqueInput[]
    update?: PermissionSlipUpdateWithWhereUniqueWithoutStudentInput | PermissionSlipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PermissionSlipUpdateManyWithWhereWithoutStudentInput | PermissionSlipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PermissionSlipScalarWhereInput | PermissionSlipScalarWhereInput[]
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type HealthLogUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput> | HealthLogCreateWithoutStudentInput[] | HealthLogUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HealthLogCreateOrConnectWithoutStudentInput | HealthLogCreateOrConnectWithoutStudentInput[]
    upsert?: HealthLogUpsertWithWhereUniqueWithoutStudentInput | HealthLogUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HealthLogCreateManyStudentInputEnvelope
    set?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    disconnect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    delete?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    connect?: HealthLogWhereUniqueInput | HealthLogWhereUniqueInput[]
    update?: HealthLogUpdateWithWhereUniqueWithoutStudentInput | HealthLogUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HealthLogUpdateManyWithWhereWithoutStudentInput | HealthLogUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HealthLogScalarWhereInput | HealthLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput> | NotificationCreateWithoutStudentInput[] | NotificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutStudentInput | NotificationCreateOrConnectWithoutStudentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutStudentInput | NotificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: NotificationCreateManyStudentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutStudentInput | NotificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutStudentInput | NotificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeacherProfileInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TeacherClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput> | ExamCreateWithoutTeacherInput[] | ExamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTeacherInput | ExamCreateOrConnectWithoutTeacherInput[]
    createMany?: ExamCreateManyTeacherInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AiGameCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput> | AiGameCreateWithoutCreatorInput[] | AiGameUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AiGameCreateOrConnectWithoutCreatorInput | AiGameCreateOrConnectWithoutCreatorInput[]
    createMany?: AiGameCreateManyCreatorInputEnvelope
    connect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
  }

  export type LessonPlanCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput> | LessonPlanCreateWithoutTeacherInput[] | LessonPlanUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutTeacherInput | LessonPlanCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonPlanCreateManyTeacherInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type GeneratedResourceCreateNestedManyWithoutTeacherInput = {
    create?: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput> | GeneratedResourceCreateWithoutTeacherInput[] | GeneratedResourceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GeneratedResourceCreateOrConnectWithoutTeacherInput | GeneratedResourceCreateOrConnectWithoutTeacherInput[]
    createMany?: GeneratedResourceCreateManyTeacherInputEnvelope
    connect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput> | AppointmentCreateWithoutTeacherInput[] | AppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTeacherInput | AppointmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AppointmentCreateManyTeacherInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TeacherClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput> | ExamCreateWithoutTeacherInput[] | ExamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTeacherInput | ExamCreateOrConnectWithoutTeacherInput[]
    createMany?: ExamCreateManyTeacherInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type AiGameUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput> | AiGameCreateWithoutCreatorInput[] | AiGameUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AiGameCreateOrConnectWithoutCreatorInput | AiGameCreateOrConnectWithoutCreatorInput[]
    createMany?: AiGameCreateManyCreatorInputEnvelope
    connect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
  }

  export type LessonPlanUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput> | LessonPlanCreateWithoutTeacherInput[] | LessonPlanUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutTeacherInput | LessonPlanCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonPlanCreateManyTeacherInputEnvelope
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
  }

  export type GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput> | GeneratedResourceCreateWithoutTeacherInput[] | GeneratedResourceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GeneratedResourceCreateOrConnectWithoutTeacherInput | GeneratedResourceCreateOrConnectWithoutTeacherInput[]
    createMany?: GeneratedResourceCreateManyTeacherInputEnvelope
    connect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput> | AppointmentCreateWithoutTeacherInput[] | AppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTeacherInput | AppointmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AppointmentCreateManyTeacherInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutTeacherProfileNestedInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    upsert?: UserUpsertWithoutTeacherProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherProfileInput, UserUpdateWithoutTeacherProfileInput>, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type TeacherSubjectUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TeacherClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutTeacherInput | TeacherClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTeacherInput | TimetableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTeacherInput | TimetableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTeacherInput | TimetableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput> | ExamCreateWithoutTeacherInput[] | ExamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTeacherInput | ExamCreateOrConnectWithoutTeacherInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutTeacherInput | ExamUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ExamCreateManyTeacherInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutTeacherInput | ExamUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutTeacherInput | ExamUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AiGameUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput> | AiGameCreateWithoutCreatorInput[] | AiGameUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AiGameCreateOrConnectWithoutCreatorInput | AiGameCreateOrConnectWithoutCreatorInput[]
    upsert?: AiGameUpsertWithWhereUniqueWithoutCreatorInput | AiGameUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AiGameCreateManyCreatorInputEnvelope
    set?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    disconnect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    delete?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    connect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    update?: AiGameUpdateWithWhereUniqueWithoutCreatorInput | AiGameUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AiGameUpdateManyWithWhereWithoutCreatorInput | AiGameUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AiGameScalarWhereInput | AiGameScalarWhereInput[]
  }

  export type LessonPlanUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput> | LessonPlanCreateWithoutTeacherInput[] | LessonPlanUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutTeacherInput | LessonPlanCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutTeacherInput | LessonPlanUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonPlanCreateManyTeacherInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutTeacherInput | LessonPlanUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutTeacherInput | LessonPlanUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type GeneratedResourceUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput> | GeneratedResourceCreateWithoutTeacherInput[] | GeneratedResourceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GeneratedResourceCreateOrConnectWithoutTeacherInput | GeneratedResourceCreateOrConnectWithoutTeacherInput[]
    upsert?: GeneratedResourceUpsertWithWhereUniqueWithoutTeacherInput | GeneratedResourceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: GeneratedResourceCreateManyTeacherInputEnvelope
    set?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    disconnect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    delete?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    connect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    update?: GeneratedResourceUpdateWithWhereUniqueWithoutTeacherInput | GeneratedResourceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: GeneratedResourceUpdateManyWithWhereWithoutTeacherInput | GeneratedResourceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: GeneratedResourceScalarWhereInput | GeneratedResourceScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput> | AppointmentCreateWithoutTeacherInput[] | AppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTeacherInput | AppointmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTeacherInput | AppointmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AppointmentCreateManyTeacherInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTeacherInput | AppointmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTeacherInput | AppointmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutTeacherInput | TeacherClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput> | TimetableCreateWithoutTeacherInput[] | TimetableUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutTeacherInput | TimetableCreateOrConnectWithoutTeacherInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutTeacherInput | TimetableUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TimetableCreateManyTeacherInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutTeacherInput | TimetableUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutTeacherInput | TimetableUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput> | ExamCreateWithoutTeacherInput[] | ExamUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTeacherInput | ExamCreateOrConnectWithoutTeacherInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutTeacherInput | ExamUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ExamCreateManyTeacherInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutTeacherInput | ExamUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutTeacherInput | ExamUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type AiGameUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput> | AiGameCreateWithoutCreatorInput[] | AiGameUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AiGameCreateOrConnectWithoutCreatorInput | AiGameCreateOrConnectWithoutCreatorInput[]
    upsert?: AiGameUpsertWithWhereUniqueWithoutCreatorInput | AiGameUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AiGameCreateManyCreatorInputEnvelope
    set?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    disconnect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    delete?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    connect?: AiGameWhereUniqueInput | AiGameWhereUniqueInput[]
    update?: AiGameUpdateWithWhereUniqueWithoutCreatorInput | AiGameUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AiGameUpdateManyWithWhereWithoutCreatorInput | AiGameUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AiGameScalarWhereInput | AiGameScalarWhereInput[]
  }

  export type LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput> | LessonPlanCreateWithoutTeacherInput[] | LessonPlanUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonPlanCreateOrConnectWithoutTeacherInput | LessonPlanCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonPlanUpsertWithWhereUniqueWithoutTeacherInput | LessonPlanUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonPlanCreateManyTeacherInputEnvelope
    set?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    disconnect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    delete?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    connect?: LessonPlanWhereUniqueInput | LessonPlanWhereUniqueInput[]
    update?: LessonPlanUpdateWithWhereUniqueWithoutTeacherInput | LessonPlanUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonPlanUpdateManyWithWhereWithoutTeacherInput | LessonPlanUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
  }

  export type GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput> | GeneratedResourceCreateWithoutTeacherInput[] | GeneratedResourceUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GeneratedResourceCreateOrConnectWithoutTeacherInput | GeneratedResourceCreateOrConnectWithoutTeacherInput[]
    upsert?: GeneratedResourceUpsertWithWhereUniqueWithoutTeacherInput | GeneratedResourceUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: GeneratedResourceCreateManyTeacherInputEnvelope
    set?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    disconnect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    delete?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    connect?: GeneratedResourceWhereUniqueInput | GeneratedResourceWhereUniqueInput[]
    update?: GeneratedResourceUpdateWithWhereUniqueWithoutTeacherInput | GeneratedResourceUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: GeneratedResourceUpdateManyWithWhereWithoutTeacherInput | GeneratedResourceUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: GeneratedResourceScalarWhereInput | GeneratedResourceScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput> | AppointmentCreateWithoutTeacherInput[] | AppointmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTeacherInput | AppointmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTeacherInput | AppointmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AppointmentCreateManyTeacherInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTeacherInput | AppointmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTeacherInput | AppointmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentProfileInput = {
    create?: XOR<UserCreateWithoutParentProfileInput, UserUncheckedCreateWithoutParentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ParentChildCreateNestedManyWithoutParentInput = {
    create?: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput> | ParentChildCreateWithoutParentInput[] | ParentChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutParentInput | ParentChildCreateOrConnectWithoutParentInput[]
    createMany?: ParentChildCreateManyParentInputEnvelope
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutParentInput = {
    create?: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput> | AppointmentCreateWithoutParentInput[] | AppointmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutParentInput | AppointmentCreateOrConnectWithoutParentInput[]
    createMany?: AppointmentCreateManyParentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ParentChildUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput> | ParentChildCreateWithoutParentInput[] | ParentChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutParentInput | ParentChildCreateOrConnectWithoutParentInput[]
    createMany?: ParentChildCreateManyParentInputEnvelope
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput> | AppointmentCreateWithoutParentInput[] | AppointmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutParentInput | AppointmentCreateOrConnectWithoutParentInput[]
    createMany?: AppointmentCreateManyParentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutParentProfileNestedInput = {
    create?: XOR<UserCreateWithoutParentProfileInput, UserUncheckedCreateWithoutParentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentProfileInput
    upsert?: UserUpsertWithoutParentProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentProfileInput, UserUpdateWithoutParentProfileInput>, UserUncheckedUpdateWithoutParentProfileInput>
  }

  export type ParentChildUpdateManyWithoutParentNestedInput = {
    create?: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput> | ParentChildCreateWithoutParentInput[] | ParentChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutParentInput | ParentChildCreateOrConnectWithoutParentInput[]
    upsert?: ParentChildUpsertWithWhereUniqueWithoutParentInput | ParentChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ParentChildCreateManyParentInputEnvelope
    set?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    disconnect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    delete?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    update?: ParentChildUpdateWithWhereUniqueWithoutParentInput | ParentChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ParentChildUpdateManyWithWhereWithoutParentInput | ParentChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutParentNestedInput = {
    create?: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput> | AppointmentCreateWithoutParentInput[] | AppointmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutParentInput | AppointmentCreateOrConnectWithoutParentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutParentInput | AppointmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AppointmentCreateManyParentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutParentInput | AppointmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutParentInput | AppointmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ParentChildUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput> | ParentChildCreateWithoutParentInput[] | ParentChildUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ParentChildCreateOrConnectWithoutParentInput | ParentChildCreateOrConnectWithoutParentInput[]
    upsert?: ParentChildUpsertWithWhereUniqueWithoutParentInput | ParentChildUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ParentChildCreateManyParentInputEnvelope
    set?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    disconnect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    delete?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    connect?: ParentChildWhereUniqueInput | ParentChildWhereUniqueInput[]
    update?: ParentChildUpdateWithWhereUniqueWithoutParentInput | ParentChildUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ParentChildUpdateManyWithWhereWithoutParentInput | ParentChildUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput> | AppointmentCreateWithoutParentInput[] | AppointmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutParentInput | AppointmentCreateOrConnectWithoutParentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutParentInput | AppointmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AppointmentCreateManyParentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutParentInput | AppointmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutParentInput | AppointmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ParentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    upsert?: ParentUpsertWithoutChildrenInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutChildrenInput, ParentUpdateWithoutChildrenInput>, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type StudentUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type TeacherCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    upsert?: TeacherUpsertWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutSubjectsInput, TeacherUpdateWithoutSubjectsInput>, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    upsert?: TeacherUpsertWithoutClassesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassesInput, TeacherUpdateWithoutClassesInput>, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherCreateNestedOneWithoutTimetableEntriesInput = {
    create?: XOR<TeacherCreateWithoutTimetableEntriesInput, TeacherUncheckedCreateWithoutTimetableEntriesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTimetableEntriesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutTimetableEntriesNestedInput = {
    create?: XOR<TeacherCreateWithoutTimetableEntriesInput, TeacherUncheckedCreateWithoutTimetableEntriesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutTimetableEntriesInput
    upsert?: TeacherUpsertWithoutTimetableEntriesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutTimetableEntriesInput, TeacherUpdateWithoutTimetableEntriesInput>, TeacherUncheckedUpdateWithoutTimetableEntriesInput>
  }

  export type StudentCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: StudentUpsertWithoutAttendanceRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput, StudentUpdateWithoutAttendanceRecordsInput>, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentCreateNestedOneWithoutAcademicPerformanceInput = {
    create?: XOR<StudentCreateWithoutAcademicPerformanceInput, StudentUncheckedCreateWithoutAcademicPerformanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicPerformanceInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAcademicPerformanceNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicPerformanceInput, StudentUncheckedCreateWithoutAcademicPerformanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicPerformanceInput
    upsert?: StudentUpsertWithoutAcademicPerformanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAcademicPerformanceInput, StudentUpdateWithoutAcademicPerformanceInput>, StudentUncheckedUpdateWithoutAcademicPerformanceInput>
  }

  export type StudentCreateNestedOneWithoutBehaviorRecordsInput = {
    create?: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBehaviorRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutBehaviorRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBehaviorRecordsInput
    upsert?: StudentUpsertWithoutBehaviorRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutBehaviorRecordsInput, StudentUpdateWithoutBehaviorRecordsInput>, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type StudentCreateNestedOneWithoutBadgesInput = {
    create?: XOR<StudentCreateWithoutBadgesInput, StudentUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBadgesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<StudentCreateWithoutBadgesInput, StudentUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBadgesInput
    upsert?: StudentUpsertWithoutBadgesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutBadgesInput, StudentUpdateWithoutBadgesInput>, StudentUncheckedUpdateWithoutBadgesInput>
  }

  export type StudentCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    upsert?: StudentUpsertWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCertificatesInput, StudentUpdateWithoutCertificatesInput>, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentCreateNestedOneWithoutAwardsInput = {
    create?: XOR<StudentCreateWithoutAwardsInput, StudentUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAwardsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAwardsNestedInput = {
    create?: XOR<StudentCreateWithoutAwardsInput, StudentUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAwardsInput
    upsert?: StudentUpsertWithoutAwardsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAwardsInput, StudentUpdateWithoutAwardsInput>, StudentUncheckedUpdateWithoutAwardsInput>
  }

  export type SubmissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput> | SubmissionCreateWithoutAssignmentInput[] | SubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutAssignmentInput | SubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: SubmissionCreateManyAssignmentInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput> | SubmissionCreateWithoutAssignmentInput[] | SubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutAssignmentInput | SubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: SubmissionCreateManyAssignmentInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type SubmissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput> | SubmissionCreateWithoutAssignmentInput[] | SubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutAssignmentInput | SubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutAssignmentInput | SubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: SubmissionCreateManyAssignmentInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutAssignmentInput | SubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutAssignmentInput | SubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput> | SubmissionCreateWithoutAssignmentInput[] | SubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutAssignmentInput | SubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutAssignmentInput | SubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: SubmissionCreateManyAssignmentInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutAssignmentInput | SubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutAssignmentInput | SubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type AssignmentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubmissionsInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    upsert?: AssignmentUpsertWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutSubmissionsInput, AssignmentUpdateWithoutSubmissionsInput>, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSubmissionsInput
    upsert?: StudentUpsertWithoutSubmissionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSubmissionsInput, StudentUpdateWithoutSubmissionsInput>, StudentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type TeacherCreateNestedOneWithoutExamsInput = {
    create?: XOR<TeacherCreateWithoutExamsInput, TeacherUncheckedCreateWithoutExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutExamsInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutExamsNestedInput = {
    create?: XOR<TeacherCreateWithoutExamsInput, TeacherUncheckedCreateWithoutExamsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutExamsInput
    upsert?: TeacherUpsertWithoutExamsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutExamsInput, TeacherUpdateWithoutExamsInput>, TeacherUncheckedUpdateWithoutExamsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    connect?: StudentWhereUniqueInput
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutNotificationsInput
    upsert?: StudentUpsertWithoutNotificationsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutNotificationsInput, StudentUpdateWithoutNotificationsInput>, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsParticipatedInput = {
    create?: XOR<UserCreateWithoutConversationsParticipatedInput, UserUncheckedCreateWithoutConversationsParticipatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsParticipatedInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationsParticipatedNestedInput = {
    create?: XOR<UserCreateWithoutConversationsParticipatedInput, UserUncheckedCreateWithoutConversationsParticipatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsParticipatedInput
    upsert?: UserUpsertWithoutConversationsParticipatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsParticipatedInput, UserUpdateWithoutConversationsParticipatedInput>, UserUncheckedUpdateWithoutConversationsParticipatedInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type ForumPostCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumPostUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutTopicInput | ForumPostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutTopicInput | ForumPostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutTopicInput | ForumPostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput> | ForumPostCreateWithoutTopicInput[] | ForumPostUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutTopicInput | ForumPostCreateOrConnectWithoutTopicInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutTopicInput | ForumPostUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ForumPostCreateManyTopicInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutTopicInput | ForumPostUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutTopicInput | ForumPostUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumTopicCreateNestedOneWithoutPostsInput = {
    create?: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutPostsInput
    connect?: ForumTopicWhereUniqueInput
  }

  export type ForumTopicUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ForumTopicCreateOrConnectWithoutPostsInput
    upsert?: ForumTopicUpsertWithoutPostsInput
    connect?: ForumTopicWhereUniqueInput
    update?: XOR<XOR<ForumTopicUpdateToOneWithWhereWithoutPostsInput, ForumTopicUpdateWithoutPostsInput>, ForumTopicUncheckedUpdateWithoutPostsInput>
  }

  export type UserCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput
    upsert?: UserUpsertWithoutComplaintsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComplaintsInput, UserUpdateWithoutComplaintsInput>, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type BusRosterCreateNestedManyWithoutDriverInput = {
    create?: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput> | BusRosterCreateWithoutDriverInput[] | BusRosterUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutDriverInput | BusRosterCreateOrConnectWithoutDriverInput[]
    createMany?: BusRosterCreateManyDriverInputEnvelope
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
  }

  export type BusRosterUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput> | BusRosterCreateWithoutDriverInput[] | BusRosterUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutDriverInput | BusRosterCreateOrConnectWithoutDriverInput[]
    createMany?: BusRosterCreateManyDriverInputEnvelope
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
  }

  export type BusRosterUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput> | BusRosterCreateWithoutDriverInput[] | BusRosterUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutDriverInput | BusRosterCreateOrConnectWithoutDriverInput[]
    upsert?: BusRosterUpsertWithWhereUniqueWithoutDriverInput | BusRosterUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BusRosterCreateManyDriverInputEnvelope
    set?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    disconnect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    delete?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    update?: BusRosterUpdateWithWhereUniqueWithoutDriverInput | BusRosterUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BusRosterUpdateManyWithWhereWithoutDriverInput | BusRosterUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
  }

  export type BusRosterUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput> | BusRosterCreateWithoutDriverInput[] | BusRosterUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutDriverInput | BusRosterCreateOrConnectWithoutDriverInput[]
    upsert?: BusRosterUpsertWithWhereUniqueWithoutDriverInput | BusRosterUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BusRosterCreateManyDriverInputEnvelope
    set?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    disconnect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    delete?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    update?: BusRosterUpdateWithWhereUniqueWithoutDriverInput | BusRosterUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BusRosterUpdateManyWithWhereWithoutDriverInput | BusRosterUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
  }

  export type BusRosterCreateNestedManyWithoutRouteInput = {
    create?: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput> | BusRosterCreateWithoutRouteInput[] | BusRosterUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutRouteInput | BusRosterCreateOrConnectWithoutRouteInput[]
    createMany?: BusRosterCreateManyRouteInputEnvelope
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
  }

  export type PickupPointCreateNestedManyWithoutRouteInput = {
    create?: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput> | PickupPointCreateWithoutRouteInput[] | PickupPointUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: PickupPointCreateOrConnectWithoutRouteInput | PickupPointCreateOrConnectWithoutRouteInput[]
    createMany?: PickupPointCreateManyRouteInputEnvelope
    connect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
  }

  export type BusRosterUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput> | BusRosterCreateWithoutRouteInput[] | BusRosterUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutRouteInput | BusRosterCreateOrConnectWithoutRouteInput[]
    createMany?: BusRosterCreateManyRouteInputEnvelope
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
  }

  export type PickupPointUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput> | PickupPointCreateWithoutRouteInput[] | PickupPointUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: PickupPointCreateOrConnectWithoutRouteInput | PickupPointCreateOrConnectWithoutRouteInput[]
    createMany?: PickupPointCreateManyRouteInputEnvelope
    connect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
  }

  export type BusRosterUpdateManyWithoutRouteNestedInput = {
    create?: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput> | BusRosterCreateWithoutRouteInput[] | BusRosterUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutRouteInput | BusRosterCreateOrConnectWithoutRouteInput[]
    upsert?: BusRosterUpsertWithWhereUniqueWithoutRouteInput | BusRosterUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: BusRosterCreateManyRouteInputEnvelope
    set?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    disconnect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    delete?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    update?: BusRosterUpdateWithWhereUniqueWithoutRouteInput | BusRosterUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: BusRosterUpdateManyWithWhereWithoutRouteInput | BusRosterUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
  }

  export type PickupPointUpdateManyWithoutRouteNestedInput = {
    create?: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput> | PickupPointCreateWithoutRouteInput[] | PickupPointUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: PickupPointCreateOrConnectWithoutRouteInput | PickupPointCreateOrConnectWithoutRouteInput[]
    upsert?: PickupPointUpsertWithWhereUniqueWithoutRouteInput | PickupPointUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: PickupPointCreateManyRouteInputEnvelope
    set?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    disconnect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    delete?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    connect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    update?: PickupPointUpdateWithWhereUniqueWithoutRouteInput | PickupPointUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: PickupPointUpdateManyWithWhereWithoutRouteInput | PickupPointUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: PickupPointScalarWhereInput | PickupPointScalarWhereInput[]
  }

  export type BusRosterUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput> | BusRosterCreateWithoutRouteInput[] | BusRosterUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: BusRosterCreateOrConnectWithoutRouteInput | BusRosterCreateOrConnectWithoutRouteInput[]
    upsert?: BusRosterUpsertWithWhereUniqueWithoutRouteInput | BusRosterUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: BusRosterCreateManyRouteInputEnvelope
    set?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    disconnect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    delete?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    connect?: BusRosterWhereUniqueInput | BusRosterWhereUniqueInput[]
    update?: BusRosterUpdateWithWhereUniqueWithoutRouteInput | BusRosterUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: BusRosterUpdateManyWithWhereWithoutRouteInput | BusRosterUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
  }

  export type PickupPointUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput> | PickupPointCreateWithoutRouteInput[] | PickupPointUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: PickupPointCreateOrConnectWithoutRouteInput | PickupPointCreateOrConnectWithoutRouteInput[]
    upsert?: PickupPointUpsertWithWhereUniqueWithoutRouteInput | PickupPointUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: PickupPointCreateManyRouteInputEnvelope
    set?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    disconnect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    delete?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    connect?: PickupPointWhereUniqueInput | PickupPointWhereUniqueInput[]
    update?: PickupPointUpdateWithWhereUniqueWithoutRouteInput | PickupPointUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: PickupPointUpdateManyWithWhereWithoutRouteInput | PickupPointUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: PickupPointScalarWhereInput | PickupPointScalarWhereInput[]
  }

  export type BusRouteCreateNestedOneWithoutRosterInput = {
    create?: XOR<BusRouteCreateWithoutRosterInput, BusRouteUncheckedCreateWithoutRosterInput>
    connectOrCreate?: BusRouteCreateOrConnectWithoutRosterInput
    connect?: BusRouteWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutRosterInput = {
    create?: XOR<DriverCreateWithoutRosterInput, DriverUncheckedCreateWithoutRosterInput>
    connectOrCreate?: DriverCreateOrConnectWithoutRosterInput
    connect?: DriverWhereUniqueInput
  }

  export type BusRouteUpdateOneWithoutRosterNestedInput = {
    create?: XOR<BusRouteCreateWithoutRosterInput, BusRouteUncheckedCreateWithoutRosterInput>
    connectOrCreate?: BusRouteCreateOrConnectWithoutRosterInput
    upsert?: BusRouteUpsertWithoutRosterInput
    disconnect?: BusRouteWhereInput | boolean
    delete?: BusRouteWhereInput | boolean
    connect?: BusRouteWhereUniqueInput
    update?: XOR<XOR<BusRouteUpdateToOneWithWhereWithoutRosterInput, BusRouteUpdateWithoutRosterInput>, BusRouteUncheckedUpdateWithoutRosterInput>
  }

  export type DriverUpdateOneWithoutRosterNestedInput = {
    create?: XOR<DriverCreateWithoutRosterInput, DriverUncheckedCreateWithoutRosterInput>
    connectOrCreate?: DriverCreateOrConnectWithoutRosterInput
    upsert?: DriverUpsertWithoutRosterInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutRosterInput, DriverUpdateWithoutRosterInput>, DriverUncheckedUpdateWithoutRosterInput>
  }

  export type BusRouteCreateNestedOneWithoutPickupPointsInput = {
    create?: XOR<BusRouteCreateWithoutPickupPointsInput, BusRouteUncheckedCreateWithoutPickupPointsInput>
    connectOrCreate?: BusRouteCreateOrConnectWithoutPickupPointsInput
    connect?: BusRouteWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusRouteUpdateOneWithoutPickupPointsNestedInput = {
    create?: XOR<BusRouteCreateWithoutPickupPointsInput, BusRouteUncheckedCreateWithoutPickupPointsInput>
    connectOrCreate?: BusRouteCreateOrConnectWithoutPickupPointsInput
    upsert?: BusRouteUpsertWithoutPickupPointsInput
    disconnect?: BusRouteWhereInput | boolean
    delete?: BusRouteWhereInput | boolean
    connect?: BusRouteWhereUniqueInput
    update?: XOR<XOR<BusRouteUpdateToOneWithWhereWithoutPickupPointsInput, BusRouteUpdateWithoutPickupPointsInput>, BusRouteUncheckedUpdateWithoutPickupPointsInput>
  }

  export type StudentCreateNestedOneWithoutFeesInput = {
    create?: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeesInput
    connect?: StudentWhereUniqueInput
  }

  export type FeePaymentCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type FeePaymentUncheckedCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StudentUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeesInput
    upsert?: StudentUpsertWithoutFeesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeesInput, StudentUpdateWithoutFeesInput>, StudentUncheckedUpdateWithoutFeesInput>
  }

  export type FeePaymentUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput> | FeePaymentCreateWithoutFeeInput[] | FeePaymentUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeePaymentCreateOrConnectWithoutFeeInput | FeePaymentCreateOrConnectWithoutFeeInput[]
    upsert?: FeePaymentUpsertWithWhereUniqueWithoutFeeInput | FeePaymentUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeePaymentCreateManyFeeInputEnvelope
    set?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    disconnect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    delete?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    connect?: FeePaymentWhereUniqueInput | FeePaymentWhereUniqueInput[]
    update?: FeePaymentUpdateWithWhereUniqueWithoutFeeInput | FeePaymentUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeePaymentUpdateManyWithWhereWithoutFeeInput | FeePaymentUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
  }

  export type StudentFeeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StudentFeeCreateWithoutPaymentsInput, StudentFeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutPaymentsInput
    connect?: StudentFeeWhereUniqueInput
  }

  export type StudentFeeUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<StudentFeeCreateWithoutPaymentsInput, StudentFeeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutPaymentsInput
    upsert?: StudentFeeUpsertWithoutPaymentsInput
    connect?: StudentFeeWhereUniqueInput
    update?: XOR<XOR<StudentFeeUpdateToOneWithWhereWithoutPaymentsInput, StudentFeeUpdateWithoutPaymentsInput>, StudentFeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentCreateNestedOneWithoutHealthLogsInput = {
    create?: XOR<StudentCreateWithoutHealthLogsInput, StudentUncheckedCreateWithoutHealthLogsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHealthLogsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneWithoutHealthLogsNestedInput = {
    create?: XOR<StudentCreateWithoutHealthLogsInput, StudentUncheckedCreateWithoutHealthLogsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHealthLogsInput
    upsert?: StudentUpsertWithoutHealthLogsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutHealthLogsInput, StudentUpdateWithoutHealthLogsInput>, StudentUncheckedUpdateWithoutHealthLogsInput>
  }

  export type CbtQuestionCreateNestedManyWithoutTestInput = {
    create?: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput> | CbtQuestionCreateWithoutTestInput[] | CbtQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtQuestionCreateOrConnectWithoutTestInput | CbtQuestionCreateOrConnectWithoutTestInput[]
    createMany?: CbtQuestionCreateManyTestInputEnvelope
    connect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
  }

  export type CbtResultCreateNestedManyWithoutTestInput = {
    create?: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput> | CbtResultCreateWithoutTestInput[] | CbtResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutTestInput | CbtResultCreateOrConnectWithoutTestInput[]
    createMany?: CbtResultCreateManyTestInputEnvelope
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
  }

  export type CbtQuestionUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput> | CbtQuestionCreateWithoutTestInput[] | CbtQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtQuestionCreateOrConnectWithoutTestInput | CbtQuestionCreateOrConnectWithoutTestInput[]
    createMany?: CbtQuestionCreateManyTestInputEnvelope
    connect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
  }

  export type CbtResultUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput> | CbtResultCreateWithoutTestInput[] | CbtResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutTestInput | CbtResultCreateOrConnectWithoutTestInput[]
    createMany?: CbtResultCreateManyTestInputEnvelope
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
  }

  export type CbtQuestionUpdateManyWithoutTestNestedInput = {
    create?: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput> | CbtQuestionCreateWithoutTestInput[] | CbtQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtQuestionCreateOrConnectWithoutTestInput | CbtQuestionCreateOrConnectWithoutTestInput[]
    upsert?: CbtQuestionUpsertWithWhereUniqueWithoutTestInput | CbtQuestionUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: CbtQuestionCreateManyTestInputEnvelope
    set?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    disconnect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    delete?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    connect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    update?: CbtQuestionUpdateWithWhereUniqueWithoutTestInput | CbtQuestionUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: CbtQuestionUpdateManyWithWhereWithoutTestInput | CbtQuestionUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: CbtQuestionScalarWhereInput | CbtQuestionScalarWhereInput[]
  }

  export type CbtResultUpdateManyWithoutTestNestedInput = {
    create?: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput> | CbtResultCreateWithoutTestInput[] | CbtResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutTestInput | CbtResultCreateOrConnectWithoutTestInput[]
    upsert?: CbtResultUpsertWithWhereUniqueWithoutTestInput | CbtResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: CbtResultCreateManyTestInputEnvelope
    set?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    disconnect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    delete?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    update?: CbtResultUpdateWithWhereUniqueWithoutTestInput | CbtResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: CbtResultUpdateManyWithWhereWithoutTestInput | CbtResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
  }

  export type CbtQuestionUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput> | CbtQuestionCreateWithoutTestInput[] | CbtQuestionUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtQuestionCreateOrConnectWithoutTestInput | CbtQuestionCreateOrConnectWithoutTestInput[]
    upsert?: CbtQuestionUpsertWithWhereUniqueWithoutTestInput | CbtQuestionUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: CbtQuestionCreateManyTestInputEnvelope
    set?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    disconnect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    delete?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    connect?: CbtQuestionWhereUniqueInput | CbtQuestionWhereUniqueInput[]
    update?: CbtQuestionUpdateWithWhereUniqueWithoutTestInput | CbtQuestionUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: CbtQuestionUpdateManyWithWhereWithoutTestInput | CbtQuestionUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: CbtQuestionScalarWhereInput | CbtQuestionScalarWhereInput[]
  }

  export type CbtResultUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput> | CbtResultCreateWithoutTestInput[] | CbtResultUncheckedCreateWithoutTestInput[]
    connectOrCreate?: CbtResultCreateOrConnectWithoutTestInput | CbtResultCreateOrConnectWithoutTestInput[]
    upsert?: CbtResultUpsertWithWhereUniqueWithoutTestInput | CbtResultUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: CbtResultCreateManyTestInputEnvelope
    set?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    disconnect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    delete?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    connect?: CbtResultWhereUniqueInput | CbtResultWhereUniqueInput[]
    update?: CbtResultUpdateWithWhereUniqueWithoutTestInput | CbtResultUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: CbtResultUpdateManyWithWhereWithoutTestInput | CbtResultUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
  }

  export type CbtTestCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<CbtTestCreateWithoutQuestionsInput, CbtTestUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CbtTestCreateOrConnectWithoutQuestionsInput
    connect?: CbtTestWhereUniqueInput
  }

  export type CbtTestUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<CbtTestCreateWithoutQuestionsInput, CbtTestUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CbtTestCreateOrConnectWithoutQuestionsInput
    upsert?: CbtTestUpsertWithoutQuestionsInput
    connect?: CbtTestWhereUniqueInput
    update?: XOR<XOR<CbtTestUpdateToOneWithWhereWithoutQuestionsInput, CbtTestUpdateWithoutQuestionsInput>, CbtTestUncheckedUpdateWithoutQuestionsInput>
  }

  export type CbtTestCreateNestedOneWithoutResultsInput = {
    create?: XOR<CbtTestCreateWithoutResultsInput, CbtTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: CbtTestCreateOrConnectWithoutResultsInput
    connect?: CbtTestWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutCbtResultsInput = {
    create?: XOR<StudentCreateWithoutCbtResultsInput, StudentUncheckedCreateWithoutCbtResultsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCbtResultsInput
    connect?: StudentWhereUniqueInput
  }

  export type CbtTestUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<CbtTestCreateWithoutResultsInput, CbtTestUncheckedCreateWithoutResultsInput>
    connectOrCreate?: CbtTestCreateOrConnectWithoutResultsInput
    upsert?: CbtTestUpsertWithoutResultsInput
    connect?: CbtTestWhereUniqueInput
    update?: XOR<XOR<CbtTestUpdateToOneWithWhereWithoutResultsInput, CbtTestUpdateWithoutResultsInput>, CbtTestUncheckedUpdateWithoutResultsInput>
  }

  export type StudentUpdateOneRequiredWithoutCbtResultsNestedInput = {
    create?: XOR<StudentCreateWithoutCbtResultsInput, StudentUncheckedCreateWithoutCbtResultsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCbtResultsInput
    upsert?: StudentUpsertWithoutCbtResultsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCbtResultsInput, StudentUpdateWithoutCbtResultsInput>, StudentUncheckedUpdateWithoutCbtResultsInput>
  }

  export type StudentCreateNestedOneWithoutPermissionSlipsInput = {
    create?: XOR<StudentCreateWithoutPermissionSlipsInput, StudentUncheckedCreateWithoutPermissionSlipsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPermissionSlipsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneWithoutPermissionSlipsNestedInput = {
    create?: XOR<StudentCreateWithoutPermissionSlipsInput, StudentUncheckedCreateWithoutPermissionSlipsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutPermissionSlipsInput
    upsert?: StudentUpsertWithoutPermissionSlipsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutPermissionSlipsInput, StudentUpdateWithoutPermissionSlipsInput>, StudentUncheckedUpdateWithoutPermissionSlipsInput>
  }

  export type TeacherCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<TeacherCreateWithoutAppointmentsInput, TeacherUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAppointmentsInput
    connect?: TeacherWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ParentCreateWithoutAppointmentsInput, ParentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutAppointmentsInput
    connect?: ParentWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<TeacherCreateWithoutAppointmentsInput, TeacherUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAppointmentsInput
    upsert?: TeacherUpsertWithoutAppointmentsInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAppointmentsInput, TeacherUpdateWithoutAppointmentsInput>, TeacherUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ParentUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<ParentCreateWithoutAppointmentsInput, ParentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutAppointmentsInput
    upsert?: ParentUpsertWithoutAppointmentsInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutAppointmentsInput, ParentUpdateWithoutAppointmentsInput>, ParentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TeacherCreateNestedOneWithoutCreatedAiGamesInput = {
    create?: XOR<TeacherCreateWithoutCreatedAiGamesInput, TeacherUncheckedCreateWithoutCreatedAiGamesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedAiGamesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutCreatedAiGamesNestedInput = {
    create?: XOR<TeacherCreateWithoutCreatedAiGamesInput, TeacherUncheckedCreateWithoutCreatedAiGamesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutCreatedAiGamesInput
    upsert?: TeacherUpsertWithoutCreatedAiGamesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutCreatedAiGamesInput, TeacherUpdateWithoutCreatedAiGamesInput>, TeacherUncheckedUpdateWithoutCreatedAiGamesInput>
  }

  export type TeacherCreateNestedOneWithoutLessonPlansInput = {
    create?: XOR<TeacherCreateWithoutLessonPlansInput, TeacherUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonPlansInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutLessonPlansNestedInput = {
    create?: XOR<TeacherCreateWithoutLessonPlansInput, TeacherUncheckedCreateWithoutLessonPlansInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonPlansInput
    upsert?: TeacherUpsertWithoutLessonPlansInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutLessonPlansInput, TeacherUpdateWithoutLessonPlansInput>, TeacherUncheckedUpdateWithoutLessonPlansInput>
  }

  export type TeacherCreateNestedOneWithoutGeneratedResourcesInput = {
    create?: XOR<TeacherCreateWithoutGeneratedResourcesInput, TeacherUncheckedCreateWithoutGeneratedResourcesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGeneratedResourcesInput
    connect?: TeacherWhereUniqueInput
  }

  export type TeacherUpdateOneWithoutGeneratedResourcesNestedInput = {
    create?: XOR<TeacherCreateWithoutGeneratedResourcesInput, TeacherUncheckedCreateWithoutGeneratedResourcesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGeneratedResourcesInput
    upsert?: TeacherUpsertWithoutGeneratedResourcesInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutGeneratedResourcesInput, TeacherUpdateWithoutGeneratedResourcesInput>, TeacherUncheckedUpdateWithoutGeneratedResourcesInput>
  }

  export type StudentCreateNestedOneWithoutReportCardsInput = {
    create?: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneWithoutReportCardsNestedInput = {
    create?: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardsInput
    upsert?: StudentUpsertWithoutReportCardsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReportCardsInput, StudentUpdateWithoutReportCardsInput>, StudentUncheckedUpdateWithoutReportCardsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StudentCreateWithoutUserInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ParentChildCreateNestedManyWithoutParentInput
    appointments?: AppointmentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ParentChildUncheckedCreateNestedManyWithoutParentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateWithoutSenderInput = {
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    conversationId: number
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    role?: string | null
    joinedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    conversationId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    relatedId?: number | null
    student?: StudentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    studentId?: number | null
    relatedId?: number | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutUserInput = {
    id?: string
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ComplaintUncheckedCreateWithoutUserInput = {
    id?: string
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput>
  }

  export type ComplaintCreateManyUserInputEnvelope = {
    data: ComplaintCreateManyUserInput | ComplaintCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ParentChildUpdateManyWithoutParentNestedInput
    appointments?: AppointmentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ParentChildUncheckedUpdateManyWithoutParentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    conversationId?: IntFilter<"Message"> | number
    senderId?: IntNullableFilter<"Message"> | number | null
    content?: StringNullableFilter<"Message"> | string | null
    type?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolNullableFilter<"Message"> | boolean | null
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    conversationId?: IntFilter<"ConversationParticipant"> | number
    userId?: IntFilter<"ConversationParticipant"> | number
    role?: StringNullableFilter<"ConversationParticipant"> | string | null
    joinedAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntNullableFilter<"Notification"> | number | null
    category?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    summary?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolNullableFilter<"Notification"> | boolean | null
    timestamp?: DateTimeFilter<"Notification"> | Date | string
    studentId?: IntNullableFilter<"Notification"> | number | null
    relatedId?: IntNullableFilter<"Notification"> | number | null
  }

  export type ComplaintUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutUserInput, ComplaintUncheckedUpdateWithoutUserInput>
    create: XOR<ComplaintCreateWithoutUserInput, ComplaintUncheckedCreateWithoutUserInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutUserInput, ComplaintUncheckedUpdateWithoutUserInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutUserInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: UuidFilter<"Complaint"> | string
    userId?: IntNullableFilter<"Complaint"> | number | null
    category?: StringFilter<"Complaint"> | string
    rating?: IntNullableFilter<"Complaint"> | number | null
    comment?: StringNullableFilter<"Complaint"> | string | null
    status?: StringNullableFilter<"Complaint"> | string | null
    timeline?: JsonNullableFilter<"Complaint">
    imageUrl?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type UserCreateWithoutStudentProfileInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentProfileInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
  }

  export type ParentChildCreateWithoutStudentInput = {
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type ParentChildUncheckedCreateWithoutStudentInput = {
    id?: number
    parentId: number
  }

  export type ParentChildCreateOrConnectWithoutStudentInput = {
    where: ParentChildWhereUniqueInput
    create: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput>
  }

  export type ParentChildCreateManyStudentInputEnvelope = {
    data: ParentChildCreateManyStudentInput | ParentChildCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAttendanceCreateWithoutStudentInput = {
    date: Date | string
    status: string
    createdAt?: Date | string
  }

  export type StudentAttendanceUncheckedCreateWithoutStudentInput = {
    id?: number
    date: Date | string
    status: string
    createdAt?: Date | string
  }

  export type StudentAttendanceCreateOrConnectWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceCreateManyStudentInputEnvelope = {
    data: StudentAttendanceCreateManyStudentInput | StudentAttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicPerformanceCreateWithoutStudentInput = {
    subject: string
    score?: number | null
    term: string
    session?: string | null
  }

  export type AcademicPerformanceUncheckedCreateWithoutStudentInput = {
    id?: number
    subject: string
    score?: number | null
    term: string
    session?: string | null
  }

  export type AcademicPerformanceCreateOrConnectWithoutStudentInput = {
    where: AcademicPerformanceWhereUniqueInput
    create: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput>
  }

  export type AcademicPerformanceCreateManyStudentInputEnvelope = {
    data: AcademicPerformanceCreateManyStudentInput | AcademicPerformanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorRecordCreateWithoutStudentInput = {
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
  }

  export type BehaviorRecordUncheckedCreateWithoutStudentInput = {
    id?: number
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
  }

  export type BehaviorRecordCreateOrConnectWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    create: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput>
  }

  export type BehaviorRecordCreateManyStudentInputEnvelope = {
    data: BehaviorRecordCreateManyStudentInput | BehaviorRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutStudentInput = {
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutStudentInput = {
    id?: number
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutStudentInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput>
  }

  export type BadgeCreateManyStudentInputEnvelope = {
    data: BadgeCreateManyStudentInput | BadgeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutStudentInput = {
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
  }

  export type CertificateUncheckedCreateWithoutStudentInput = {
    id?: number
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
  }

  export type CertificateCreateOrConnectWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateCreateManyStudentInputEnvelope = {
    data: CertificateCreateManyStudentInput | CertificateCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AwardCreateWithoutStudentInput = {
    name: string
    description?: string | null
    date?: Date | string | null
  }

  export type AwardUncheckedCreateWithoutStudentInput = {
    id?: number
    name: string
    description?: string | null
    date?: Date | string | null
  }

  export type AwardCreateOrConnectWithoutStudentInput = {
    where: AwardWhereUniqueInput
    create: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput>
  }

  export type AwardCreateManyStudentInputEnvelope = {
    data: AwardCreateManyStudentInput | AwardCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutStudentInput = {
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutStudentInput = {
    id?: number
    assignmentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type SubmissionCreateOrConnectWithoutStudentInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput>
  }

  export type SubmissionCreateManyStudentInputEnvelope = {
    data: SubmissionCreateManyStudentInput | SubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentFeeCreateWithoutStudentInput = {
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
    payments?: FeePaymentCreateNestedManyWithoutFeeInput
  }

  export type StudentFeeUncheckedCreateWithoutStudentInput = {
    id?: number
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
    payments?: FeePaymentUncheckedCreateNestedManyWithoutFeeInput
  }

  export type StudentFeeCreateOrConnectWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput>
  }

  export type StudentFeeCreateManyStudentInputEnvelope = {
    data: StudentFeeCreateManyStudentInput | StudentFeeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CbtResultCreateWithoutStudentInput = {
    score: number
    totalQuestions: number
    submittedAt?: Date | string
    test: CbtTestCreateNestedOneWithoutResultsInput
  }

  export type CbtResultUncheckedCreateWithoutStudentInput = {
    id?: number
    testId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type CbtResultCreateOrConnectWithoutStudentInput = {
    where: CbtResultWhereUniqueInput
    create: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput>
  }

  export type CbtResultCreateManyStudentInputEnvelope = {
    data: CbtResultCreateManyStudentInput | CbtResultCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PermissionSlipCreateWithoutStudentInput = {
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
  }

  export type PermissionSlipUncheckedCreateWithoutStudentInput = {
    id?: number
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
  }

  export type PermissionSlipCreateOrConnectWithoutStudentInput = {
    where: PermissionSlipWhereUniqueInput
    create: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput>
  }

  export type PermissionSlipCreateManyStudentInputEnvelope = {
    data: PermissionSlipCreateManyStudentInput | PermissionSlipCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ReportCardCreateWithoutStudentInput = {
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ReportCardUncheckedCreateWithoutStudentInput = {
    id?: number
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ReportCardCreateOrConnectWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardCreateManyStudentInputEnvelope = {
    data: ReportCardCreateManyStudentInput | ReportCardCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type HealthLogCreateWithoutStudentInput = {
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
  }

  export type HealthLogUncheckedCreateWithoutStudentInput = {
    id?: number
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
  }

  export type HealthLogCreateOrConnectWithoutStudentInput = {
    where: HealthLogWhereUniqueInput
    create: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput>
  }

  export type HealthLogCreateManyStudentInputEnvelope = {
    data: HealthLogCreateManyStudentInput | HealthLogCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutStudentInput = {
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    relatedId?: number | null
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutStudentInput = {
    id?: number
    userId?: number | null
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    relatedId?: number | null
  }

  export type NotificationCreateOrConnectWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput>
  }

  export type NotificationCreateManyStudentInputEnvelope = {
    data: NotificationCreateManyStudentInput | NotificationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentProfileInput = {
    update: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type UserUpdateWithoutStudentProfileInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ParentChildUpsertWithWhereUniqueWithoutStudentInput = {
    where: ParentChildWhereUniqueInput
    update: XOR<ParentChildUpdateWithoutStudentInput, ParentChildUncheckedUpdateWithoutStudentInput>
    create: XOR<ParentChildCreateWithoutStudentInput, ParentChildUncheckedCreateWithoutStudentInput>
  }

  export type ParentChildUpdateWithWhereUniqueWithoutStudentInput = {
    where: ParentChildWhereUniqueInput
    data: XOR<ParentChildUpdateWithoutStudentInput, ParentChildUncheckedUpdateWithoutStudentInput>
  }

  export type ParentChildUpdateManyWithWhereWithoutStudentInput = {
    where: ParentChildScalarWhereInput
    data: XOR<ParentChildUpdateManyMutationInput, ParentChildUncheckedUpdateManyWithoutStudentInput>
  }

  export type ParentChildScalarWhereInput = {
    AND?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
    OR?: ParentChildScalarWhereInput[]
    NOT?: ParentChildScalarWhereInput | ParentChildScalarWhereInput[]
    id?: IntFilter<"ParentChild"> | number
    parentId?: IntFilter<"ParentChild"> | number
    studentId?: IntFilter<"ParentChild"> | number
  }

  export type StudentAttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    update: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAttendanceCreateWithoutStudentInput, StudentAttendanceUncheckedCreateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAttendanceWhereUniqueInput
    data: XOR<StudentAttendanceUpdateWithoutStudentInput, StudentAttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAttendanceScalarWhereInput
    data: XOR<StudentAttendanceUpdateManyMutationInput, StudentAttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAttendanceScalarWhereInput = {
    AND?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    OR?: StudentAttendanceScalarWhereInput[]
    NOT?: StudentAttendanceScalarWhereInput | StudentAttendanceScalarWhereInput[]
    id?: IntFilter<"StudentAttendance"> | number
    studentId?: IntFilter<"StudentAttendance"> | number
    date?: DateTimeFilter<"StudentAttendance"> | Date | string
    status?: StringFilter<"StudentAttendance"> | string
    createdAt?: DateTimeFilter<"StudentAttendance"> | Date | string
  }

  export type AcademicPerformanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AcademicPerformanceWhereUniqueInput
    update: XOR<AcademicPerformanceUpdateWithoutStudentInput, AcademicPerformanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AcademicPerformanceCreateWithoutStudentInput, AcademicPerformanceUncheckedCreateWithoutStudentInput>
  }

  export type AcademicPerformanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AcademicPerformanceWhereUniqueInput
    data: XOR<AcademicPerformanceUpdateWithoutStudentInput, AcademicPerformanceUncheckedUpdateWithoutStudentInput>
  }

  export type AcademicPerformanceUpdateManyWithWhereWithoutStudentInput = {
    where: AcademicPerformanceScalarWhereInput
    data: XOR<AcademicPerformanceUpdateManyMutationInput, AcademicPerformanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AcademicPerformanceScalarWhereInput = {
    AND?: AcademicPerformanceScalarWhereInput | AcademicPerformanceScalarWhereInput[]
    OR?: AcademicPerformanceScalarWhereInput[]
    NOT?: AcademicPerformanceScalarWhereInput | AcademicPerformanceScalarWhereInput[]
    id?: IntFilter<"AcademicPerformance"> | number
    studentId?: IntFilter<"AcademicPerformance"> | number
    subject?: StringFilter<"AcademicPerformance"> | string
    score?: IntNullableFilter<"AcademicPerformance"> | number | null
    term?: StringFilter<"AcademicPerformance"> | string
    session?: StringNullableFilter<"AcademicPerformance"> | string | null
  }

  export type BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    update: XOR<BehaviorRecordUpdateWithoutStudentInput, BehaviorRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput>
  }

  export type BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    data: XOR<BehaviorRecordUpdateWithoutStudentInput, BehaviorRecordUncheckedUpdateWithoutStudentInput>
  }

  export type BehaviorRecordUpdateManyWithWhereWithoutStudentInput = {
    where: BehaviorRecordScalarWhereInput
    data: XOR<BehaviorRecordUpdateManyMutationInput, BehaviorRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type BehaviorRecordScalarWhereInput = {
    AND?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
    OR?: BehaviorRecordScalarWhereInput[]
    NOT?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
    id?: IntFilter<"BehaviorRecord"> | number
    studentId?: IntFilter<"BehaviorRecord"> | number
    type?: StringFilter<"BehaviorRecord"> | string
    title?: StringFilter<"BehaviorRecord"> | string
    summary?: StringNullableFilter<"BehaviorRecord"> | string | null
    timestamp?: DateTimeFilter<"BehaviorRecord"> | Date | string
  }

  export type BadgeUpsertWithWhereUniqueWithoutStudentInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutStudentInput, BadgeUncheckedUpdateWithoutStudentInput>
    create: XOR<BadgeCreateWithoutStudentInput, BadgeUncheckedCreateWithoutStudentInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutStudentInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutStudentInput, BadgeUncheckedUpdateWithoutStudentInput>
  }

  export type BadgeUpdateManyWithWhereWithoutStudentInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutStudentInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: IntFilter<"Badge"> | number
    studentId?: IntFilter<"Badge"> | number
    name?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    iconName?: StringNullableFilter<"Badge"> | string | null
    color?: StringNullableFilter<"Badge"> | string | null
    awardedAt?: DateTimeFilter<"Badge"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
  }

  export type CertificateUpdateManyWithWhereWithoutStudentInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutStudentInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: IntFilter<"Certificate"> | number
    studentId?: IntFilter<"Certificate"> | number
    name?: StringFilter<"Certificate"> | string
    issuer?: StringNullableFilter<"Certificate"> | string | null
    fileUrl?: StringNullableFilter<"Certificate"> | string | null
    issuedDate?: DateTimeNullableFilter<"Certificate"> | Date | string | null
  }

  export type AwardUpsertWithWhereUniqueWithoutStudentInput = {
    where: AwardWhereUniqueInput
    update: XOR<AwardUpdateWithoutStudentInput, AwardUncheckedUpdateWithoutStudentInput>
    create: XOR<AwardCreateWithoutStudentInput, AwardUncheckedCreateWithoutStudentInput>
  }

  export type AwardUpdateWithWhereUniqueWithoutStudentInput = {
    where: AwardWhereUniqueInput
    data: XOR<AwardUpdateWithoutStudentInput, AwardUncheckedUpdateWithoutStudentInput>
  }

  export type AwardUpdateManyWithWhereWithoutStudentInput = {
    where: AwardScalarWhereInput
    data: XOR<AwardUpdateManyMutationInput, AwardUncheckedUpdateManyWithoutStudentInput>
  }

  export type AwardScalarWhereInput = {
    AND?: AwardScalarWhereInput | AwardScalarWhereInput[]
    OR?: AwardScalarWhereInput[]
    NOT?: AwardScalarWhereInput | AwardScalarWhereInput[]
    id?: IntFilter<"Award"> | number
    studentId?: IntFilter<"Award"> | number
    name?: StringFilter<"Award"> | string
    description?: StringNullableFilter<"Award"> | string | null
    date?: DateTimeNullableFilter<"Award"> | Date | string | null
  }

  export type SubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutStudentInput, SubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<SubmissionCreateWithoutStudentInput, SubmissionUncheckedCreateWithoutStudentInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutStudentInput, SubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    OR?: SubmissionScalarWhereInput[]
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    id?: IntFilter<"Submission"> | number
    assignmentId?: IntFilter<"Submission"> | number
    studentId?: IntFilter<"Submission"> | number
    submittedAt?: DateTimeFilter<"Submission"> | Date | string
    isLate?: BoolNullableFilter<"Submission"> | boolean | null
    status?: StringNullableFilter<"Submission"> | string | null
    grade?: IntNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    textSubmission?: StringNullableFilter<"Submission"> | string | null
    fileUrl?: StringNullableFilter<"Submission"> | string | null
  }

  export type StudentFeeUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    update: XOR<StudentFeeUpdateWithoutStudentInput, StudentFeeUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput>
  }

  export type StudentFeeUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    data: XOR<StudentFeeUpdateWithoutStudentInput, StudentFeeUncheckedUpdateWithoutStudentInput>
  }

  export type StudentFeeUpdateManyWithWhereWithoutStudentInput = {
    where: StudentFeeScalarWhereInput
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentFeeScalarWhereInput = {
    AND?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
    OR?: StudentFeeScalarWhereInput[]
    NOT?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
    id?: IntFilter<"StudentFee"> | number
    studentId?: IntFilter<"StudentFee"> | number
    totalFee?: DecimalFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string
    paidAmount?: DecimalNullableFilter<"StudentFee"> | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    status?: StringNullableFilter<"StudentFee"> | string | null
  }

  export type CbtResultUpsertWithWhereUniqueWithoutStudentInput = {
    where: CbtResultWhereUniqueInput
    update: XOR<CbtResultUpdateWithoutStudentInput, CbtResultUncheckedUpdateWithoutStudentInput>
    create: XOR<CbtResultCreateWithoutStudentInput, CbtResultUncheckedCreateWithoutStudentInput>
  }

  export type CbtResultUpdateWithWhereUniqueWithoutStudentInput = {
    where: CbtResultWhereUniqueInput
    data: XOR<CbtResultUpdateWithoutStudentInput, CbtResultUncheckedUpdateWithoutStudentInput>
  }

  export type CbtResultUpdateManyWithWhereWithoutStudentInput = {
    where: CbtResultScalarWhereInput
    data: XOR<CbtResultUpdateManyMutationInput, CbtResultUncheckedUpdateManyWithoutStudentInput>
  }

  export type CbtResultScalarWhereInput = {
    AND?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
    OR?: CbtResultScalarWhereInput[]
    NOT?: CbtResultScalarWhereInput | CbtResultScalarWhereInput[]
    id?: IntFilter<"CbtResult"> | number
    testId?: IntFilter<"CbtResult"> | number
    studentId?: IntFilter<"CbtResult"> | number
    score?: IntFilter<"CbtResult"> | number
    totalQuestions?: IntFilter<"CbtResult"> | number
    submittedAt?: DateTimeFilter<"CbtResult"> | Date | string
  }

  export type PermissionSlipUpsertWithWhereUniqueWithoutStudentInput = {
    where: PermissionSlipWhereUniqueInput
    update: XOR<PermissionSlipUpdateWithoutStudentInput, PermissionSlipUncheckedUpdateWithoutStudentInput>
    create: XOR<PermissionSlipCreateWithoutStudentInput, PermissionSlipUncheckedCreateWithoutStudentInput>
  }

  export type PermissionSlipUpdateWithWhereUniqueWithoutStudentInput = {
    where: PermissionSlipWhereUniqueInput
    data: XOR<PermissionSlipUpdateWithoutStudentInput, PermissionSlipUncheckedUpdateWithoutStudentInput>
  }

  export type PermissionSlipUpdateManyWithWhereWithoutStudentInput = {
    where: PermissionSlipScalarWhereInput
    data: XOR<PermissionSlipUpdateManyMutationInput, PermissionSlipUncheckedUpdateManyWithoutStudentInput>
  }

  export type PermissionSlipScalarWhereInput = {
    AND?: PermissionSlipScalarWhereInput | PermissionSlipScalarWhereInput[]
    OR?: PermissionSlipScalarWhereInput[]
    NOT?: PermissionSlipScalarWhereInput | PermissionSlipScalarWhereInput[]
    id?: IntFilter<"PermissionSlip"> | number
    studentId?: IntNullableFilter<"PermissionSlip"> | number | null
    title?: StringFilter<"PermissionSlip"> | string
    description?: StringNullableFilter<"PermissionSlip"> | string | null
    location?: StringNullableFilter<"PermissionSlip"> | string | null
    date?: DateTimeNullableFilter<"PermissionSlip"> | Date | string | null
    status?: StringNullableFilter<"PermissionSlip"> | string | null
  }

  export type ReportCardUpsertWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    update: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardUpdateWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    data: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
  }

  export type ReportCardUpdateManyWithWhereWithoutStudentInput = {
    where: ReportCardScalarWhereInput
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyWithoutStudentInput>
  }

  export type ReportCardScalarWhereInput = {
    AND?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    OR?: ReportCardScalarWhereInput[]
    NOT?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    id?: IntFilter<"ReportCard"> | number
    studentId?: IntNullableFilter<"ReportCard"> | number | null
    session?: StringFilter<"ReportCard"> | string
    term?: StringFilter<"ReportCard"> | string
    status?: StringNullableFilter<"ReportCard"> | string | null
    classTeacherComment?: StringNullableFilter<"ReportCard"> | string | null
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    gradeAverage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    position?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    attendancePercentage?: DecimalNullableFilter<"ReportCard"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullableFilter<"ReportCard">
    psychomotor?: JsonNullableFilter<"ReportCard">
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    publishedAt?: DateTimeNullableFilter<"ReportCard"> | Date | string | null
  }

  export type HealthLogUpsertWithWhereUniqueWithoutStudentInput = {
    where: HealthLogWhereUniqueInput
    update: XOR<HealthLogUpdateWithoutStudentInput, HealthLogUncheckedUpdateWithoutStudentInput>
    create: XOR<HealthLogCreateWithoutStudentInput, HealthLogUncheckedCreateWithoutStudentInput>
  }

  export type HealthLogUpdateWithWhereUniqueWithoutStudentInput = {
    where: HealthLogWhereUniqueInput
    data: XOR<HealthLogUpdateWithoutStudentInput, HealthLogUncheckedUpdateWithoutStudentInput>
  }

  export type HealthLogUpdateManyWithWhereWithoutStudentInput = {
    where: HealthLogScalarWhereInput
    data: XOR<HealthLogUpdateManyMutationInput, HealthLogUncheckedUpdateManyWithoutStudentInput>
  }

  export type HealthLogScalarWhereInput = {
    AND?: HealthLogScalarWhereInput | HealthLogScalarWhereInput[]
    OR?: HealthLogScalarWhereInput[]
    NOT?: HealthLogScalarWhereInput | HealthLogScalarWhereInput[]
    id?: IntFilter<"HealthLog"> | number
    studentId?: IntNullableFilter<"HealthLog"> | number | null
    date?: DateTimeFilter<"HealthLog"> | Date | string
    time?: StringNullableFilter<"HealthLog"> | string | null
    reason?: StringFilter<"HealthLog"> | string
    notes?: StringNullableFilter<"HealthLog"> | string | null
    parentNotified?: BoolNullableFilter<"HealthLog"> | boolean | null
    medicationAdministered?: JsonNullableFilter<"HealthLog">
    recordedBy?: StringNullableFilter<"HealthLog"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutStudentInput, NotificationUncheckedUpdateWithoutStudentInput>
    create: XOR<NotificationCreateWithoutStudentInput, NotificationUncheckedCreateWithoutStudentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutStudentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutStudentInput, NotificationUncheckedUpdateWithoutStudentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutStudentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutStudentInput>
  }

  export type UserCreateWithoutTeacherProfileInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherProfileInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
  }

  export type TeacherSubjectCreateWithoutTeacherInput = {
    subject: string
  }

  export type TeacherSubjectUncheckedCreateWithoutTeacherInput = {
    id?: number
    subject: string
  }

  export type TeacherSubjectCreateOrConnectWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectCreateManyTeacherInputEnvelope = {
    data: TeacherSubjectCreateManyTeacherInput | TeacherSubjectCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TeacherClassCreateWithoutTeacherInput = {
    className: string
  }

  export type TeacherClassUncheckedCreateWithoutTeacherInput = {
    id?: number
    className: string
  }

  export type TeacherClassCreateOrConnectWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    create: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassCreateManyTeacherInputEnvelope = {
    data: TeacherClassCreateManyTeacherInput | TeacherClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TimetableCreateWithoutTeacherInput = {
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUncheckedCreateWithoutTeacherInput = {
    id?: number
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableCreateManyTeacherInputEnvelope = {
    data: TimetableCreateManyTeacherInput | TimetableCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutTeacherInput = {
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
  }

  export type ExamUncheckedCreateWithoutTeacherInput = {
    id?: number
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
  }

  export type ExamCreateOrConnectWithoutTeacherInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput>
  }

  export type ExamCreateManyTeacherInputEnvelope = {
    data: ExamCreateManyTeacherInput | ExamCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AiGameCreateWithoutCreatorInput = {
    id?: string
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameCreateOrConnectWithoutCreatorInput = {
    where: AiGameWhereUniqueInput
    create: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput>
  }

  export type AiGameCreateManyCreatorInputEnvelope = {
    data: AiGameCreateManyCreatorInput | AiGameCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type LessonPlanCreateWithoutTeacherInput = {
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LessonPlanUncheckedCreateWithoutTeacherInput = {
    id?: number
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LessonPlanCreateOrConnectWithoutTeacherInput = {
    where: LessonPlanWhereUniqueInput
    create: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput>
  }

  export type LessonPlanCreateManyTeacherInputEnvelope = {
    data: LessonPlanCreateManyTeacherInput | LessonPlanCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedResourceCreateWithoutTeacherInput = {
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type GeneratedResourceUncheckedCreateWithoutTeacherInput = {
    id?: number
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type GeneratedResourceCreateOrConnectWithoutTeacherInput = {
    where: GeneratedResourceWhereUniqueInput
    create: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput>
  }

  export type GeneratedResourceCreateManyTeacherInputEnvelope = {
    data: GeneratedResourceCreateManyTeacherInput | GeneratedResourceCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutTeacherInput = {
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
    parent?: ParentCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutTeacherInput = {
    id?: number
    parentId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutTeacherInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput>
  }

  export type AppointmentCreateManyTeacherInputEnvelope = {
    data: AppointmentCreateManyTeacherInput | AppointmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherProfileInput = {
    update: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type UserUpdateWithoutTeacherProfileInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherSubjectScalarWhereInput = {
    AND?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    OR?: TeacherSubjectScalarWhereInput[]
    NOT?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    id?: IntFilter<"TeacherSubject"> | number
    teacherId?: IntFilter<"TeacherSubject"> | number
    subject?: StringFilter<"TeacherSubject"> | string
  }

  export type TeacherClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    update: XOR<TeacherClassUpdateWithoutTeacherInput, TeacherClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    data: XOR<TeacherClassUpdateWithoutTeacherInput, TeacherClassUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherClassUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherClassScalarWhereInput
    data: XOR<TeacherClassUpdateManyMutationInput, TeacherClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherClassScalarWhereInput = {
    AND?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
    OR?: TeacherClassScalarWhereInput[]
    NOT?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
    id?: IntFilter<"TeacherClass"> | number
    teacherId?: IntFilter<"TeacherClass"> | number
    className?: StringFilter<"TeacherClass"> | string
  }

  export type TimetableUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutTeacherInput, TimetableUncheckedUpdateWithoutTeacherInput>
    create: XOR<TimetableCreateWithoutTeacherInput, TimetableUncheckedCreateWithoutTeacherInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutTeacherInput, TimetableUncheckedUpdateWithoutTeacherInput>
  }

  export type TimetableUpdateManyWithWhereWithoutTeacherInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TimetableScalarWhereInput = {
    AND?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    OR?: TimetableScalarWhereInput[]
    NOT?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    id?: IntFilter<"Timetable"> | number
    day?: StringFilter<"Timetable"> | string
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    className?: StringFilter<"Timetable"> | string
    teacherId?: IntNullableFilter<"Timetable"> | number | null
    status?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutTeacherInput, ExamUncheckedUpdateWithoutTeacherInput>
    create: XOR<ExamCreateWithoutTeacherInput, ExamUncheckedCreateWithoutTeacherInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutTeacherInput, ExamUncheckedUpdateWithoutTeacherInput>
  }

  export type ExamUpdateManyWithWhereWithoutTeacherInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: IntFilter<"Exam"> | number
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    time?: StringFilter<"Exam"> | string
    className?: StringFilter<"Exam"> | string
    subject?: StringFilter<"Exam"> | string
    isPublished?: BoolNullableFilter<"Exam"> | boolean | null
    teacherId?: IntNullableFilter<"Exam"> | number | null
  }

  export type AiGameUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AiGameWhereUniqueInput
    update: XOR<AiGameUpdateWithoutCreatorInput, AiGameUncheckedUpdateWithoutCreatorInput>
    create: XOR<AiGameCreateWithoutCreatorInput, AiGameUncheckedCreateWithoutCreatorInput>
  }

  export type AiGameUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AiGameWhereUniqueInput
    data: XOR<AiGameUpdateWithoutCreatorInput, AiGameUncheckedUpdateWithoutCreatorInput>
  }

  export type AiGameUpdateManyWithWhereWithoutCreatorInput = {
    where: AiGameScalarWhereInput
    data: XOR<AiGameUpdateManyMutationInput, AiGameUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AiGameScalarWhereInput = {
    AND?: AiGameScalarWhereInput | AiGameScalarWhereInput[]
    OR?: AiGameScalarWhereInput[]
    NOT?: AiGameScalarWhereInput | AiGameScalarWhereInput[]
    id?: UuidFilter<"AiGame"> | string
    creatorId?: IntNullableFilter<"AiGame"> | number | null
    title?: StringFilter<"AiGame"> | string
    subject?: StringNullableFilter<"AiGame"> | string | null
    difficultyLevel?: StringNullableFilter<"AiGame"> | string | null
    status?: StringNullableFilter<"AiGame"> | string | null
    questions?: JsonNullableFilter<"AiGame">
  }

  export type LessonPlanUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonPlanWhereUniqueInput
    update: XOR<LessonPlanUpdateWithoutTeacherInput, LessonPlanUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonPlanCreateWithoutTeacherInput, LessonPlanUncheckedCreateWithoutTeacherInput>
  }

  export type LessonPlanUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonPlanWhereUniqueInput
    data: XOR<LessonPlanUpdateWithoutTeacherInput, LessonPlanUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonPlanUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonPlanScalarWhereInput
    data: XOR<LessonPlanUpdateManyMutationInput, LessonPlanUncheckedUpdateManyWithoutTeacherInput>
  }

  export type LessonPlanScalarWhereInput = {
    AND?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
    OR?: LessonPlanScalarWhereInput[]
    NOT?: LessonPlanScalarWhereInput | LessonPlanScalarWhereInput[]
    id?: IntFilter<"LessonPlan"> | number
    teacherId?: IntNullableFilter<"LessonPlan"> | number | null
    subject?: StringNullableFilter<"LessonPlan"> | string | null
    grade?: StringNullableFilter<"LessonPlan"> | string | null
    topic?: StringNullableFilter<"LessonPlan"> | string | null
    content?: JsonNullableFilter<"LessonPlan">
    createdAt?: DateTimeFilter<"LessonPlan"> | Date | string
  }

  export type GeneratedResourceUpsertWithWhereUniqueWithoutTeacherInput = {
    where: GeneratedResourceWhereUniqueInput
    update: XOR<GeneratedResourceUpdateWithoutTeacherInput, GeneratedResourceUncheckedUpdateWithoutTeacherInput>
    create: XOR<GeneratedResourceCreateWithoutTeacherInput, GeneratedResourceUncheckedCreateWithoutTeacherInput>
  }

  export type GeneratedResourceUpdateWithWhereUniqueWithoutTeacherInput = {
    where: GeneratedResourceWhereUniqueInput
    data: XOR<GeneratedResourceUpdateWithoutTeacherInput, GeneratedResourceUncheckedUpdateWithoutTeacherInput>
  }

  export type GeneratedResourceUpdateManyWithWhereWithoutTeacherInput = {
    where: GeneratedResourceScalarWhereInput
    data: XOR<GeneratedResourceUpdateManyMutationInput, GeneratedResourceUncheckedUpdateManyWithoutTeacherInput>
  }

  export type GeneratedResourceScalarWhereInput = {
    AND?: GeneratedResourceScalarWhereInput | GeneratedResourceScalarWhereInput[]
    OR?: GeneratedResourceScalarWhereInput[]
    NOT?: GeneratedResourceScalarWhereInput | GeneratedResourceScalarWhereInput[]
    id?: IntFilter<"GeneratedResource"> | number
    teacherId?: IntNullableFilter<"GeneratedResource"> | number | null
    subject?: StringNullableFilter<"GeneratedResource"> | string | null
    className?: StringNullableFilter<"GeneratedResource"> | string | null
    term?: StringNullableFilter<"GeneratedResource"> | string | null
    schemeContent?: JsonNullableFilter<"GeneratedResource">
    lessonPlansContent?: JsonNullableFilter<"GeneratedResource">
    updatedAt?: DateTimeFilter<"GeneratedResource"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutTeacherInput, AppointmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<AppointmentCreateWithoutTeacherInput, AppointmentUncheckedCreateWithoutTeacherInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutTeacherInput, AppointmentUncheckedUpdateWithoutTeacherInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutTeacherInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    teacherId?: IntNullableFilter<"Appointment"> | number | null
    parentId?: IntNullableFilter<"Appointment"> | number | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    status?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type UserCreateWithoutParentProfileInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentProfileInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentProfileInput, UserUncheckedCreateWithoutParentProfileInput>
  }

  export type ParentChildCreateWithoutParentInput = {
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type ParentChildUncheckedCreateWithoutParentInput = {
    id?: number
    studentId: number
  }

  export type ParentChildCreateOrConnectWithoutParentInput = {
    where: ParentChildWhereUniqueInput
    create: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput>
  }

  export type ParentChildCreateManyParentInputEnvelope = {
    data: ParentChildCreateManyParentInput | ParentChildCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutParentInput = {
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutParentInput = {
    id?: number
    teacherId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutParentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput>
  }

  export type AppointmentCreateManyParentInputEnvelope = {
    data: AppointmentCreateManyParentInput | AppointmentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParentProfileInput = {
    update: XOR<UserUpdateWithoutParentProfileInput, UserUncheckedUpdateWithoutParentProfileInput>
    create: XOR<UserCreateWithoutParentProfileInput, UserUncheckedCreateWithoutParentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentProfileInput, UserUncheckedUpdateWithoutParentProfileInput>
  }

  export type UserUpdateWithoutParentProfileInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ParentChildUpsertWithWhereUniqueWithoutParentInput = {
    where: ParentChildWhereUniqueInput
    update: XOR<ParentChildUpdateWithoutParentInput, ParentChildUncheckedUpdateWithoutParentInput>
    create: XOR<ParentChildCreateWithoutParentInput, ParentChildUncheckedCreateWithoutParentInput>
  }

  export type ParentChildUpdateWithWhereUniqueWithoutParentInput = {
    where: ParentChildWhereUniqueInput
    data: XOR<ParentChildUpdateWithoutParentInput, ParentChildUncheckedUpdateWithoutParentInput>
  }

  export type ParentChildUpdateManyWithWhereWithoutParentInput = {
    where: ParentChildScalarWhereInput
    data: XOR<ParentChildUpdateManyMutationInput, ParentChildUncheckedUpdateManyWithoutParentInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutParentInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutParentInput, AppointmentUncheckedUpdateWithoutParentInput>
    create: XOR<AppointmentCreateWithoutParentInput, AppointmentUncheckedCreateWithoutParentInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutParentInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutParentInput, AppointmentUncheckedUpdateWithoutParentInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutParentInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutParentInput>
  }

  export type ParentCreateWithoutChildrenInput = {
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutParentProfileInput
    appointments?: AppointmentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutChildrenInput = {
    id?: number
    userId?: number | null
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type StudentCreateWithoutParentsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type ParentUpsertWithoutChildrenInput = {
    update: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type ParentUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherCreateWithoutSubjectsInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSubjectsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSubjectsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
  }

  export type TeacherUpsertWithoutSubjectsInput = {
    update: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutClassesInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
  }

  export type TeacherUpsertWithoutClassesInput = {
    update: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutTimetableEntriesInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutTimetableEntriesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutTimetableEntriesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutTimetableEntriesInput, TeacherUncheckedCreateWithoutTimetableEntriesInput>
  }

  export type TeacherUpsertWithoutTimetableEntriesInput = {
    update: XOR<TeacherUpdateWithoutTimetableEntriesInput, TeacherUncheckedUpdateWithoutTimetableEntriesInput>
    create: XOR<TeacherCreateWithoutTimetableEntriesInput, TeacherUncheckedCreateWithoutTimetableEntriesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutTimetableEntriesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutTimetableEntriesInput, TeacherUncheckedUpdateWithoutTimetableEntriesInput>
  }

  export type TeacherUpdateWithoutTimetableEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutTimetableEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentCreateWithoutAttendanceRecordsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StudentUpsertWithoutAttendanceRecordsInput = {
    update: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentUpdateWithoutAttendanceRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutAcademicPerformanceInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicPerformanceInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicPerformanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicPerformanceInput, StudentUncheckedCreateWithoutAcademicPerformanceInput>
  }

  export type StudentUpsertWithoutAcademicPerformanceInput = {
    update: XOR<StudentUpdateWithoutAcademicPerformanceInput, StudentUncheckedUpdateWithoutAcademicPerformanceInput>
    create: XOR<StudentCreateWithoutAcademicPerformanceInput, StudentUncheckedCreateWithoutAcademicPerformanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAcademicPerformanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAcademicPerformanceInput, StudentUncheckedUpdateWithoutAcademicPerformanceInput>
  }

  export type StudentUpdateWithoutAcademicPerformanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicPerformanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutBehaviorRecordsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutBehaviorRecordsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutBehaviorRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
  }

  export type StudentUpsertWithoutBehaviorRecordsInput = {
    update: XOR<StudentUpdateWithoutBehaviorRecordsInput, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
    create: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutBehaviorRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutBehaviorRecordsInput, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type StudentUpdateWithoutBehaviorRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutBehaviorRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutBadgesInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutBadgesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutBadgesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBadgesInput, StudentUncheckedCreateWithoutBadgesInput>
  }

  export type StudentUpsertWithoutBadgesInput = {
    update: XOR<StudentUpdateWithoutBadgesInput, StudentUncheckedUpdateWithoutBadgesInput>
    create: XOR<StudentCreateWithoutBadgesInput, StudentUncheckedCreateWithoutBadgesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutBadgesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutBadgesInput, StudentUncheckedUpdateWithoutBadgesInput>
  }

  export type StudentUpdateWithoutBadgesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutCertificatesInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCertificatesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCertificatesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
  }

  export type StudentUpsertWithoutCertificatesInput = {
    update: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentUpdateWithoutCertificatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCertificatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutAwardsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAwardsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAwardsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAwardsInput, StudentUncheckedCreateWithoutAwardsInput>
  }

  export type StudentUpsertWithoutAwardsInput = {
    update: XOR<StudentUpdateWithoutAwardsInput, StudentUncheckedUpdateWithoutAwardsInput>
    create: XOR<StudentCreateWithoutAwardsInput, StudentUncheckedCreateWithoutAwardsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAwardsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAwardsInput, StudentUncheckedUpdateWithoutAwardsInput>
  }

  export type StudentUpdateWithoutAwardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAwardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubmissionCreateWithoutAssignmentInput = {
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
    student: StudentCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutAssignmentInput = {
    id?: number
    studentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type SubmissionCreateOrConnectWithoutAssignmentInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type SubmissionCreateManyAssignmentInputEnvelope = {
    data: SubmissionCreateManyAssignmentInput | SubmissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutAssignmentInput, SubmissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<SubmissionCreateWithoutAssignmentInput, SubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutAssignmentInput, SubmissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type AssignmentCreateWithoutSubmissionsInput = {
    title: string
    description?: string | null
    className: string
    subject: string
    dueDate: Date | string
    totalStudents?: number | null
    submissionsCount?: number | null
    createdAt?: Date | string
  }

  export type AssignmentUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    title: string
    description?: string | null
    className: string
    subject: string
    dueDate: Date | string
    totalStudents?: number | null
    submissionsCount?: number | null
    createdAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutSubmissionsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
  }

  export type StudentCreateWithoutSubmissionsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSubmissionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
  }

  export type AssignmentUpsertWithoutSubmissionsInput = {
    update: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type AssignmentUpdateWithoutSubmissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    submissionsCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutSubmissionsInput = {
    update: XOR<StudentUpdateWithoutSubmissionsInput, StudentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<StudentCreateWithoutSubmissionsInput, StudentUncheckedCreateWithoutSubmissionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSubmissionsInput, StudentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentUpdateWithoutSubmissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherCreateWithoutExamsInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutExamsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutExamsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutExamsInput, TeacherUncheckedCreateWithoutExamsInput>
  }

  export type TeacherUpsertWithoutExamsInput = {
    update: XOR<TeacherUpdateWithoutExamsInput, TeacherUncheckedUpdateWithoutExamsInput>
    create: XOR<TeacherCreateWithoutExamsInput, TeacherUncheckedCreateWithoutExamsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutExamsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutExamsInput, TeacherUncheckedUpdateWithoutExamsInput>
  }

  export type TeacherUpdateWithoutExamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type StudentCreateWithoutNotificationsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutNotificationsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutNotificationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentUpsertWithoutNotificationsInput = {
    update: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StudentCreateWithoutNotificationsInput, StudentUncheckedCreateWithoutNotificationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutNotificationsInput, StudentUncheckedUpdateWithoutNotificationsInput>
  }

  export type StudentUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type MessageCreateWithoutConversationInput = {
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
    sender?: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: number
    senderId?: number | null
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    role?: string | null
    joinedAt?: Date | string | null
    user: UserCreateNestedOneWithoutConversationsParticipatedInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    userId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: number
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutConversationsParticipatedInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsParticipatedInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsParticipatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsParticipatedInput, UserUncheckedCreateWithoutConversationsParticipatedInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationsParticipatedInput = {
    update: XOR<UserUpdateWithoutConversationsParticipatedInput, UserUncheckedUpdateWithoutConversationsParticipatedInput>
    create: XOR<UserCreateWithoutConversationsParticipatedInput, UserUncheckedCreateWithoutConversationsParticipatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsParticipatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsParticipatedInput, UserUncheckedUpdateWithoutConversationsParticipatedInput>
  }

  export type UserUpdateWithoutConversationsParticipatedInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsParticipatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    type?: string
    name?: string | null
    createdAt?: Date | string
    lastMessageAt?: Date | string | null
    lastMessageText?: string | null
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesSentInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    complaints?: ComplaintCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageText?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumPostCreateWithoutTopicInput = {
    authorName: string
    content: string
    timestamp?: Date | string
  }

  export type ForumPostUncheckedCreateWithoutTopicInput = {
    id?: number
    authorName: string
    content: string
    timestamp?: Date | string
  }

  export type ForumPostCreateOrConnectWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput>
  }

  export type ForumPostCreateManyTopicInputEnvelope = {
    data: ForumPostCreateManyTopicInput | ForumPostCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ForumPostUpsertWithWhereUniqueWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutTopicInput, ForumPostUncheckedUpdateWithoutTopicInput>
    create: XOR<ForumPostCreateWithoutTopicInput, ForumPostUncheckedCreateWithoutTopicInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutTopicInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutTopicInput, ForumPostUncheckedUpdateWithoutTopicInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutTopicInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutTopicInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    OR?: ForumPostScalarWhereInput[]
    NOT?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    id?: IntFilter<"ForumPost"> | number
    topicId?: IntFilter<"ForumPost"> | number
    authorName?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    timestamp?: DateTimeFilter<"ForumPost"> | Date | string
  }

  export type ForumTopicCreateWithoutPostsInput = {
    title: string
    authorName: string
    createdAt?: Date | string
    postCount?: number | null
    lastActivity?: Date | string
  }

  export type ForumTopicUncheckedCreateWithoutPostsInput = {
    id?: number
    title: string
    authorName: string
    createdAt?: Date | string
    postCount?: number | null
    lastActivity?: Date | string
  }

  export type ForumTopicCreateOrConnectWithoutPostsInput = {
    where: ForumTopicWhereUniqueInput
    create: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
  }

  export type ForumTopicUpsertWithoutPostsInput = {
    update: XOR<ForumTopicUpdateWithoutPostsInput, ForumTopicUncheckedUpdateWithoutPostsInput>
    create: XOR<ForumTopicCreateWithoutPostsInput, ForumTopicUncheckedCreateWithoutPostsInput>
    where?: ForumTopicWhereInput
  }

  export type ForumTopicUpdateToOneWithWhereWithoutPostsInput = {
    where?: ForumTopicWhereInput
    data: XOR<ForumTopicUpdateWithoutPostsInput, ForumTopicUncheckedUpdateWithoutPostsInput>
  }

  export type ForumTopicUpdateWithoutPostsInput = {
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumTopicUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    authorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postCount?: NullableIntFieldUpdateOperationsInput | number | null
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutComplaintsInput = {
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    messagesSent?: MessageCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComplaintsInput = {
    id?: number
    supabaseUid?: string | null
    email: string
    name: string
    role: string
    avatarUrl?: string | null
    createdAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    messagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    conversationsParticipated?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComplaintsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
  }

  export type UserUpsertWithoutComplaintsInput = {
    update: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
    create: XOR<UserCreateWithoutComplaintsInput, UserUncheckedCreateWithoutComplaintsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComplaintsInput, UserUncheckedUpdateWithoutComplaintsInput>
  }

  export type UserUpdateWithoutComplaintsInput = {
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supabaseUid?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    messagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    conversationsParticipated?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BusRosterCreateWithoutDriverInput = {
    date: Date | string
    route?: BusRouteCreateNestedOneWithoutRosterInput
  }

  export type BusRosterUncheckedCreateWithoutDriverInput = {
    id?: number
    routeId?: string | null
    date: Date | string
  }

  export type BusRosterCreateOrConnectWithoutDriverInput = {
    where: BusRosterWhereUniqueInput
    create: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput>
  }

  export type BusRosterCreateManyDriverInputEnvelope = {
    data: BusRosterCreateManyDriverInput | BusRosterCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type BusRosterUpsertWithWhereUniqueWithoutDriverInput = {
    where: BusRosterWhereUniqueInput
    update: XOR<BusRosterUpdateWithoutDriverInput, BusRosterUncheckedUpdateWithoutDriverInput>
    create: XOR<BusRosterCreateWithoutDriverInput, BusRosterUncheckedCreateWithoutDriverInput>
  }

  export type BusRosterUpdateWithWhereUniqueWithoutDriverInput = {
    where: BusRosterWhereUniqueInput
    data: XOR<BusRosterUpdateWithoutDriverInput, BusRosterUncheckedUpdateWithoutDriverInput>
  }

  export type BusRosterUpdateManyWithWhereWithoutDriverInput = {
    where: BusRosterScalarWhereInput
    data: XOR<BusRosterUpdateManyMutationInput, BusRosterUncheckedUpdateManyWithoutDriverInput>
  }

  export type BusRosterScalarWhereInput = {
    AND?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
    OR?: BusRosterScalarWhereInput[]
    NOT?: BusRosterScalarWhereInput | BusRosterScalarWhereInput[]
    id?: IntFilter<"BusRoster"> | number
    routeId?: StringNullableFilter<"BusRoster"> | string | null
    driverId?: IntNullableFilter<"BusRoster"> | number | null
    date?: DateTimeFilter<"BusRoster"> | Date | string
  }

  export type BusRosterCreateWithoutRouteInput = {
    date: Date | string
    driver?: DriverCreateNestedOneWithoutRosterInput
  }

  export type BusRosterUncheckedCreateWithoutRouteInput = {
    id?: number
    driverId?: number | null
    date: Date | string
  }

  export type BusRosterCreateOrConnectWithoutRouteInput = {
    where: BusRosterWhereUniqueInput
    create: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput>
  }

  export type BusRosterCreateManyRouteInputEnvelope = {
    data: BusRosterCreateManyRouteInput | BusRosterCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type PickupPointCreateWithoutRouteInput = {
    name: string
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
  }

  export type PickupPointUncheckedCreateWithoutRouteInput = {
    id?: number
    name: string
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
  }

  export type PickupPointCreateOrConnectWithoutRouteInput = {
    where: PickupPointWhereUniqueInput
    create: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput>
  }

  export type PickupPointCreateManyRouteInputEnvelope = {
    data: PickupPointCreateManyRouteInput | PickupPointCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type BusRosterUpsertWithWhereUniqueWithoutRouteInput = {
    where: BusRosterWhereUniqueInput
    update: XOR<BusRosterUpdateWithoutRouteInput, BusRosterUncheckedUpdateWithoutRouteInput>
    create: XOR<BusRosterCreateWithoutRouteInput, BusRosterUncheckedCreateWithoutRouteInput>
  }

  export type BusRosterUpdateWithWhereUniqueWithoutRouteInput = {
    where: BusRosterWhereUniqueInput
    data: XOR<BusRosterUpdateWithoutRouteInput, BusRosterUncheckedUpdateWithoutRouteInput>
  }

  export type BusRosterUpdateManyWithWhereWithoutRouteInput = {
    where: BusRosterScalarWhereInput
    data: XOR<BusRosterUpdateManyMutationInput, BusRosterUncheckedUpdateManyWithoutRouteInput>
  }

  export type PickupPointUpsertWithWhereUniqueWithoutRouteInput = {
    where: PickupPointWhereUniqueInput
    update: XOR<PickupPointUpdateWithoutRouteInput, PickupPointUncheckedUpdateWithoutRouteInput>
    create: XOR<PickupPointCreateWithoutRouteInput, PickupPointUncheckedCreateWithoutRouteInput>
  }

  export type PickupPointUpdateWithWhereUniqueWithoutRouteInput = {
    where: PickupPointWhereUniqueInput
    data: XOR<PickupPointUpdateWithoutRouteInput, PickupPointUncheckedUpdateWithoutRouteInput>
  }

  export type PickupPointUpdateManyWithWhereWithoutRouteInput = {
    where: PickupPointScalarWhereInput
    data: XOR<PickupPointUpdateManyMutationInput, PickupPointUncheckedUpdateManyWithoutRouteInput>
  }

  export type PickupPointScalarWhereInput = {
    AND?: PickupPointScalarWhereInput | PickupPointScalarWhereInput[]
    OR?: PickupPointScalarWhereInput[]
    NOT?: PickupPointScalarWhereInput | PickupPointScalarWhereInput[]
    id?: IntFilter<"PickupPoint"> | number
    name?: StringFilter<"PickupPoint"> | string
    routeId?: StringNullableFilter<"PickupPoint"> | string | null
    lat?: FloatNullableFilter<"PickupPoint"> | number | null
    lng?: FloatNullableFilter<"PickupPoint"> | number | null
    uiPositionTop?: StringNullableFilter<"PickupPoint"> | string | null
    uiPositionLeft?: StringNullableFilter<"PickupPoint"> | string | null
    isUserStop?: BoolNullableFilter<"PickupPoint"> | boolean | null
  }

  export type BusRouteCreateWithoutRosterInput = {
    id: string
    name: string
    description?: string | null
    pickupPoints?: PickupPointCreateNestedManyWithoutRouteInput
  }

  export type BusRouteUncheckedCreateWithoutRosterInput = {
    id: string
    name: string
    description?: string | null
    pickupPoints?: PickupPointUncheckedCreateNestedManyWithoutRouteInput
  }

  export type BusRouteCreateOrConnectWithoutRosterInput = {
    where: BusRouteWhereUniqueInput
    create: XOR<BusRouteCreateWithoutRosterInput, BusRouteUncheckedCreateWithoutRosterInput>
  }

  export type DriverCreateWithoutRosterInput = {
    name: string
    phone?: string | null
    avatarUrl?: string | null
  }

  export type DriverUncheckedCreateWithoutRosterInput = {
    id?: number
    name: string
    phone?: string | null
    avatarUrl?: string | null
  }

  export type DriverCreateOrConnectWithoutRosterInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutRosterInput, DriverUncheckedCreateWithoutRosterInput>
  }

  export type BusRouteUpsertWithoutRosterInput = {
    update: XOR<BusRouteUpdateWithoutRosterInput, BusRouteUncheckedUpdateWithoutRosterInput>
    create: XOR<BusRouteCreateWithoutRosterInput, BusRouteUncheckedCreateWithoutRosterInput>
    where?: BusRouteWhereInput
  }

  export type BusRouteUpdateToOneWithWhereWithoutRosterInput = {
    where?: BusRouteWhereInput
    data: XOR<BusRouteUpdateWithoutRosterInput, BusRouteUncheckedUpdateWithoutRosterInput>
  }

  export type BusRouteUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickupPoints?: PickupPointUpdateManyWithoutRouteNestedInput
  }

  export type BusRouteUncheckedUpdateWithoutRosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pickupPoints?: PickupPointUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DriverUpsertWithoutRosterInput = {
    update: XOR<DriverUpdateWithoutRosterInput, DriverUncheckedUpdateWithoutRosterInput>
    create: XOR<DriverCreateWithoutRosterInput, DriverUncheckedCreateWithoutRosterInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutRosterInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutRosterInput, DriverUncheckedUpdateWithoutRosterInput>
  }

  export type DriverUpdateWithoutRosterInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DriverUncheckedUpdateWithoutRosterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BusRouteCreateWithoutPickupPointsInput = {
    id: string
    name: string
    description?: string | null
    roster?: BusRosterCreateNestedManyWithoutRouteInput
  }

  export type BusRouteUncheckedCreateWithoutPickupPointsInput = {
    id: string
    name: string
    description?: string | null
    roster?: BusRosterUncheckedCreateNestedManyWithoutRouteInput
  }

  export type BusRouteCreateOrConnectWithoutPickupPointsInput = {
    where: BusRouteWhereUniqueInput
    create: XOR<BusRouteCreateWithoutPickupPointsInput, BusRouteUncheckedCreateWithoutPickupPointsInput>
  }

  export type BusRouteUpsertWithoutPickupPointsInput = {
    update: XOR<BusRouteUpdateWithoutPickupPointsInput, BusRouteUncheckedUpdateWithoutPickupPointsInput>
    create: XOR<BusRouteCreateWithoutPickupPointsInput, BusRouteUncheckedCreateWithoutPickupPointsInput>
    where?: BusRouteWhereInput
  }

  export type BusRouteUpdateToOneWithWhereWithoutPickupPointsInput = {
    where?: BusRouteWhereInput
    data: XOR<BusRouteUpdateWithoutPickupPointsInput, BusRouteUncheckedUpdateWithoutPickupPointsInput>
  }

  export type BusRouteUpdateWithoutPickupPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUpdateManyWithoutRouteNestedInput
  }

  export type BusRouteUncheckedUpdateWithoutPickupPointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roster?: BusRosterUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type StudentCreateWithoutFeesInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFeesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
  }

  export type FeePaymentCreateWithoutFeeInput = {
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
  }

  export type FeePaymentUncheckedCreateWithoutFeeInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
  }

  export type FeePaymentCreateOrConnectWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentCreateManyFeeInputEnvelope = {
    data: FeePaymentCreateManyFeeInput | FeePaymentCreateManyFeeInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutFeesInput = {
    update: XOR<StudentUpdateWithoutFeesInput, StudentUncheckedUpdateWithoutFeesInput>
    create: XOR<StudentCreateWithoutFeesInput, StudentUncheckedCreateWithoutFeesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeesInput, StudentUncheckedUpdateWithoutFeesInput>
  }

  export type StudentUpdateWithoutFeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FeePaymentUpsertWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    update: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
    create: XOR<FeePaymentCreateWithoutFeeInput, FeePaymentUncheckedCreateWithoutFeeInput>
  }

  export type FeePaymentUpdateWithWhereUniqueWithoutFeeInput = {
    where: FeePaymentWhereUniqueInput
    data: XOR<FeePaymentUpdateWithoutFeeInput, FeePaymentUncheckedUpdateWithoutFeeInput>
  }

  export type FeePaymentUpdateManyWithWhereWithoutFeeInput = {
    where: FeePaymentScalarWhereInput
    data: XOR<FeePaymentUpdateManyMutationInput, FeePaymentUncheckedUpdateManyWithoutFeeInput>
  }

  export type FeePaymentScalarWhereInput = {
    AND?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    OR?: FeePaymentScalarWhereInput[]
    NOT?: FeePaymentScalarWhereInput | FeePaymentScalarWhereInput[]
    id?: IntFilter<"FeePayment"> | number
    feeId?: IntFilter<"FeePayment"> | number
    amount?: DecimalFilter<"FeePayment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeNullableFilter<"FeePayment"> | Date | string | null
    method?: StringNullableFilter<"FeePayment"> | string | null
    reference?: StringNullableFilter<"FeePayment"> | string | null
    recordedBy?: StringNullableFilter<"FeePayment"> | string | null
  }

  export type StudentFeeCreateWithoutPaymentsInput = {
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
    student: StudentCreateNestedOneWithoutFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutPaymentsInput = {
    id?: number
    studentId: number
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
  }

  export type StudentFeeCreateOrConnectWithoutPaymentsInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutPaymentsInput, StudentFeeUncheckedCreateWithoutPaymentsInput>
  }

  export type StudentFeeUpsertWithoutPaymentsInput = {
    update: XOR<StudentFeeUpdateWithoutPaymentsInput, StudentFeeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StudentFeeCreateWithoutPaymentsInput, StudentFeeUncheckedCreateWithoutPaymentsInput>
    where?: StudentFeeWhereInput
  }

  export type StudentFeeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StudentFeeWhereInput
    data: XOR<StudentFeeUpdateWithoutPaymentsInput, StudentFeeUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentFeeUpdateWithoutPaymentsInput = {
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentCreateWithoutHealthLogsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutHealthLogsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutHealthLogsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutHealthLogsInput, StudentUncheckedCreateWithoutHealthLogsInput>
  }

  export type StudentUpsertWithoutHealthLogsInput = {
    update: XOR<StudentUpdateWithoutHealthLogsInput, StudentUncheckedUpdateWithoutHealthLogsInput>
    create: XOR<StudentCreateWithoutHealthLogsInput, StudentUncheckedCreateWithoutHealthLogsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutHealthLogsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutHealthLogsInput, StudentUncheckedUpdateWithoutHealthLogsInput>
  }

  export type StudentUpdateWithoutHealthLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutHealthLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CbtQuestionCreateWithoutTestInput = {
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
  }

  export type CbtQuestionUncheckedCreateWithoutTestInput = {
    id?: number
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
  }

  export type CbtQuestionCreateOrConnectWithoutTestInput = {
    where: CbtQuestionWhereUniqueInput
    create: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput>
  }

  export type CbtQuestionCreateManyTestInputEnvelope = {
    data: CbtQuestionCreateManyTestInput | CbtQuestionCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type CbtResultCreateWithoutTestInput = {
    score: number
    totalQuestions: number
    submittedAt?: Date | string
    student: StudentCreateNestedOneWithoutCbtResultsInput
  }

  export type CbtResultUncheckedCreateWithoutTestInput = {
    id?: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type CbtResultCreateOrConnectWithoutTestInput = {
    where: CbtResultWhereUniqueInput
    create: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput>
  }

  export type CbtResultCreateManyTestInputEnvelope = {
    data: CbtResultCreateManyTestInput | CbtResultCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type CbtQuestionUpsertWithWhereUniqueWithoutTestInput = {
    where: CbtQuestionWhereUniqueInput
    update: XOR<CbtQuestionUpdateWithoutTestInput, CbtQuestionUncheckedUpdateWithoutTestInput>
    create: XOR<CbtQuestionCreateWithoutTestInput, CbtQuestionUncheckedCreateWithoutTestInput>
  }

  export type CbtQuestionUpdateWithWhereUniqueWithoutTestInput = {
    where: CbtQuestionWhereUniqueInput
    data: XOR<CbtQuestionUpdateWithoutTestInput, CbtQuestionUncheckedUpdateWithoutTestInput>
  }

  export type CbtQuestionUpdateManyWithWhereWithoutTestInput = {
    where: CbtQuestionScalarWhereInput
    data: XOR<CbtQuestionUpdateManyMutationInput, CbtQuestionUncheckedUpdateManyWithoutTestInput>
  }

  export type CbtQuestionScalarWhereInput = {
    AND?: CbtQuestionScalarWhereInput | CbtQuestionScalarWhereInput[]
    OR?: CbtQuestionScalarWhereInput[]
    NOT?: CbtQuestionScalarWhereInput | CbtQuestionScalarWhereInput[]
    id?: IntFilter<"CbtQuestion"> | number
    testId?: IntFilter<"CbtQuestion"> | number
    questionText?: StringFilter<"CbtQuestion"> | string
    options?: JsonFilter<"CbtQuestion">
    correctAnswer?: StringFilter<"CbtQuestion"> | string
  }

  export type CbtResultUpsertWithWhereUniqueWithoutTestInput = {
    where: CbtResultWhereUniqueInput
    update: XOR<CbtResultUpdateWithoutTestInput, CbtResultUncheckedUpdateWithoutTestInput>
    create: XOR<CbtResultCreateWithoutTestInput, CbtResultUncheckedCreateWithoutTestInput>
  }

  export type CbtResultUpdateWithWhereUniqueWithoutTestInput = {
    where: CbtResultWhereUniqueInput
    data: XOR<CbtResultUpdateWithoutTestInput, CbtResultUncheckedUpdateWithoutTestInput>
  }

  export type CbtResultUpdateManyWithWhereWithoutTestInput = {
    where: CbtResultScalarWhereInput
    data: XOR<CbtResultUpdateManyMutationInput, CbtResultUncheckedUpdateManyWithoutTestInput>
  }

  export type CbtTestCreateWithoutQuestionsInput = {
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    results?: CbtResultCreateNestedManyWithoutTestInput
  }

  export type CbtTestUncheckedCreateWithoutQuestionsInput = {
    id?: number
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    results?: CbtResultUncheckedCreateNestedManyWithoutTestInput
  }

  export type CbtTestCreateOrConnectWithoutQuestionsInput = {
    where: CbtTestWhereUniqueInput
    create: XOR<CbtTestCreateWithoutQuestionsInput, CbtTestUncheckedCreateWithoutQuestionsInput>
  }

  export type CbtTestUpsertWithoutQuestionsInput = {
    update: XOR<CbtTestUpdateWithoutQuestionsInput, CbtTestUncheckedUpdateWithoutQuestionsInput>
    create: XOR<CbtTestCreateWithoutQuestionsInput, CbtTestUncheckedCreateWithoutQuestionsInput>
    where?: CbtTestWhereInput
  }

  export type CbtTestUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: CbtTestWhereInput
    data: XOR<CbtTestUpdateWithoutQuestionsInput, CbtTestUncheckedUpdateWithoutQuestionsInput>
  }

  export type CbtTestUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: CbtResultUpdateManyWithoutTestNestedInput
  }

  export type CbtTestUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: CbtResultUncheckedUpdateManyWithoutTestNestedInput
  }

  export type CbtTestCreateWithoutResultsInput = {
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    questions?: CbtQuestionCreateNestedManyWithoutTestInput
  }

  export type CbtTestUncheckedCreateWithoutResultsInput = {
    id?: number
    title: string
    type: string
    className: string
    subject: string
    durationMinutes: number
    isPublished?: boolean | null
    createdAt?: Date | string
    questions?: CbtQuestionUncheckedCreateNestedManyWithoutTestInput
  }

  export type CbtTestCreateOrConnectWithoutResultsInput = {
    where: CbtTestWhereUniqueInput
    create: XOR<CbtTestCreateWithoutResultsInput, CbtTestUncheckedCreateWithoutResultsInput>
  }

  export type StudentCreateWithoutCbtResultsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCbtResultsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCbtResultsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCbtResultsInput, StudentUncheckedCreateWithoutCbtResultsInput>
  }

  export type CbtTestUpsertWithoutResultsInput = {
    update: XOR<CbtTestUpdateWithoutResultsInput, CbtTestUncheckedUpdateWithoutResultsInput>
    create: XOR<CbtTestCreateWithoutResultsInput, CbtTestUncheckedCreateWithoutResultsInput>
    where?: CbtTestWhereInput
  }

  export type CbtTestUpdateToOneWithWhereWithoutResultsInput = {
    where?: CbtTestWhereInput
    data: XOR<CbtTestUpdateWithoutResultsInput, CbtTestUncheckedUpdateWithoutResultsInput>
  }

  export type CbtTestUpdateWithoutResultsInput = {
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: CbtQuestionUpdateManyWithoutTestNestedInput
  }

  export type CbtTestUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    durationMinutes?: IntFieldUpdateOperationsInput | number
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: CbtQuestionUncheckedUpdateManyWithoutTestNestedInput
  }

  export type StudentUpsertWithoutCbtResultsInput = {
    update: XOR<StudentUpdateWithoutCbtResultsInput, StudentUncheckedUpdateWithoutCbtResultsInput>
    create: XOR<StudentCreateWithoutCbtResultsInput, StudentUncheckedCreateWithoutCbtResultsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCbtResultsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCbtResultsInput, StudentUncheckedUpdateWithoutCbtResultsInput>
  }

  export type StudentUpdateWithoutCbtResultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCbtResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutPermissionSlipsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutPermissionSlipsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutPermissionSlipsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutPermissionSlipsInput, StudentUncheckedCreateWithoutPermissionSlipsInput>
  }

  export type StudentUpsertWithoutPermissionSlipsInput = {
    update: XOR<StudentUpdateWithoutPermissionSlipsInput, StudentUncheckedUpdateWithoutPermissionSlipsInput>
    create: XOR<StudentCreateWithoutPermissionSlipsInput, StudentUncheckedCreateWithoutPermissionSlipsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutPermissionSlipsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutPermissionSlipsInput, StudentUncheckedUpdateWithoutPermissionSlipsInput>
  }

  export type StudentUpdateWithoutPermissionSlipsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutPermissionSlipsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherCreateWithoutAppointmentsInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAppointmentsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAppointmentsInput, TeacherUncheckedCreateWithoutAppointmentsInput>
  }

  export type ParentCreateWithoutAppointmentsInput = {
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutParentProfileInput
    children?: ParentChildCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    userId?: number | null
    name: string
    email: string
    phone?: string | null
    avatarUrl?: string | null
    createdAt?: Date | string
    children?: ParentChildUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutAppointmentsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutAppointmentsInput, ParentUncheckedCreateWithoutAppointmentsInput>
  }

  export type TeacherUpsertWithoutAppointmentsInput = {
    update: XOR<TeacherUpdateWithoutAppointmentsInput, TeacherUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<TeacherCreateWithoutAppointmentsInput, TeacherUncheckedCreateWithoutAppointmentsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAppointmentsInput, TeacherUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TeacherUpdateWithoutAppointmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ParentUpsertWithoutAppointmentsInput = {
    update: XOR<ParentUpdateWithoutAppointmentsInput, ParentUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ParentCreateWithoutAppointmentsInput, ParentUncheckedCreateWithoutAppointmentsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutAppointmentsInput, ParentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ParentUpdateWithoutAppointmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutParentProfileNestedInput
    children?: ParentChildUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ParentChildUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TeacherCreateWithoutCreatedAiGamesInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutCreatedAiGamesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutCreatedAiGamesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutCreatedAiGamesInput, TeacherUncheckedCreateWithoutCreatedAiGamesInput>
  }

  export type TeacherUpsertWithoutCreatedAiGamesInput = {
    update: XOR<TeacherUpdateWithoutCreatedAiGamesInput, TeacherUncheckedUpdateWithoutCreatedAiGamesInput>
    create: XOR<TeacherCreateWithoutCreatedAiGamesInput, TeacherUncheckedCreateWithoutCreatedAiGamesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutCreatedAiGamesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutCreatedAiGamesInput, TeacherUncheckedUpdateWithoutCreatedAiGamesInput>
  }

  export type TeacherUpdateWithoutCreatedAiGamesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutCreatedAiGamesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutLessonPlansInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    generatedResources?: GeneratedResourceCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutLessonPlansInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    generatedResources?: GeneratedResourceUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutLessonPlansInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutLessonPlansInput, TeacherUncheckedCreateWithoutLessonPlansInput>
  }

  export type TeacherUpsertWithoutLessonPlansInput = {
    update: XOR<TeacherUpdateWithoutLessonPlansInput, TeacherUncheckedUpdateWithoutLessonPlansInput>
    create: XOR<TeacherCreateWithoutLessonPlansInput, TeacherUncheckedCreateWithoutLessonPlansInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutLessonPlansInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutLessonPlansInput, TeacherUncheckedUpdateWithoutLessonPlansInput>
  }

  export type TeacherUpdateWithoutLessonPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    generatedResources?: GeneratedResourceUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutLessonPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    generatedResources?: GeneratedResourceUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutGeneratedResourcesInput = {
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherProfileInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableCreateNestedManyWithoutTeacherInput
    exams?: ExamCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutGeneratedResourcesInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    email: string
    phone?: string | null
    status?: string | null
    createdAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    timetableEntries?: TimetableUncheckedCreateNestedManyWithoutTeacherInput
    exams?: ExamUncheckedCreateNestedManyWithoutTeacherInput
    createdAiGames?: AiGameUncheckedCreateNestedManyWithoutCreatorInput
    lessonPlans?: LessonPlanUncheckedCreateNestedManyWithoutTeacherInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutGeneratedResourcesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutGeneratedResourcesInput, TeacherUncheckedCreateWithoutGeneratedResourcesInput>
  }

  export type TeacherUpsertWithoutGeneratedResourcesInput = {
    update: XOR<TeacherUpdateWithoutGeneratedResourcesInput, TeacherUncheckedUpdateWithoutGeneratedResourcesInput>
    create: XOR<TeacherCreateWithoutGeneratedResourcesInput, TeacherUncheckedCreateWithoutGeneratedResourcesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutGeneratedResourcesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutGeneratedResourcesInput, TeacherUncheckedUpdateWithoutGeneratedResourcesInput>
  }

  export type TeacherUpdateWithoutGeneratedResourcesInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherProfileNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUpdateManyWithoutTeacherNestedInput
    exams?: ExamUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutGeneratedResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    timetableEntries?: TimetableUncheckedUpdateManyWithoutTeacherNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTeacherNestedInput
    createdAiGames?: AiGameUncheckedUpdateManyWithoutCreatorNestedInput
    lessonPlans?: LessonPlanUncheckedUpdateManyWithoutTeacherNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentCreateWithoutReportCardsInput = {
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    parents?: ParentChildCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    badges?: BadgeCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    awards?: AwardCreateNestedManyWithoutStudentInput
    submissions?: SubmissionCreateNestedManyWithoutStudentInput
    fees?: StudentFeeCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogCreateNestedManyWithoutStudentInput
    notifications?: NotificationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutReportCardsInput = {
    id?: number
    userId?: number | null
    name: string
    avatarUrl?: string | null
    grade: number
    section: string
    department?: string | null
    attendanceStatus?: string | null
    birthday?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentChildUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: StudentAttendanceUncheckedCreateNestedManyWithoutStudentInput
    academicPerformance?: AcademicPerformanceUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    badges?: BadgeUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    awards?: AwardUncheckedCreateNestedManyWithoutStudentInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutStudentInput
    fees?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    cbtResults?: CbtResultUncheckedCreateNestedManyWithoutStudentInput
    permissionSlips?: PermissionSlipUncheckedCreateNestedManyWithoutStudentInput
    healthLogs?: HealthLogUncheckedCreateNestedManyWithoutStudentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutReportCardsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
  }

  export type StudentUpsertWithoutReportCardsInput = {
    update: XOR<StudentUpdateWithoutReportCardsInput, StudentUncheckedUpdateWithoutReportCardsInput>
    create: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReportCardsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReportCardsInput, StudentUncheckedUpdateWithoutReportCardsInput>
  }

  export type StudentUpdateWithoutReportCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    parents?: ParentChildUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    badges?: BadgeUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    awards?: AwardUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutReportCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    attendanceStatus?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentChildUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: StudentAttendanceUncheckedUpdateManyWithoutStudentNestedInput
    academicPerformance?: AcademicPerformanceUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    badges?: BadgeUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    awards?: AwardUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutStudentNestedInput
    fees?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    cbtResults?: CbtResultUncheckedUpdateManyWithoutStudentNestedInput
    permissionSlips?: PermissionSlipUncheckedUpdateManyWithoutStudentNestedInput
    healthLogs?: HealthLogUncheckedUpdateManyWithoutStudentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type MessageCreateManySenderInput = {
    id?: number
    conversationId: number
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type ConversationParticipantCreateManyUserInput = {
    conversationId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    studentId?: number | null
    relatedId?: number | null
  }

  export type ComplaintCreateManyUserInput = {
    id?: string
    category: string
    rating?: number | null
    comment?: string | null
    status?: string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    conversationId?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    conversationId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ComplaintUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentChildCreateManyStudentInput = {
    id?: number
    parentId: number
  }

  export type StudentAttendanceCreateManyStudentInput = {
    id?: number
    date: Date | string
    status: string
    createdAt?: Date | string
  }

  export type AcademicPerformanceCreateManyStudentInput = {
    id?: number
    subject: string
    score?: number | null
    term: string
    session?: string | null
  }

  export type BehaviorRecordCreateManyStudentInput = {
    id?: number
    type: string
    title: string
    summary?: string | null
    timestamp?: Date | string
  }

  export type BadgeCreateManyStudentInput = {
    id?: number
    name: string
    description?: string | null
    iconName?: string | null
    color?: string | null
    awardedAt?: Date | string
  }

  export type CertificateCreateManyStudentInput = {
    id?: number
    name: string
    issuer?: string | null
    fileUrl?: string | null
    issuedDate?: Date | string | null
  }

  export type AwardCreateManyStudentInput = {
    id?: number
    name: string
    description?: string | null
    date?: Date | string | null
  }

  export type SubmissionCreateManyStudentInput = {
    id?: number
    assignmentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type StudentFeeCreateManyStudentInput = {
    id?: number
    totalFee: Decimal | DecimalJsLike | number | string
    paidAmount?: Decimal | DecimalJsLike | number | string | null
    dueDate: Date | string
    status?: string | null
  }

  export type CbtResultCreateManyStudentInput = {
    id?: number
    testId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type PermissionSlipCreateManyStudentInput = {
    id?: number
    title: string
    description?: string | null
    location?: string | null
    date?: Date | string | null
    status?: string | null
  }

  export type ReportCardCreateManyStudentInput = {
    id?: number
    session: string
    term: string
    status?: string | null
    classTeacherComment?: string | null
    principalComment?: string | null
    gradeAverage?: Decimal | DecimalJsLike | number | string | null
    position?: number | null
    totalStudents?: number | null
    attendancePercentage?: Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type HealthLogCreateManyStudentInput = {
    id?: number
    date: Date | string
    time?: string | null
    reason: string
    notes?: string | null
    parentNotified?: boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: string | null
  }

  export type NotificationCreateManyStudentInput = {
    id?: number
    userId?: number | null
    category: string
    title: string
    summary?: string | null
    isRead?: boolean | null
    timestamp?: Date | string
    relatedId?: number | null
  }

  export type ParentChildUpdateWithoutStudentInput = {
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type ParentChildUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentChildUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: IntFieldUpdateOperationsInput | number
  }

  export type StudentAttendanceUpdateWithoutStudentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicPerformanceUpdateWithoutStudentInput = {
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicPerformanceUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicPerformanceUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    term?: StringFieldUpdateOperationsInput | string
    session?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehaviorRecordUpdateWithoutStudentInput = {
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconName?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    awardedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificateUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificateUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AwardUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubmissionUpdateWithoutStudentInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentFeeUpdateWithoutStudentInput = {
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: FeePaymentUpdateManyWithoutFeeNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: FeePaymentUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type StudentFeeUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CbtResultUpdateWithoutStudentInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    test?: CbtTestUpdateOneRequiredWithoutResultsNestedInput
  }

  export type CbtResultUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtResultUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionSlipUpdateWithoutStudentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionSlipUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionSlipUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCardUpdateWithoutStudentInput = {
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCardUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    session?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    classTeacherComment?: NullableStringFieldUpdateOperationsInput | string | null
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    gradeAverage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    attendancePercentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    psychomotor?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HealthLogUpdateWithoutStudentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HealthLogUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HealthLogUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    medicationAdministered?: NullableJsonNullValueInput | InputJsonValue
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutStudentInput = {
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeacherSubjectCreateManyTeacherInput = {
    id?: number
    subject: string
  }

  export type TeacherClassCreateManyTeacherInput = {
    id?: number
    className: string
  }

  export type TimetableCreateManyTeacherInput = {
    id?: number
    day: string
    startTime: string
    endTime: string
    subject: string
    className: string
    status?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyTeacherInput = {
    id?: number
    type: string
    date: Date | string
    time: string
    className: string
    subject: string
    isPublished?: boolean | null
  }

  export type AiGameCreateManyCreatorInput = {
    id?: string
    title: string
    subject?: string | null
    difficultyLevel?: string | null
    status?: string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonPlanCreateManyTeacherInput = {
    id?: number
    subject?: string | null
    grade?: string | null
    topic?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedResourceCreateManyTeacherInput = {
    id?: number
    subject?: string | null
    className?: string | null
    term?: string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyTeacherInput = {
    id?: number
    parentId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type TeacherSubjectUpdateWithoutTeacherInput = {
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassUpdateWithoutTeacherInput = {
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
  }

  export type TimetableUpdateWithoutTeacherInput = {
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutTeacherInput = {
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ExamUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ExamUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    isPublished?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AiGameUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AiGameUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LessonPlanUpdateWithoutTeacherInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonPlanUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceUpdateWithoutTeacherInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResourceUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    className?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    schemeContent?: NullableJsonNullValueInput | InputJsonValue
    lessonPlansContent?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutTeacherInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentChildCreateManyParentInput = {
    id?: number
    studentId: number
  }

  export type AppointmentCreateManyParentInput = {
    id?: number
    teacherId?: number | null
    date: Date | string
    time: string
    reason?: string | null
    status?: string | null
    createdAt?: Date | string
  }

  export type ParentChildUpdateWithoutParentInput = {
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type ParentChildUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentChildUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
  }

  export type AppointmentUpdateWithoutParentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateManyAssignmentInput = {
    id?: number
    studentId: number
    submittedAt?: Date | string
    isLate?: boolean | null
    status?: string | null
    grade?: number | null
    feedback?: string | null
    textSubmission?: string | null
    fileUrl?: string | null
  }

  export type SubmissionUpdateWithoutAssignmentInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubmissionUncheckedUpdateManyWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isLate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    textSubmission?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateManyConversationInput = {
    id?: number
    senderId?: number | null
    content?: string | null
    type?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean | null
  }

  export type ConversationParticipantCreateManyConversationInput = {
    userId: number
    role?: string | null
    joinedAt?: Date | string | null
  }

  export type MessageUpdateWithoutConversationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sender?: UserUpdateOneWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutConversationsParticipatedNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    role?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ForumPostCreateManyTopicInput = {
    id?: number
    authorName: string
    content: string
    timestamp?: Date | string
  }

  export type ForumPostUpdateWithoutTopicInput = {
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyWithoutTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterCreateManyDriverInput = {
    id?: number
    routeId?: string | null
    date: Date | string
  }

  export type BusRosterUpdateWithoutDriverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: BusRouteUpdateOneWithoutRosterNestedInput
  }

  export type BusRosterUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    routeId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterCreateManyRouteInput = {
    id?: number
    driverId?: number | null
    date: Date | string
  }

  export type PickupPointCreateManyRouteInput = {
    id?: number
    name: string
    lat?: number | null
    lng?: number | null
    uiPositionTop?: string | null
    uiPositionLeft?: string | null
    isUserStop?: boolean | null
  }

  export type BusRosterUpdateWithoutRouteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneWithoutRosterNestedInput
  }

  export type BusRosterUncheckedUpdateWithoutRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusRosterUncheckedUpdateManyWithoutRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PickupPointUpdateWithoutRouteInput = {
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PickupPointUncheckedUpdateWithoutRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PickupPointUncheckedUpdateManyWithoutRouteInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    uiPositionTop?: NullableStringFieldUpdateOperationsInput | string | null
    uiPositionLeft?: NullableStringFieldUpdateOperationsInput | string | null
    isUserStop?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeePaymentCreateManyFeeInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string | null
    method?: string | null
    reference?: string | null
    recordedBy?: string | null
  }

  export type FeePaymentUpdateWithoutFeeInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeePaymentUncheckedUpdateWithoutFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeePaymentUncheckedUpdateManyWithoutFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CbtQuestionCreateManyTestInput = {
    id?: number
    questionText: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
  }

  export type CbtResultCreateManyTestInput = {
    id?: number
    studentId: number
    score: number
    totalQuestions: number
    submittedAt?: Date | string
  }

  export type CbtQuestionUpdateWithoutTestInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtQuestionUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtQuestionUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
  }

  export type CbtResultUpdateWithoutTestInput = {
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutCbtResultsNestedInput
  }

  export type CbtResultUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CbtResultUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherCountOutputTypeDefaultArgs instead
     */
    export type TeacherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentCountOutputTypeDefaultArgs instead
     */
    export type ParentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentCountOutputTypeDefaultArgs instead
     */
    export type AssignmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumTopicCountOutputTypeDefaultArgs instead
     */
    export type ForumTopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumTopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverCountOutputTypeDefaultArgs instead
     */
    export type DriverCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusRouteCountOutputTypeDefaultArgs instead
     */
    export type BusRouteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusRouteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentFeeCountOutputTypeDefaultArgs instead
     */
    export type StudentFeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentFeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CbtTestCountOutputTypeDefaultArgs instead
     */
    export type CbtTestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CbtTestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherDefaultArgs instead
     */
    export type TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentDefaultArgs instead
     */
    export type ParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentChildDefaultArgs instead
     */
    export type ParentChildArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentChildDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherSubjectDefaultArgs instead
     */
    export type TeacherSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherClassDefaultArgs instead
     */
    export type TeacherClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimetableDefaultArgs instead
     */
    export type TimetableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimetableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentAttendanceDefaultArgs instead
     */
    export type StudentAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentAttendanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicPerformanceDefaultArgs instead
     */
    export type AcademicPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehaviorRecordDefaultArgs instead
     */
    export type BehaviorRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehaviorRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AwardDefaultArgs instead
     */
    export type AwardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AwardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentDefaultArgs instead
     */
    export type AssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubmissionDefaultArgs instead
     */
    export type SubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoticeDefaultArgs instead
     */
    export type NoticeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoticeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationParticipantDefaultArgs instead
     */
    export type ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversationParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumTopicDefaultArgs instead
     */
    export type ForumTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumPostDefaultArgs instead
     */
    export type ForumPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComplaintDefaultArgs instead
     */
    export type ComplaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComplaintDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DriverDefaultArgs instead
     */
    export type DriverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DriverDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusRouteDefaultArgs instead
     */
    export type BusRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusRosterDefaultArgs instead
     */
    export type BusRosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusRosterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PickupPointDefaultArgs instead
     */
    export type PickupPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PickupPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentFeeDefaultArgs instead
     */
    export type StudentFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentFeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeePaymentDefaultArgs instead
     */
    export type FeePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeePaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreProductDefaultArgs instead
     */
    export type StoreProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreOrderDefaultArgs instead
     */
    export type StoreOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthLogDefaultArgs instead
     */
    export type HealthLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookDefaultArgs instead
     */
    export type BookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DigitalResourceDefaultArgs instead
     */
    export type DigitalResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DigitalResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CbtTestDefaultArgs instead
     */
    export type CbtTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CbtTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CbtQuestionDefaultArgs instead
     */
    export type CbtQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CbtQuestionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CbtResultDefaultArgs instead
     */
    export type CbtResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CbtResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CalendarEventDefaultArgs instead
     */
    export type CalendarEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CalendarEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExtracurricularActivityDefaultArgs instead
     */
    export type ExtracurricularActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExtracurricularActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PtaMeetingDefaultArgs instead
     */
    export type PtaMeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PtaMeetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolPolicyDefaultArgs instead
     */
    export type SchoolPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VolunteeringOpportunityDefaultArgs instead
     */
    export type VolunteeringOpportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VolunteeringOpportunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionSlipDefaultArgs instead
     */
    export type PermissionSlipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionSlipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PdResourceDefaultArgs instead
     */
    export type PdResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PdResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiGameDefaultArgs instead
     */
    export type AiGameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiGameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonPlanDefaultArgs instead
     */
    export type LessonPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GeneratedResourceDefaultArgs instead
     */
    export type GeneratedResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GeneratedResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCardDefaultArgs instead
     */
    export type ReportCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCardDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}